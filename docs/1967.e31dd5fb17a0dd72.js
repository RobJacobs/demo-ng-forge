"use strict";(self.webpackChunkdemo_ng_forge=self.webpackChunkdemo_ng_forge||[]).push([[1967],{10615:(U,B,u)=>{u.d(B,{f:()=>x});var F=u(71670),N=u(19420),i=u(28191),O=u(53661),D=u(13878),P=u(4907),t=u(87652),r=u(69923);const E=i.Z.getLogger("esri.views.webgl.BufferObject");class x{static createIndex(n,c,T){return new x(n,r.w0.ELEMENT_ARRAY_BUFFER,c,T)}static createVertex(n,c,T){return new x(n,r.w0.ARRAY_BUFFER,c,T)}static createUniform(n,c,T){if(n.type!==t.zO.WEBGL2)throw new Error("Uniform buffers are supported in WebGL2 only!");return new x(n,r.w0.UNIFORM_BUFFER,c,T)}static createPixelPack(n,c=r.l1.STREAM_READ,T){if(n.type!==t.zO.WEBGL2)throw new Error("Pixel pack buffers are supported in WebGL2 only!");const l=new x(n,r.w0.PIXEL_PACK_BUFFER,c);return T&&l.setSize(T),l}static createPixelUnpack(n,c=r.l1.STREAM_DRAW,T){if(n.type!==t.zO.WEBGL2)throw new Error("Pixel unpack buffers are supported in WebGL2 only!");return new x(n,r.w0.PIXEL_UNPACK_BUFFER,c,T)}constructor(n,c,T,l){this._context=n,this.bufferType=c,this.usage=T,this._glName=null,this._size=-1,this._indexType=void 0,n.instanceCounter.increment(r._g.BufferObject,this),this._glName=this._context.gl.createBuffer(),(0,P.zu)(this._context.gl),l&&this.setData(l)}get glName(){return this._glName}get size(){return this._size}get indexType(){return this._indexType}get byteSize(){return this.bufferType===r.w0.ELEMENT_ARRAY_BUFFER?this._indexType===r.g.UNSIGNED_INT?4*this._size:2*this._size:this._size}get _isVAOAware(){return this.bufferType===r.w0.ELEMENT_ARRAY_BUFFER||this.bufferType===r.w0.ARRAY_BUFFER}dispose(){this._context?.gl?(this._glName&&(this._context.gl.deleteBuffer(this._glName),this._glName=null),this._context.instanceCounter.decrement(r._g.BufferObject,this),this._context=(0,O.wN)(this._context)):this._glName&&E.warn("Leaked WebGL buffer object")}setSize(n,c=null){if(n<=0&&E.error("Buffer size needs to be positive!"),this.bufferType===r.w0.ELEMENT_ARRAY_BUFFER&&(0,O.pC)(c))switch(this._indexType=c,c){case r.g.UNSIGNED_SHORT:n*=2;break;case r.g.UNSIGNED_INT:n*=4}this._setBufferData(n)}setData(n){if(!n)return;let c=n.byteLength;this.bufferType===r.w0.ELEMENT_ARRAY_BUFFER&&((0,D.Uc)(n)&&(c/=2,this._indexType=r.g.UNSIGNED_SHORT),(0,D.ZY)(n)&&(c/=4,this._indexType=r.g.UNSIGNED_INT)),this._setBufferData(c,n)}_setBufferData(n,c=null){this._size=n;const T=this._context.getBoundVAO();this._isVAOAware&&this._context.bindVAO(null),this._context.bindBuffer(this);const l=this._context.gl;(0,O.pC)(c)?l.bufferData(this.bufferType,c,this.usage):l.bufferData(this.bufferType,n,this.usage),(0,P.zu)(l),this._isVAOAware&&this._context.bindVAO(T)}setSubData(n,c,T,l){if(!n)return;(c<0||c*n.BYTES_PER_ELEMENT>=this.byteSize)&&E.error("offset is out of range!"),T>=l&&E.error("end must be bigger than start!"),(c+(l-T))*n.BYTES_PER_ELEMENT>this.byteSize&&E.error("An attempt to write beyond the end of the buffer!");const R=this._context.getBoundVAO();this._isVAOAware&&this._context.bindVAO(null),this._context.bindBuffer(this);const h=this._context.gl;if(this._context.type===t.zO.WEBGL2)h.bufferSubData(this.bufferType,c*n.BYTES_PER_ELEMENT,n,T,l-T);else{const a=0===T&&l===n.length?n:n.subarray(T,l);h.bufferSubData(this.bufferType,c*n.BYTES_PER_ELEMENT,a)}(0,P.zu)(h),this._isVAOAware&&this._context.bindVAO(R)}getSubData(n,c=0,T,l){if(this._context.type!==t.zO.WEBGL2)return void E.error("Get buffer subdata is supported in WebGL2 only!");if(T<0||l<0)return void E.error("Problem getting subdata: offset and length were less than zero!");const R=function o(d){return(0,N.zG)(d)}(n)?n.BYTES_PER_ELEMENT:1;if(R*((T??0)+(l??0))>n.byteLength)return void E.error("Problem getting subdata: offset and length exceeded destination size!");c+R*(l??0)>this.byteSize&&E.warn("Potential problem getting subdata: requested data exceeds buffer size!");const h=this._context.gl;this._context.bindBuffer(this,r.w0.COPY_READ_BUFFER),h.getBufferSubData(r.w0.COPY_READ_BUFFER,c,n,T,l),this._context.unbindBuffer(r.w0.COPY_READ_BUFFER)}getSubDataAsync(n,c=0,T,l){var R=this;return(0,F.Z)(function*(){R._context.type===t.zO.WEBGL2?(yield R._context.clientWaitAsync(),R.getSubData(n,c,T,l)):E.error("Get buffer subdata is supported in WebGL2 only!")})()}}},2512:(U,B,u)=>{u.d(B,{X:()=>o});var F=u(71670),N=u(28191),i=u(53661),O=u(10615),D=u(4907),P=u(87652),t=u(69923),r=u(80806),E=u(74697),x=u(68267);class o{constructor(e,s,_=null,f=null){if(this._context=e,this._glName=null,this._depthAttachment=null,this._stencilAttachment=null,this._colorAttachments=new Map,this._depthStencilTexture=null,this._initialized=!1,this._desc={...s},e.instanceCounter.increment(t._g.FramebufferObject,this),(0,i.pC)(_)){Array.isArray(_)||(_=[_]);for(let m=0;m<_.length;++m){const A=_[m],g=t.VY.COLOR_ATTACHMENT0+m;let b;c(A)?(d(A)?(b=A.descriptor,this._colorAttachments.set(g,A)):(b=A,this._colorAttachments.set(g,new E.x(this._context,b))),l(b,this._desc)):(n(A)?(b=A.descriptor,this._colorAttachments.set(g,A)):(b=A,this._colorAttachments.set(g,new r.r(this._context,b))),R(b,this._desc)),this._validateColorAttachmentPoint(g)}}if((0,i.pC)(f)){let m,A;if(c(f))this._context.capabilities.depthTexture||console.error("Setting the depth/stencil texture as an attachment requires WEBGL_depth_texture or WebGL2"),d(f)?(A=f.descriptor,this._depthStencilTexture=f):(A=f,this._depthStencilTexture=new E.x(this._context,A)),l(A,this._desc);else{n(f)?(A=f.descriptor,m=f):(A=f,m=new r.r(this._context,A));const g=this._desc.depthStencilTarget??t.OU.DEPTH_STENCIL_RENDER_BUFFER;g===t.OU.STENCIL_RENDER_BUFFER?this._stencilAttachment=m:g===t.OU.DEPTH_RENDER_BUFFER||g===t.OU.DEPTH_STENCIL_RENDER_BUFFER?this._depthAttachment=m:console.error('If a Renderbuffer is provided, "depthStencilTarget" must be one of STENCIL_RENDER_BUFFER, DEPTH_RENDER_BUFFER or DEPTH_STENCIL_RENDER_BUFFER'),this._desc.depthStencilTarget=g,R(A,this._desc)}}}dispose(){if(!this._desc)return;const e=this._context.getBoundFramebufferObject();this._disposeColorAttachments(),this._disposeDepthStencilAttachments(),this._glName&&(this._context.gl.deleteFramebuffer(this._glName),this._glName=null),this._context.bindFramebuffer(e),this._context.instanceCounter.decrement(t._g.FramebufferObject,this),this._desc=null}get glName(){return this._glName}get descriptor(){return this._desc}get colorTexture(){const e=this._colorAttachments.get(t.VY.COLOR_ATTACHMENT0);return e&&d(e)?e:null}get colorAttachment(){return this._colorAttachments.get(t.VY.COLOR_ATTACHMENT0)}get depthStencilAttachment(){return this._depthStencilTexture||this._depthAttachment||this._stencilAttachment}get depthStencilTexture(){return this._depthStencilTexture}get width(){return this._desc.width??0}get height(){return this._desc.height??0}get gpuMemoryUsage(){return[...this._colorAttachments].reduce((e,[s,_])=>e+(0,x.un)(_),0)+(0,x.un)(this.depthStencilAttachment)}getColorTexture(e){const s=this._colorAttachments.get(e);return s&&d(s)?s:null}attachColorTexture(e,s=t.VY.COLOR_ATTACHMENT0){e&&(this._validateColorAttachmentPoint(s),l(e.descriptor,this._desc),this._disposeColorAttachments(),this._initialized&&(this._context.bindFramebuffer(this),this._framebufferTexture2D(e.glName,s)),this._colorAttachments.set(s,e))}detachColorTexture(e=t.VY.COLOR_ATTACHMENT0){const s=this._colorAttachments.get(e);if(d(s)){const _=s;return this._initialized&&(this._context.bindFramebuffer(this),this._framebufferTexture2D(null,e)),this._colorAttachments.delete(e),_}}setColorTextureTarget(e,s=t.VY.COLOR_ATTACHMENT0){const _=this._colorAttachments.get(s);d(_)&&this._framebufferTexture2D(_.glName,s,e)}attachDepthStencilTexture(e){if((0,i.Wi)(e))return;const s=e.descriptor;s.pixelFormat!==t.VI.DEPTH_STENCIL&&console.error("Depth/Stencil texture must have a pixel type of DEPTH_STENCIL!"),s.dataType!==t.Br.UNSIGNED_INT_24_8&&console.error("Depth/Stencil texture must have data type of UNSIGNED_INT_24_8!"),this._context.capabilities.depthTexture||console.error("Extension WEBGL_depth_texture isn't supported therefore it is no possible to set the depth/stencil texture!"),l(s,this._desc),this._desc.depthStencilTarget&&this._desc.depthStencilTarget!==t.OU.DEPTH_STENCIL_TEXTURE&&(this._desc.depthStencilTarget=t.OU.DEPTH_STENCIL_TEXTURE),this._disposeDepthStencilAttachments(),this._initialized&&(this._context.bindFramebuffer(this),this._framebufferTexture2D(e.glName,t.Lu)),this._depthStencilTexture=e}detachDepthStencilTexture(){const e=this._depthStencilTexture;return e&&this._initialized&&(this._context.bindFramebuffer(this),this._framebufferTexture2D(null,t.Lu)),this._depthStencilTexture=null,e}attachDepthStencilBuffer(e){if((0,i.Wi)(e))return;const s=e.descriptor;if(s.internalFormat!==t.Tg.DEPTH_STENCIL&&s.internalFormat!==t.Tg.DEPTH_COMPONENT16&&console.error("Depth/Stencil buffer must have correct internalFormat"),R(s,this._desc),this._disposeDepthStencilAttachments(),this._desc.depthStencilTarget=s.internalFormat===t.Tg.DEPTH_STENCIL?t.OU.DEPTH_STENCIL_RENDER_BUFFER:t.OU.DEPTH_RENDER_BUFFER,this._initialized){this._context.bindFramebuffer(this);const _=this._context.gl;_.framebufferRenderbuffer(t.qi.FRAMEBUFFER,this._desc.depthStencilTarget===t.OU.DEPTH_RENDER_BUFFER?_.DEPTH_ATTACHMENT:_.DEPTH_STENCIL_ATTACHMENT,_.RENDERBUFFER,e.glName)}this._depthAttachment=e}detachDepthStencilBuffer(){const e=this._context.gl,s=this._depthAttachment;return s&&this._initialized&&(this._context.bindFramebuffer(this),e.framebufferRenderbuffer(t.qi.FRAMEBUFFER,this._desc.depthStencilTarget===t.OU.DEPTH_RENDER_BUFFER?e.DEPTH_ATTACHMENT:e.DEPTH_STENCIL_ATTACHMENT,e.RENDERBUFFER,null)),this._depthAttachment=null,s}detachAll(){this._colorAttachments.forEach((e,s)=>this._detachColorAttachment(s)),this.detachDepthStencilBuffer(),this.detachDepthStencilTexture()}copyToTexture(e,s,_,f,m,A,g){(e<0||s<0||m<0||A<0)&&console.error("Offsets cannot be negative!"),(_<=0||f<=0)&&console.error("Copy width and height must be greater than zero!");const b=this._desc,C=g.descriptor;g.descriptor.target!==t.No.TEXTURE_2D&&console.error("Texture target must be TEXTURE_2D!"),(null==b?.width||null==b?.height||null==C?.width||null==C?.height||e+_>b.width||s+f>b.height||m+_>C.width||A+f>C.height)&&console.error("Bad dimensions, the current input values will attempt to read or copy out of bounds!");const p=this._context,S=p.bindTexture(g,E.x.TEXTURE_UNIT_FOR_UPDATES);p.setActiveTexture(E.x.TEXTURE_UNIT_FOR_UPDATES),p.bindFramebuffer(this),p.gl.copyTexSubImage2D(t.No.TEXTURE_2D,0,m,A,e,s,_,f),p.bindTexture(S,E.x.TEXTURE_UNIT_FOR_UPDATES)}readPixels(e,s,_,f,m,A,g){(_<=0||f<=0)&&console.error("Copy width and height must be greater than zero!"),g||console.error("Target memory is not initialized!"),this._context.bindFramebuffer(this),this._context.gl.readPixels(e,s,_,f,m,A,g)}readPixelsAsync(e,s,_,f,m,A,g){var b=this;return(0,F.Z)(function*(){if(b._context.type!==P.zO.WEBGL2)return(0,D.hZ)()&&console.warn("Attempting to read pixels using pixel buffer object without WebGL2"),void b.readPixels(e,s,_,f,m,A,g);const C=b._context.gl,p=O.f.createPixelPack(b._context,t.l1.STREAM_READ,g.byteLength);b._context.bindBuffer(p),b._context.bindFramebuffer(b),C.readPixels(e,s,_,f,m,A,0),b._context.unbindBuffer(t.w0.PIXEL_PACK_BUFFER),yield p.getSubDataAsync(g),p.dispose()})()}resize(e,s){const _=this._desc;if(_.width!==e||_.height!==s){if(_.width=e,_.height=s,!this._initialized)return this._colorAttachments.forEach(f=>{f&&f.resize(e,s)}),void(this._depthStencilTexture&&this._depthStencilTexture.resize(e,s));this._colorAttachments.forEach(f=>{f&&f.resize(e,s)}),null!=this._depthStencilTexture?this._depthStencilTexture.resize(e,s):(this._depthAttachment||this._stencilAttachment)&&(this._depthAttachment&&this._depthAttachment.resize(e,s),this._stencilAttachment&&this._stencilAttachment.resize(e,s)),this._context.getBoundFramebufferObject()===this&&this._context.bindFramebuffer(null),this._initialized=!1}}initializeAndBind(e=t.qi.FRAMEBUFFER){const s=this._context.gl;if(this._initialized)return void s.bindFramebuffer(e,this.glName);this._glName&&s.deleteFramebuffer(this._glName);const _=this._context,f=s.createFramebuffer(),m=this._desc,A=m.colorTarget??t.Lm.RENDER_BUFFER,g=m.width??1,b=m.height??1;if(s.bindFramebuffer(e,f),0===this._colorAttachments.size)if(A===t.Lm.TEXTURE||A===t.Lm.CUBEMAP)this._colorAttachments.set(t.VY.COLOR_ATTACHMENT0,function T(a,e,s){return new E.x(a,{target:s,pixelFormat:t.VI.RGBA,dataType:t.Br.UNSIGNED_BYTE,samplingMode:t.cw.NEAREST,wrapMode:t.e8.CLAMP_TO_EDGE,width:e.width,height:e.height})}(_,m,this.descriptor.colorTarget===t.Lm.CUBEMAP?t.No.TEXTURE_CUBE_MAP:t.No.TEXTURE_2D));else{const p=new r.r(_,{internalFormat:t.lP.RGBA4,width:g,height:b});this._colorAttachments.set(t.VY.COLOR_ATTACHMENT0,p)}this._colorAttachments.forEach((p,S)=>{p&&(d(p)?this._framebufferTexture2D(p.glName,S,h(p),e):s.framebufferRenderbuffer(e,S,s.RENDERBUFFER,p.glName))});const C=m.depthStencilTarget??t.OU.NONE;switch(C){case t.OU.DEPTH_RENDER_BUFFER:case t.OU.DEPTH_STENCIL_RENDER_BUFFER:this._depthAttachment||(this._depthAttachment=new r.r(_,{internalFormat:m.depthStencilTarget===t.OU.DEPTH_RENDER_BUFFER?t.Tg.DEPTH_COMPONENT16:t.Tg.DEPTH_STENCIL,width:g,height:b})),s.framebufferRenderbuffer(e,C===t.OU.DEPTH_RENDER_BUFFER?s.DEPTH_ATTACHMENT:s.DEPTH_STENCIL_ATTACHMENT,s.RENDERBUFFER,this._depthAttachment.glName);break;case t.OU.STENCIL_RENDER_BUFFER:this._stencilAttachment||(this._stencilAttachment=new r.r(_,{internalFormat:t.Tg.STENCIL_INDEX8,width:g,height:b})),s.framebufferRenderbuffer(e,s.STENCIL_ATTACHMENT,s.RENDERBUFFER,this._stencilAttachment.glName);break;case t.OU.DEPTH_STENCIL_TEXTURE:this._depthStencilTexture||(_.capabilities.depthTexture||console.error("Extension WEBGL_depth_texture isn't supported therefore it is no possible to set the depth/stencil texture as an attachment!"),this._depthStencilTexture=new E.x(_,{target:t.No.TEXTURE_2D,pixelFormat:t.VI.DEPTH_STENCIL,dataType:t.Br.UNSIGNED_INT_24_8,samplingMode:t.cw.NEAREST,wrapMode:t.e8.CLAMP_TO_EDGE,width:g,height:b})),this._framebufferTexture2D(this._depthStencilTexture.glName,s.DEPTH_STENCIL_ATTACHMENT,h(this._depthStencilTexture),e)}(0,D.hZ)()&&s.checkFramebufferStatus(e)!==s.FRAMEBUFFER_COMPLETE&&console.error("Framebuffer is incomplete!"),this._glName=f,this._initialized=!0}_framebufferTexture2D(e,s=t.VY.COLOR_ATTACHMENT0,_=t.No.TEXTURE_2D,f=t.qi.FRAMEBUFFER,m=0){this._context.gl.framebufferTexture2D(f,s,_,e,m)}_detachColorAttachment(e){(0,D.hZ)()&&console.warn("Detaching an FBO attachment can be a slow due to invalidating framebuffer completeness!");const s=this._context.gl,_=this._colorAttachments.get(e);return d(_)?this._initialized&&(this._context.bindFramebuffer(this),this._framebufferTexture2D(null,e)):this._initialized&&(this._context.bindFramebuffer(this),s.framebufferRenderbuffer(t.qi.FRAMEBUFFER,e,s.RENDERBUFFER,null)),this._colorAttachments.delete(e),_}_disposeColorAttachments(){this._colorAttachments.forEach((e,s)=>{this._detachColorAttachment(s),e.dispose()}),this._colorAttachments.clear()}_disposeDepthStencilAttachments(){const e=this._context.gl;this._depthAttachment&&(this._initialized&&(this._context.bindFramebuffer(this),e.framebufferRenderbuffer(t.qi.FRAMEBUFFER,this._desc.depthStencilTarget===t.OU.DEPTH_RENDER_BUFFER?e.DEPTH_ATTACHMENT:e.DEPTH_STENCIL_ATTACHMENT,e.RENDERBUFFER,null)),this._depthAttachment.dispose(),this._depthAttachment=null),this._stencilAttachment&&(this._initialized&&(this._context.bindFramebuffer(this),e.framebufferRenderbuffer(t.qi.FRAMEBUFFER,e.STENCIL_ATTACHMENT,e.RENDERBUFFER,null)),this._stencilAttachment.dispose(),this._stencilAttachment=null),this._depthStencilTexture&&(this._initialized&&(this._context.bindFramebuffer(this),this._framebufferTexture2D(null,e.DEPTH_STENCIL_ATTACHMENT)),this._depthStencilTexture.dispose(),this._depthStencilTexture=null)}_validateColorAttachmentPoint(e){if(-1===o._MAX_COLOR_ATTACHMENTS){const _=this._context.capabilities.drawBuffers;o._MAX_COLOR_ATTACHMENTS=_?this._context.gl.getParameter(_.MAX_COLOR_ATTACHMENTS):1}const s=e-t.VY.COLOR_ATTACHMENT0;s+1>o._MAX_COLOR_ATTACHMENTS&&N.Z.getLogger("esri.views.webgl.FrameBufferObject").error("esri.FrameBufferObject",`illegal attachment point for color attachment: ${s+1}. Implementation supports up to ${o._MAX_COLOR_ATTACHMENTS} color attachments`)}}function d(a){return null!=a&&"type"in a&&"texture"===a.type}function n(a){return null!=a&&"type"in a&&"renderbuffer"===a.type}function c(a){return d(a)||null!=a&&"pixelFormat"in a}function l(a,e){a.target!==t.No.TEXTURE_2D&&a.target!==t.No.TEXTURE_CUBE_MAP&&console.error("Texture type must be TEXTURE_2D or TEXTURE_CUBE_MAP!"),void 0!==e.width&&e.width>=0&&void 0!==e.height&&e.height>=0?e.width===a.width&&e.height===a.height||console.error("Color attachment texture must match the framebuffer's!"):(e.width=a.width,e.height=a.height)}function R(a,e){void 0!==e.width&&e.width>=0&&void 0!==e.height&&e.height>=0?e.width===a.width&&e.height===a.height||console.error("Renderbuffer dimensions must match the framebuffer's!"):(e.width=a.width,e.height=a.height)}function h(a){return a.descriptor.target===t.No.TEXTURE_CUBE_MAP?t.No.TEXTURE_CUBE_MAP_POSITIVE_X:t.No.TEXTURE_2D}o._MAX_COLOR_ATTACHMENTS=-1},80806:(U,B,u)=>{u.d(B,{r:()=>O});var F=u(53661),N=u(87652),i=u(69923);class O{constructor(P,t){this._context=P,this._desc=t,this.type="renderbuffer",this._context.instanceCounter.increment(i._g.Renderbuffer,this);const r=this._context.gl;this.glName=r.createRenderbuffer(),this._context.bindRenderbuffer(this);const{width:E,height:x,internalFormat:o,multisampled:d}=t;if(d){if(this._context.type!==N.zO.WEBGL2)throw new Error("Multisampled renderbuffers are not supported in WebGL1!");r.renderbufferStorageMultisample(r.RENDERBUFFER,this.samples,o,E,x)}else r.renderbufferStorage(r.RENDERBUFFER,o,E,x)}get descriptor(){return this._desc}get samples(){const P=this._desc.samples,t=this._context.parameters.maxSamples;return P?Math.min(P,t):t}resize(P,t){const r=this._desc;if(r.width===P&&r.height===t)return;r.width=P,r.height=t;const E=this._context.gl;this._context.bindRenderbuffer(this),r.multisampled?E.renderbufferStorageMultisample(E.RENDERBUFFER,this.samples,r.internalFormat,r.width,r.height):E.renderbufferStorage(E.RENDERBUFFER,r.internalFormat,r.width,r.height)}dispose(){this._context&&(this._context.gl.deleteRenderbuffer(this.glName),this._context.instanceCounter.decrement(i._g.Renderbuffer,this),this._context=(0,F.wN)(this._context))}}},68267:(U,B,u)=>{u.d(B,{HH:()=>O,RG:()=>E,UF:()=>r,XP:()=>t,_V:()=>D,un:()=>x}),u(67087);var N=u(53661),i=u(69923);function O(o){const d=o.gl;switch(d.getError()){case d.NO_ERROR:return null;case d.INVALID_ENUM:return"An unacceptable value has been specified for an enumerated argument";case d.INVALID_VALUE:return"An unacceptable value has been specified for an argument";case d.INVALID_OPERATION:return"The specified command is not allowed for the current state";case d.INVALID_FRAMEBUFFER_OPERATION:return"The currently bound framebuffer is not framebuffer complete";case d.OUT_OF_MEMORY:return"Not enough memory is left to execute the command";case d.CONTEXT_LOST_WEBGL:return"WebGL context is lost"}return"Unknown error"}function D(o,d){return o.vertexBuffers[d].size/function P(o){return o[0].stride}(o.layout[d])}function t(o,d,n,c,T=0){const l=o.gl,R=o.capabilities.instancing;o.bindBuffer(n);for(const h of c){const a=d.get(h.name);void 0===a&&console.error(`There is no location for vertex attribute '${h.name}' defined.`);const e=T*h.stride;if(h.count<=4)l.vertexAttribPointer(a,h.count,h.type,h.normalized,h.stride,h.offset+e),l.enableVertexAttribArray(a),h.divisor>0&&R&&R.vertexAttribDivisor(a,h.divisor);else if(9===h.count)for(let s=0;s<3;s++)l.vertexAttribPointer(a+s,3,h.type,h.normalized,h.stride,h.offset+12*s+e),l.enableVertexAttribArray(a+s),h.divisor>0&&R&&R.vertexAttribDivisor(a+s,h.divisor);else if(16===h.count)for(let s=0;s<4;s++)l.vertexAttribPointer(a+s,4,h.type,h.normalized,h.stride,h.offset+16*s+e),l.enableVertexAttribArray(a+s),h.divisor>0&&R&&R.vertexAttribDivisor(a+s,h.divisor);else console.error("Unsupported vertex attribute element count: "+h.count)}}function r(o,d,n,c){const T=o.gl,l=o.capabilities.instancing;o.bindBuffer(n);for(const R of c){const h=d.get(R.name);if(R.count<=4)T.disableVertexAttribArray(h),R.divisor&&R.divisor>0&&l&&l.vertexAttribDivisor(h,0);else if(9===R.count)for(let a=0;a<3;a++)T.disableVertexAttribArray(h+a),R.divisor&&R.divisor>0&&l&&l.vertexAttribDivisor(h+a,0);else if(16===R.count)for(let a=0;a<4;a++)T.disableVertexAttribArray(h+a),R.divisor&&R.divisor>0&&l&&l.vertexAttribDivisor(h+a,0);else console.error("Unsupported vertex attribute element count: "+R.count)}o.unbindBuffer(i.w0.ARRAY_BUFFER)}function E(o){switch(o){case i.VI.ALPHA:case i.VI.LUMINANCE:case i.VI.RED:case i.VI.RED_INTEGER:case i.lP.R8:case i.lP.R8I:case i.lP.R8UI:case i.lP.R8_SNORM:case i.Tg.STENCIL_INDEX8:return 1;case i.VI.LUMINANCE_ALPHA:case i.VI.RG:case i.VI.RG_INTEGER:case i.lP.RGBA4:case i.lP.R16F:case i.lP.R16I:case i.lP.R16UI:case i.lP.RG8:case i.lP.RG8I:case i.lP.RG8UI:case i.lP.RG8_SNORM:case i.lP.RGB565:case i.lP.RGB5_A1:case i.Tg.DEPTH_COMPONENT16:return 2;case i.VI.DEPTH_COMPONENT:case i.VI.RGB:case i.VI.RGB_INTEGER:case i.lP.RGB8:case i.lP.RGB8I:case i.lP.RGB8UI:case i.lP.RGB8_SNORM:case i.lP.SRGB8:case i.Tg.DEPTH_COMPONENT24:return 3;case i.VI.DEPTH_STENCIL:case i.VI.RGBA:case i.VI.RGBA_INTEGER:case i.lP.RGBA8:case i.lP.R32F:case i.lP.R11F_G11F_B10F:case i.lP.RG16F:case i.lP.R32I:case i.lP.R32UI:case i.lP.RG16I:case i.lP.RG16UI:case i.lP.RGBA8I:case i.lP.RGBA8UI:case i.lP.RGBA8_SNORM:case i.lP.SRGB8_ALPHA8:case i.lP.RGB9_E5:case i.lP.RGB10_A2UI:case i.lP.RGB10_A2:case i.Tg.DEPTH_STENCIL:case i.Tg.DEPTH_COMPONENT32F:case i.Tg.DEPTH24_STENCIL8:return 4;case i.Tg.DEPTH32F_STENCIL8:return 5;case i.lP.RGB16F:case i.lP.RGB16I:case i.lP.RGB16UI:return 6;case i.lP.RG32F:case i.lP.RG32I:case i.lP.RG32UI:case i.lP.RGBA16F:case i.lP.RGBA16I:case i.lP.RGBA16UI:return 8;case i.lP.RGB32F:case i.lP.RGB32I:case i.lP.RGB32UI:return 12;case i.lP.RGBA32F:case i.lP.RGBA32I:case i.lP.RGBA32UI:return 16;case i.q_.COMPRESSED_RGB_S3TC_DXT1_EXT:case i.q_.COMPRESSED_RGBA_S3TC_DXT1_EXT:return.5;case i.q_.COMPRESSED_RGBA_S3TC_DXT3_EXT:case i.q_.COMPRESSED_RGBA_S3TC_DXT5_EXT:return 1;case i.q_.COMPRESSED_R11_EAC:case i.q_.COMPRESSED_SIGNED_R11_EAC:case i.q_.COMPRESSED_RGB8_ETC2:case i.q_.COMPRESSED_SRGB8_ETC2:case i.q_.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case i.q_.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:return.5;case i.q_.COMPRESSED_RG11_EAC:case i.q_.COMPRESSED_SIGNED_RG11_EAC:case i.q_.COMPRESSED_RGBA8_ETC2_EAC:case i.q_.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return 1}return 0}function x(o){if((0,N.Wi)(o))return 0;if("descriptor"in o)return o.glName?x(o.descriptor):0;const d=o.internalFormat||"pixelFormat"in o&&o.pixelFormat;if(!d)return 0;const n="hasMipmap"in o&&o.hasMipmap?1.3:1,c=o.width*o.height;return E(d)*c*n}},19955:(U,B,u)=>{u.d(B,{U:()=>P});var F=u(28191),N=u(53661),i=u(69923),O=u(68267);const D=F.Z.getLogger("esri.views.webgl.VertexArrayObject");let P=class{constructor(t,r,E,x,o=null){this._context=t,this._locations=r,this._layout=E,this._buffers=x,this._indexBuffer=o,this._glName=null,this._initialized=!1,t.instanceCounter.increment(i._g.VertexArrayObject,this)}get glName(){return this._glName}get context(){return this._context}get vertexBuffers(){return this._buffers}get indexBuffer(){return this._indexBuffer}get size(){return Object.keys(this._buffers).reduce((t,r)=>t+this._buffers[r].size,(0,N.pC)(this._indexBuffer)?this._indexBuffer.size:0)}get layout(){return this._layout}get locations(){return this._locations}dispose(t=!0){if(this._context){if(this._glName){const r=this._context?.capabilities?.vao;r?(r.deleteVertexArray(this._glName),this._glName=null):D.warn("Leaked WebGL VAO")}if(this._context.getBoundVAO()===this&&this._context.bindVAO(null),t){for(const r in this._buffers)this._buffers[r]?.dispose(),delete this._buffers[r];this._indexBuffer=(0,N.M2)(this._indexBuffer)}this._context.instanceCounter.decrement(i._g.VertexArrayObject,this),this._context=(0,N.wN)(this._context)}else(this._glName||t&&Object.getOwnPropertyNames(this._buffers).length>0)&&D.warn("Leaked WebGL VAO")}initialize(){if(this._initialized)return;const t=this._context.capabilities.vao;if(t){const r=t.createVertexArray();t.bindVertexArray(r),this._bindLayout(),t.bindVertexArray(null),this._glName=r}this._initialized=!0}bind(){this.initialize();const t=this._context.capabilities.vao;t?t.bindVertexArray(this.glName):(this._context.bindVAO(null),this._bindLayout())}_bindLayout(){const{_buffers:t,_layout:r,_indexBuffer:E}=this;t||D.error("Vertex buffer dictionary is empty!");const x=this._context.gl;for(const o in t){const d=t[o];d||D.error("Vertex buffer is uninitialized!");const n=r[o];n||D.error("Vertex element descriptor is empty!"),(0,O.XP)(this._context,this._locations,d,n)}(0,N.pC)(E)&&(this._context.capabilities.vao?x.bindBuffer(x.ELEMENT_ARRAY_BUFFER,E.glName):this._context.bindBuffer(E))}unbind(){this.initialize();const t=this._context.capabilities.vao;t?t.bindVertexArray(null):this._unbindLayout()}_unbindLayout(){const{_buffers:t,_layout:r}=this;t||D.error("Vertex buffer dictionary is empty!");for(const E in t){const x=t[E];x||D.error("Vertex buffer is uninitialized!"),(0,O.UF)(this._context,this._locations,x,r[E])}(0,N.pC)(this._indexBuffer)&&this._context.unbindBuffer(this._indexBuffer.bufferType)}}}}]);
//# sourceMappingURL=1967.e31dd5fb17a0dd72.js.map