{
  "version": 3,
  "sources": ["src/utils.ts"],
  "sourcesContent": ["import { formatDate, formatNumber, Location } from '@angular/common';\nimport { HttpParams } from '@angular/common/http';\nimport { Router } from '@angular/router';\nimport { isArray, getPropertyValue, isDefined, isString, isObject } from '@tylertech/forge-core';\nimport { SortDirection } from '@tylertech/forge';\n\nexport class Utils {\n  public static sortData(data: any[], key: string, type: 'string' | 'number' | 'boolean' | 'date', direction: 'ASC' | 'DESC' | SortDirection): any[] {\n    if (!data || !data.length) {\n      return data;\n    }\n\n    type = type || 'string';\n\n    if (direction !== 'DESC') {\n      direction = 'ASC';\n    }\n\n    return data.slice().sort((a, b): number => {\n      a = getPropertyValue(a, key);\n      b = getPropertyValue(b, key);\n\n      if (direction === 'DESC') {\n        return this.comparator(b, a, type);\n      } else {\n        return this.comparator(a, b, type);\n      }\n    });\n  }\n\n  public static groupData(data: any[], property: string): any[] {\n    if (!isArray(data) || !data.length || !property?.length) {\n      return data;\n    }\n\n    return data.reduce((previousValue, currentValue) => {\n      const key = currentValue[property];\n      if (!previousValue[key]) {\n        previousValue[key] = [];\n      }\n      previousValue[key].push(currentValue);\n      return previousValue;\n    }, {});\n  }\n\n  public static filterData(\n    data: any[],\n    filters: {\n      key: string;\n      value: string;\n      type?: 'string' | 'number' | 'boolean' | 'date';\n      strict?: boolean;\n    }[]\n  ): any[] {\n    if (!isArray(data) || !data.length || !isArray(filters) || !filters.length) {\n      return data;\n    }\n\n    filters = filters.map((f) => {\n      if (isString(f.value) && f.value.length) {\n        let operator;\n        if (f.value.substring(0, 2) === '<>') {\n          if (f.value.length === 2) {\n            f.value = '';\n            return f;\n          }\n          operator = f.value.substring(0, 2);\n          f.value = f.value.substring(2);\n        } else if (f.value.substring(0, 1) === '<' || f.value.substring(0, 1) === '>') {\n          if (f.value.length === 1) {\n            f.value = '';\n            return f;\n          }\n          operator = f.value.substring(0, 1);\n          f.value = f.value.substring(1);\n        }\n\n        if (operator) {\n          Object.defineProperty(f, 'operator', { value: operator });\n        }\n      }\n\n      f.value = ('' + f.value).toLowerCase();\n      return f;\n    });\n\n    const filter = (rec: any) =>\n      filters.every((f) => {\n        if (!f.value.length) {\n          return true;\n        }\n\n        const value = ('' + getPropertyValue(rec, f.key)).toLowerCase();\n        if (!value.length) {\n          return false;\n        }\n\n        if (f.strict) {\n          return value === f.value;\n        }\n\n        switch ((f as any).operator) {\n          case '<>':\n            return this.comparator(value, f.value, f.type) !== 0;\n          case '>':\n            return this.comparator(value, f.value, f.type) > 0;\n          case '<':\n            return this.comparator(value, f.value, f.type) < 0;\n          default:\n            return value.indexOf(f.value) > -1;\n        }\n      });\n\n    return data.filter((rec) => filter(rec));\n  }\n\n  public static comparator(a: any, b: any, type: 'string' | 'number' | 'boolean' | 'date' = 'string'): number {\n    // eslint-disable-next-line\n    if (a == b) {\n      return 0;\n    }\n    if (!isDefined(a)) {\n      return -1;\n    }\n    if (!isDefined(b)) {\n      return 1;\n    }\n\n    switch (type) {\n      case 'boolean':\n        return a ? -1 : 1;\n      case 'date':\n        a = new Date(a).getTime();\n        if (isNaN(a)) {\n          return -1;\n        }\n        b = new Date(b).getTime();\n        if (isNaN(b)) {\n          return 1;\n        }\n        break;\n      case 'number':\n        a = parseFloat(a);\n        if (isNaN(a)) {\n          return -1;\n        }\n        b = parseFloat(b);\n        if (isNaN(b)) {\n          return 1;\n        }\n        break;\n      default:\n        if (!isNaN(parseFloat(a)) && !isNaN(parseFloat(b))) {\n          return ('' + a).localeCompare('' + b, navigator.language, {\n            numeric: true\n          });\n        } else {\n          return ('' + a).localeCompare('' + b, navigator.language, {\n            sensitivity: 'base'\n          });\n        }\n    }\n\n    return a < b ? -1 : a > b ? 1 : 0;\n  }\n\n  public static navigateBack(location: Location, router: Router, fallbackRoute: any[]) {\n    if ((location.getState() as any)?.navigationId === 1) {\n      router.navigate(fallbackRoute);\n    } else {\n      location.back();\n    }\n  }\n\n  public static elementId(prefix: string): string {\n    return (\n      prefix +\n      Math.random()\n        .toString(36)\n        .replace(/[^a-z]+/g, '')\n    );\n  }\n\n  public static formatDate(value: Date, format = 'MM/dd/yyyy'): string {\n    if (!isDefined(value)) {\n      return '';\n    }\n    return formatDate(value, format, navigator.language);\n  }\n\n  public static formatNumber(value: number, format = '1.2-2'): string {\n    return formatNumber(value, navigator.language, format);\n  }\n\n  public static uniqueId(): string {\n    return Math.random().toString(36).substring(2);\n  }\n\n  public static parseQueryStringParameters(): any {\n    const params = {};\n    const queryIndex = window.location.href.indexOf('?');\n    if (queryIndex !== -1) {\n      const httpParams = new HttpParams({\n        fromString: window.location.href.substring(queryIndex)\n      });\n      httpParams.keys().forEach((k) => {\n        const value = httpParams.getAll(k) as string[];\n        if (value.length) {\n          Object.defineProperty(params, k.toLowerCase(), {\n            value: value.length === 1 ? value[0] : value,\n            enumerable: true,\n            writable: true\n          });\n        }\n      });\n    }\n\n    return params;\n  }\n\n  public static objectReduce(obj: object): object {\n    const reduced: any = {};\n\n    Object.keys(obj).forEach((key) => {\n      if (isDefined(obj[key])) {\n        if (isArray(obj[key])) {\n          if (obj[key].length) {\n            reduced[key] = obj[key];\n          }\n        } else if ((obj[key] + '').trim().length) {\n          reduced[key] = typeof obj[key] === 'string' ? obj[key].trim() : obj[key];\n        }\n      }\n    });\n\n    return reduced;\n  }\n\n  public static objectPropertyPaths(obj: object, parentKey?: string): Map<string, string> {\n    // return Object.keys(obj).reduce((prev, curr) => {\n    //   const value = obj[curr];\n    //   const key = parentKey ? `${parentKey}.${curr}` : `${curr}`;\n    //   if (value && typeof value === 'object') {\n    //     return { ...prev, ...this.objectPropertyPaths(value, key) };\n    //   } else {\n    //     return { ...prev, [key]: value };\n    //   }\n    // }, {});\n\n    const result = new Map<string, string>();\n    Object.keys(obj).forEach((key) => {\n      const path = parentKey?.length ? `${parentKey}.${key}` : key;\n      const value = obj[key];\n      if (isObject(value)) {\n        Object.assign(result, this.objectPropertyPaths(obj[key], path));\n      } else {\n        result[path] = value;\n      }\n    });\n\n    return result;\n  }\n}\n"],
  "mappings": "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",
  "names": ["Utils", "sortData", "data", "key", "type", "direction", "length", "slice", "sort", "a", "b", "getPropertyValue", "comparator", "groupData", "property", "isArray", "reduce", "previousValue", "currentValue", "push", "filterData", "filters", "map", "f", "isString", "value", "operator", "substring", "Object", "defineProperty", "toLowerCase", "filter", "rec", "every", "strict", "indexOf", "isDefined", "Date", "getTime", "isNaN", "parseFloat", "localeCompare", "navigator", "language", "numeric", "sensitivity", "navigateBack", "location", "router", "fallbackRoute", "getState", "navigationId", "navigate", "back", "elementId", "prefix", "Math", "random", "toString", "replace", "formatDate", "format", "formatNumber", "uniqueId", "parseQueryStringParameters", "params", "queryIndex", "window", "href", "httpParams", "HttpParams", "fromString", "keys", "forEach", "k", "getAll", "enumerable", "writable", "objectReduce", "obj", "reduced", "trim", "objectPropertyPaths", "parentKey", "result", "Map", "path", "isObject", "assign"]
}
