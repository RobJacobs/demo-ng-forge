"use strict";(self.webpackChunkdemo_ng_forge=self.webpackChunkdemo_ng_forge||[]).push([[1850],{65489:(ae,Wt,G)=>{G.d(Wt,{E:()=>pt});const nt=new(G(43430).Z);function pt(mt){if(null==mt)return["",!1];if(!nt.hasBidiChar(mt))return[mt,!1];let Ot;return Ot="rtl"===nt.checkContextual(mt)?"IDNNN":"ICNNN",[nt.bidiTransform(mt,Ot,"VLYSN"),!0]}},1671:(ae,Wt,G)=>{G.d(Wt,{I:()=>nt,v:()=>pt});var At=G(93142);function nt(V,Q,tt=0){const H=(0,At.uZ)(V,0,L);for(let ft=0;ft<4;ft++)Q[tt+ft]=Math.floor(256*at(H*mt[ft]))}function pt(V,Q=0){let tt=0;for(let H=0;H<4;H++)tt+=V[Q+H]*Ot[H];return tt}const mt=[1,256,65536,16777216],Ot=[1/256,1/65536,1/16777216,1/4294967296],L=pt(new Uint8ClampedArray([255,255,255,255]));function at(V){return V-Math.floor(V)}},36416:(ae,Wt,G)=>{G.d(Wt,{BN:()=>at,Yc:()=>V,mx:()=>Ot});var At=G(71670),nt=G(68327);const pt="woff2",mt=new Map;function Ot(H){return L.apply(this,arguments)}function L(){return(L=(0,At.Z)(function*(H){const ft=V(H);let gt=mt.get(ft);if(gt)return gt;const E=new FontFace(H.family,`url('${nt.default.fontsUrl}/woff2/${ft}.${pt}') format('${pt}')`),O=document.fonts;return O.has(E)&&"loading"===E.status?E.loaded:(gt=E.load(),mt.set(ft,gt),O.add(E),gt)})).apply(this,arguments)}function at(H){if(!H)return"arial-unicode-ms";const ft=H.toLowerCase().split(" ").join("-");switch(ft){case"serif":return"noto-serif";case"sans-serif":return"arial-unicode-ms";case"monospace":return"ubuntu-mono";case"fantasy":return"cabin-sketch";case"cursive":return"redressed";default:return ft}}function V(H){const ft=function Q(H){if(!H.weight)return"";switch(H.weight.toLowerCase()){case"bold":case"bolder":return"-bold"}return""}(H)+function tt(H){if(!H.style)return"";switch(H.style.toLowerCase()){case"italic":case"oblique":return"-italic"}return""}(H);return at(H.family)+(ft.length>0?ft:"-regular")}},63291:(ae,Wt,G)=>{G.d(Wt,{GP:()=>mt,QK:()=>A,XV:()=>ht,hh:()=>O,ov:()=>E,qh:()=>vt,v1:()=>bt,wp:()=>gt,zY:()=>It,zv:()=>St});var At=G(88684),nt=G(71182),pt=G(46806);function mt(D){const it=(0,At.d9)(D);return function ft(D){D&&((0,nt.oU)(D)?H(D.rings):(0,nt.l9)(D)?H(D.paths):(0,nt.aW)(D)&&tt(D.points),Ot(D))}(it),it}function Ot(D){D&&((0,nt.wp)(D)?D.y=-D.y:(0,nt.oU)(D)?at(D.rings):(0,nt.l9)(D)?at(D.paths):(0,nt.aW)(D)&&L(D.points))}function L(D){if(D){const it=D.length;for(let Mt=0;Mt<it;Mt++)D[Mt][1]=-D[Mt][1]}}function at(D){if(D)for(const it of D)L(it)}function V(D){if(D)for(let it=D.length-1;it>0;--it)D[it][0]-=D[it-1][0],D[it][1]-=D[it-1][1]}function Q(D){if(D)for(const it of D)V(it)}function tt(D){if(D){const it=D.length;for(let Mt=1;Mt<it;++Mt)D[Mt][0]+=D[Mt-1][0],D[Mt][1]+=D[Mt-1][1]}}function H(D){if(D)for(const it of D)tt(it)}function gt(D){D&&(Ot(D),(0,nt.oU)(D)?Q(D.rings):(0,nt.l9)(D)?Q(D.paths):(0,nt.aW)(D)&&V(D.points))}function E(D){if(D)for(const it of D)O(it)}function O(D){D&&D.reverse()}function ht(D,it,Mt){return[D[0]+(it[0]-D[0])*Mt,D[1]+(it[1]-D[1])*Mt]}function A(D){return!(!D||0===D.length)&&D[0][0]===D[D.length-1][0]&&D[0][1]===D[D.length-1][1]}function St(D){return D[4]}function vt(D,it){D[4]=it}class bt{constructor(it,Mt,zt,yt=0){this.isClosed=!1,this.multiPath=null,this.acceptPolygon=Mt,this.acceptPolyline=zt,this.geomUnitsPerPoint=yt,this.pathCount=-1,this.pathIndex=-1,this.iteratePath=!1,it&&((0,nt.oU)(it)?Mt&&(this.multiPath=it.rings,this.isClosed=!0):(0,nt.l9)(it)?zt&&(this.multiPath=it.paths,this.isClosed=!1):(0,nt.YX)(it)&&Mt&&(this.multiPath=Rt(it).rings,this.isClosed=!0),this.multiPath&&(this.pathCount=this.multiPath.length)),this.internalPlacement=new pt.u}next(){if(!this.multiPath)return null;for(;this.iteratePath||this.pathIndex<this.pathCount-1;){this.iteratePath||this.pathIndex++;const it=this.processPath(this.multiPath[this.pathIndex]);if(it)return it}return this.pathCount=-1,this.pathIndex=-1,this.multiPath=null,null}}class It{constructor(it,Mt,zt,yt=0){this.isClosed=!1,this.multiPath=null,this.inputGeometries=it,this.acceptPolygon=Mt,this.acceptPolyline=zt,this.geomUnitsPerPoint=yt,this.pathCount=-1,this.pathIndex=-1,this.iteratePath=!1}next(){for(;;){if(!this.multiPath){let it=this.inputGeometries.next();for(;it;){if((0,nt.oU)(it)?this.acceptPolygon&&(this.multiPath=it.rings,this.isClosed=!0):(0,nt.l9)(it)?this.acceptPolyline&&(this.multiPath=it.paths,this.isClosed=!1):(0,nt.YX)(it)&&this.acceptPolygon&&(this.multiPath=Rt(it).rings,this.isClosed=!0),this.multiPath){this.pathCount=this.multiPath.length,this.pathIndex=-1;break}it=this.inputGeometries.next()}if(!this.multiPath)return null}for(;this.iteratePath||this.pathIndex<this.pathCount-1;){this.iteratePath||this.pathIndex++;const it=this.processPath(this.multiPath[this.pathIndex]);if(it)return it}this.pathCount=-1,this.pathIndex=-1,this.multiPath=null}}}function Rt(D){return{rings:[[[D.xmin,D.ymin],[D.xmin,D.ymax],[D.xmax,D.ymax],[D.xmax,D.ymin],[D.xmin,D.ymin]]]}}},23975:(ae,Wt,G)=>{G.d(Wt,{MU:()=>Ot,ib:()=>at,yn:()=>V}),G(88684);var nt=G(99220);const pt=512;let mt;class Ot{constructor(tt){this._geometry=tt}next(){const tt=this._geometry;return this._geometry=null,tt}}function at(Q,tt){let H,ft;mt||(mt=new nt.bN(0,0,0,1)),mt.reset(nt.Vl.Polygon),mt.setPixelMargin(tt+1),mt.setExtent(pt);for(const E of Q.rings)if(E&&!(E.length<3)){H=E[0][0],ft=-E[0][1],mt.moveTo(H,ft);for(let O=1;O<E.length;O++)H=E[O][0],ft=-E[O][1],mt.lineTo(H,ft);mt.close()}const gt=mt.result(!1);if(gt){const E=[];for(const O of gt){const ht=[];E.push(ht);for(const A of O)ht.push([A.x,-A.y])}return{rings:E}}return{rings:[]}}function V(Q,tt){let H,ft;mt||(mt=new nt.bN(0,0,0,1)),mt.reset(nt.Vl.LineString),mt.setPixelMargin(tt+1),mt.setExtent(pt);for(const E of Q.paths)if(E&&!(E.length<2)){H=E[0][0],ft=-E[0][1],mt.moveTo(H,ft);for(let O=1;O<E.length;O++)H=E[O][0],ft=-E[O][1],mt.lineTo(H,ft)}const gt=mt.result(!1);if(gt){const E=[];for(const O of gt){const ht=[];E.push(ht);for(const A of O)ht.push([A.x,-A.y])}return{paths:E}}return{paths:[]}}},5780:(ae,Wt,G)=>{G.d(Wt,{h:()=>Ee,W:()=>Le});var At=G(88684),nt=G(71182),pt=G(63291);let mt=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(s,i,h,o,r){return new Ot(s,i,h)}}return f.instance=null,f})();class Ot{constructor(e,s,i){this._inputGeometries=e,this._angleTolerance=void 0!==s.angleTolerance?s.angleTolerance:120,this._maxCosAngle=Math.cos((1-Math.abs(this._angleTolerance)/180)*Math.PI)}next(){let e=this._inputGeometries.next();for(;e;){if((0,nt.oU)(e)){this._isClosed=!0;const s=(0,At.d9)(e);return this._processMultipath(s.rings),s}if((0,nt.l9)(e)){this._isClosed=!1;const s=(0,At.d9)(e);return this._processMultipath(s.paths),s}if((0,nt.YX)(e)){if(this._maxCosAngle)return e;this._isClosed=!0;const s=[[e.xmin,e.ymin],[e.xmin,e.ymax],[e.xmax,e.ymax],[e.xmax,e.ymin],[e.xmin,e.ymin]];return this._processPath(s),{rings:[s]}}e=this._inputGeometries.next()}return null}_processMultipath(e){if(e)for(const s of e)this._processPath(s)}_processPath(e){if(e){let s,i,h,o,r,l,c=e.length,p=e[0];this._isClosed&&++c;for(let d=1;d<c;++d){let y;y=this._isClosed&&d===c-1?e[0]:e[d];const R=y[0]-p[0],N=y[1]-p[1],W=Math.sqrt(R*R+N*N);d>1&&W>0&&h>0&&(s*R+i*N)/W/h<=this._maxCosAngle&&(0,pt.qh)(p,1),1===d&&(o=R,r=N,l=W),W>0&&(p=y,s=R,i=N,h=W)}this._isClosed&&h>0&&l>0&&(s*o+i*r)/l/h<=this._maxCosAngle&&(0,pt.qh)(e[0],1)}}}var L=G(20877);const at=.03;class V{constructor(){this._path=[]}path(){return this._path}addPath(e,s){s||e.reverse(),Array.prototype.push.apply(this._path,e),s||e.reverse()}static mergePath(e,s){s&&Array.prototype.push.apply(e,s)}startPath(e){this._path.push(e)}lineTo(e){this._path.push(e)}close(){const e=this._path;e.length>1&&(e[0][0]===e[e.length-1][0]&&e[0][1]===e[e.length-1][1]||e.push([e[0][0],e[0][1]]))}}class Q{constructor(e=0,s=!1){}normalize(e){const s=Math.sqrt(e[0]*e[0]+e[1]*e[1]);0!==s&&(e[0]/=s,e[1]/=s)}calculateLength(e,s){const i=s[0]-e[0],h=s[1]-e[1];return Math.sqrt(i*i+h*h)}calculateSegLength(e,s){return this.calculateLength(e[s],e[s+1])}calculatePathLength(e){let s=0;const i=e?e.length:0;for(let h=0;h<i-1;++h)s+=this.calculateSegLength(e,h);return s}calculatePathArea(e){let s=0;const i=e?e.length:0;for(let h=0;h<i-1;++h)s+=(e[h+1][0]-e[h][0])*(e[h+1][1]+e[h][1]);return s/2}getCoord2D(e,s,i){return[e[0]+(s[0]-e[0])*i,e[1]+(s[1]-e[1])*i]}getSegCoord2D(e,s,i){return this.getCoord2D(e[s],e[s+1],i)}getAngle(e,s,i){return Math.atan2(s[1]-e[1],s[0]-e[0])}getSegAngle(e,s,i){return this.getAngle(e[s],e[s+1],i)}getAngleCS(e,s,i){const h=s[0]-e[0],o=s[1]-e[1],r=Math.sqrt(h*h+o*o);return r>0?[h/r,o/r]:[1,0]}getSegAngleCS(e,s,i){return this.getAngleCS(e[s],e[s+1],i)}cut(e,s,i,h){return[i<=0?e[s]:this.getSegCoord2D(e,s,i),h>=1?e[s+1]:this.getSegCoord2D(e,s,h)]}addSegment(e,s,i){i&&e.push(s[0]),e.push(s[1])}getSubCurve(e,s,i){const h=[];return this.appendSubCurve(h,e,s,i)?h:null}appendSubCurve(e,s,i,h){const o=s?s.length-1:0;let r=0,l=!0,c=0;for(;c<o;){const p=this.calculateSegLength(s,c);if(0!==p){if(l){if(r+p>i){let y=1,R=!1;r+p>=h&&(y=(h-r)/p,R=!0);const N=this.cut(s,c,(i-r)/p,y);if(N&&this.addSegment(e,N,l),R)break;l=!1}}else{if(r+p>h){const d=this.cut(s,c,0,(h-r)/p);d&&this.addSegment(e,d,l);break}this.addSegment(e,[s[c],s[c+1]],l)}r+=p,++c}else++c}return!0}getCIMPointAlong(e,s){const i=e?e.length-1:0;let h=0,o=-1;for(;o<i;){++o;const r=this.calculateSegLength(e,o);if(0!==r){if(h+r>s)return this.getCoord2D(e[o],e[o+1],(s-h)/r);h+=r}}return null}isEmpty(e,s){if(!e||e.length<=1)return!0;const i=e?e.length-1:0;let h=-1;for(;h<i;)if(++h,e[h+1][0]!==e[h][0]||e[h+1][1]!==e[h][1]||s&&e[h+1][2]!==e[h][2])return!1;return!0}offset(e,s,i,h,o){if(!e||e.length<2)return null;let r=0,l=e[r++],c=r;for(;r<e.length;){const R=e[r];R[0]===l[0]&&R[1]===l[1]||(r!==c&&(e[c]=e[r]),l=e[c++]),r++}const p=e[0][0]===e[c-1][0]&&e[0][1]===e[c-1][1];if(p&&--c,c<(p?3:2))return null;const d=[];l=p?e[c-1]:null;let y=e[0];for(let R=0;R<c;R++){const N=R===c-1?p?e[0]:null:e[R+1];if(l)if(N){const W=[N[0]-y[0],N[1]-y[1]];this.normalize(W);const K=[y[0]-l[0],y[1]-l[1]];this.normalize(K);const ut=K[0]*W[1]-K[1]*W[0],Ct=K[0]*W[0]+K[1]*W[1];if(0===ut&&1===Ct){y=N;continue}if(ut>=0==s<=0){if(Ct<1){const Ut=[W[0]-K[0],W[1]-K[1]];this.normalize(Ut);const Ft=Math.sqrt((1+Ct)/2);if(Ft>1/h){const xt=-Math.abs(s)/Ft;d.push([y[0]-Ut[0]*xt,y[1]-Ut[1]*xt])}}}else switch(i){case L.id.Mitered:{const Ut=Math.sqrt((1+Ct)/2);if(Ut>0&&1/Ut<h){const Ft=[W[0]-K[0],W[1]-K[1]];this.normalize(Ft);const xt=Math.abs(s)/Ut;d.push([y[0]-Ft[0]*xt,y[1]-Ft[1]*xt]);break}}case L.id.Bevelled:d.push([y[0]+K[1]*s,y[1]-K[0]*s]),d.push([y[0]+W[1]*s,y[1]-W[0]*s]);break;case L.id.Rounded:if(Ct<1){d.push([y[0]+K[1]*s,y[1]-K[0]*s]);const Ut=Math.floor(2.5*(1-Ct));if(Ut>0){const Ft=1/Ut;let xt=Ft;for(let qt=1;qt<Ut;qt++,xt+=Ft){const Vt=[K[1]*(1-xt)+W[1]*xt,-K[0]*(1-xt)-W[0]*xt];this.normalize(Vt),d.push([y[0]+Vt[0]*s,y[1]+Vt[1]*s])}}d.push([y[0]+W[1]*s,y[1]-W[0]*s])}break;default:if(ut<0)d.push([y[0]+(K[1]+K[0])*s,y[1]+(K[1]-K[0])*s]),d.push([y[0]+(W[1]-W[0])*s,y[1]-(W[0]+W[1])*s]);else{const Ut=Math.sqrt((1+Math.abs(Ct))/2),Ft=[W[0]-K[0],W[1]-K[1]];this.normalize(Ft);const xt=s/Ut;d.push([y[0]-Ft[0]*xt,y[1]-Ft[1]*xt])}}}else{const W=[y[0]-l[0],y[1]-l[1]];this.normalize(W),d.push([y[0]+W[1]*s,y[1]-W[0]*s])}else{const W=[N[0]-y[0],N[1]-y[1]];this.normalize(W),d.push([y[0]+W[1]*s,y[1]-W[0]*s])}l=y,y=N}return d.length<(p?3:2)?null:(p&&d.push([d[0][0],d[0][1]]),d)}}const tt=1.7320508075688772,ft=L.TF.OpenEnded;let gt=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(s,i,h,o,r){return new E(s,i,h)}}return f.instance=null,f})();class E extends pt.zY{constructor(e,s,i){super(e,!1,!0),this._curveHelper=new Q,this._width=(void 0!==s.width?s.width:5)*i,this._arrowType=void 0!==s.geometricEffectArrowType?s.geometricEffectArrowType:void 0!==s.arrowType?s.arrowType:ft,this._offsetFlattenError=at*i}processPath(e){switch(this._arrowType){case L.TF.OpenEnded:default:return this._constructSimpleArrow(e,!0);case L.TF.Block:return this._constructSimpleArrow(e,!1);case L.TF.Crossed:return this._constructCrossedArrow(e)}}_constructSimpleArrow(e,s){const i=this._curveHelper.calculatePathLength(e);let h=this._width;i<2*h&&(h=i/2);const o=this._curveHelper.getSubCurve(e,0,i-h);if(!o)return null;const r=h/2;if(this._curveHelper.isEmpty(o,!1))return null;const l=this._constructOffset(o,-r);if(!l)return null;const c=this._constructOffset(o,r);if(!c)return null;const p=this._constructArrowBasePoint(l,-r/2);if(!p)return null;const d=this._constructArrowBasePoint(c,r/2);if(!d)return null;const y=e[e.length-1];s||(this._makeControlPoint(c,!0),this._makeControlPoint(l,!0));const R=new V;return R.addPath(c,!0),R.lineTo(d),this._makeControlPoint(R.path()),R.lineTo(y),this._makeControlPoint(R.path()),R.lineTo(p),this._makeControlPoint(R.path()),R.addPath(l,!1),s?{paths:[R.path()]}:(R.close(),{rings:[R.path()]})}_constructCrossedArrow(e){const s=this._curveHelper.calculatePathLength(e);let i=this._width;s<i*(1+tt+1)&&(i=s/(1+tt+1));const h=this._curveHelper.getSubCurve(e,0,s-i*(1+tt));if(!h)return null;const o=i/2;if(this._curveHelper.isEmpty(h,!1))return null;const r=this._constructOffset(h,o);if(!r)return null;const l=this._constructOffset(h,-o);if(!l)return null;const c=this._curveHelper.getSubCurve(e,0,s-i);if(!c||this._curveHelper.isEmpty(c,!1))return null;const p=this._constructOffset(c,o);if(!p)return null;const d=this._constructOffset(c,-o);if(!d)return null;const y=p[p.length-1],R=this._constructArrowBasePoint(p,o/2);if(!R)return null;const N=d[d.length-1],W=this._constructArrowBasePoint(d,-o/2);if(!W)return null;const K=e[e.length-1];this._makeControlPoint(r,!1),this._makeControlPoint(l,!1);const ut=new V;return ut.addPath(r,!0),this._makeControlPoint(ut.path()),ut.lineTo(N),ut.lineTo(W),this._makeControlPoint(ut.path()),ut.lineTo(K),this._makeControlPoint(ut.path()),ut.lineTo(R),this._makeControlPoint(ut.path()),ut.lineTo(y),this._makeControlPoint(ut.path()),ut.addPath(l,!1),{paths:[ut.path()]}}_constructOffset(e,s){return this._curveHelper.offset(e,s,L.id.Rounded,4,this._offsetFlattenError)}_constructArrowBasePoint(e,s){if(!e||e.length<2)return null;const i=e[e.length-2],h=e[e.length-1],o=[h[0]-i[0],h[1]-i[1]];return this._curveHelper.normalize(o),[h[0]+o[1]*s,h[1]-o[0]*s]}_makeControlPoint(e,s=!1){(0,pt.qh)(s?e[0]:e[e.length-1],1)}}G(6010);var ht=G(53661),A=G(23975),St=G(68230);let vt=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(s,i,h,o,r){return new bt(s,i,h,o,r)}}return f.instance=null,f})();class bt{constructor(e,s,i,h,o){this._inputGeometries=e,this._tileKey=h,this._geometryEngine=o,this._curveHelper=new Q,this._size=(void 0!==s.size?s.size:1)*i,this._offsetFlattenError=at*i}next(){let e;for(;e=this._inputGeometries.next();){if(0===this._size)return e;if((0,nt.YX)(e))if(this._size>0){const o=this._curveHelper.offset([[e.xmin,e.ymin],[e.xmin,e.ymax],[e.xmax,e.ymax],[e.xmax,e.ymin],[e.xmin,e.ymin]],this._size,L.id.Rounded,4,this._offsetFlattenError);if(o)return{rings:[o]}}else if(this._size<0&&Math.min(e.xmax-e.xmin,e.ymax-e.ymin)+2*this._size>0)return{xmin:e.xmin-this._size,xmax:e.xmax+this._size,ymin:e.ymin-this._size,ymax:e.ymax+this._size};const s=this._geometryEngine;if((0,ht.Wi)(s))return null;let i=e;if((!(0,nt.oU)(e)||!this._tileKey||(i=(0,A.ib)(e,Math.abs(this._size)+1),i&&i.rings&&0!==i.rings.length))&&(!(0,nt.l9)(e)||!this._tileKey||(i=(0,A.yn)(e,Math.abs(this._size)+1),i&&i.paths&&0!==i.paths.length)))return s.buffer(St.Z.WebMercator,i,this._size,1)}return null}}let It=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(s,i,h,o,r){return new Rt(s,i,h)}}return f.instance=null,f})();class Rt{constructor(e,s,i){this._defaultPointSize=20,this._inputGeometries=e,this._geomUnitsPerPoint=i,this._rule=s.rule??L.Em.FullGeometry,this._defaultSize=this._defaultPointSize*i}next(){let e;for(;e=this._inputGeometries.next();){let s;if((0,nt.wp)(e)?s=this._processGeom([[[e.x,e.y]]]):(0,nt.aW)(e)?s=this._processGeom([e.points]):(0,nt.l9)(e)?s=this._processGeom(e.paths):(0,nt.oU)(e)&&(s=this._processGeom(e.rings)),s&&s.length)return{paths:s}}return null}_clone(e){return[e[0],e[1]]}_mid(e,s){return[(e[0]+s[0])/2,(e[1]+s[1])/2]}_mix(e,s,i,h){return[e[0]*s+i[0]*h,e[1]*s+i[1]*h]}_add(e,s){return[e[0]+s[0],e[1]+s[1]]}_add2(e,s,i){return[e[0]+s,e[1]+i]}_sub(e,s){return[e[0]-s[0],e[1]-s[1]]}_dist(e,s){return Math.sqrt((e[0]-s[0])*(e[0]-s[0])+(e[1]-s[1])*(e[1]-s[1]))}_norm(e){return Math.sqrt(e[0]*e[0]+e[1]*e[1])}_normalize(e,s=1){const i=s/this._norm(e);e[0]*=i,e[1]*=i}_leftPerpendicular(e){const i=e[0];e[0]=-e[1],e[1]=i}_leftPerp(e){return[-e[1],e[0]]}_rightPerpendicular(e){const i=-e[0];e[0]=e[1],e[1]=i}_rightPerp(e){return[e[1],-e[0]]}_dotProduct(e,s){return e[0]*s[0]+e[1]*s[1]}_crossProduct(e,s){return e[0]*s[1]-e[1]*s[0]}_rotateDirect(e,s,i){const o=e[0]*i+e[1]*s;e[0]=e[0]*s-e[1]*i,e[1]=o}_makeCtrlPt(e){const s=[e[0],e[1]];return(0,pt.qh)(s,1),s}_addAngledTicks(e,s,i,h){const o=this._sub(i,s);this._normalize(o);const r=this._crossProduct(o,this._sub(h,s));let l;l=r>0?this._rightPerp(o):this._leftPerp(o);const c=Math.abs(r)/2,p=[];p.push([s[0]+(l[0]-o[0])*c,s[1]+(l[1]-o[1])*c]),p.push(s),p.push(i),p.push([i[0]+(l[0]+o[0])*c,i[1]+(l[1]+o[1])*c]),e.push(p)}_addBezier2(e,s,i,h,o){if(0==o--)return void e.push(h);const r=this._mid(s,i),l=this._mid(i,h),c=this._mid(r,l);this._addBezier2(e,s,r,c,o),this._addBezier2(e,c,l,h,o)}_addBezier3(e,s,i,h,o,r){if(0==r--)return void e.push(o);const l=this._mid(s,i),c=this._mid(i,h),p=this._mid(h,o),d=this._mid(l,c),y=this._mid(c,p),R=this._mid(d,y);this._addBezier3(e,s,l,d,R,r),this._addBezier3(e,R,y,p,o,r)}_add90DegArc(e,s,i,h,o){const r=o??this._crossProduct(this._sub(i,s),this._sub(h,s))>0,l=this._mid(s,i),c=this._sub(l,s);r?this._leftPerpendicular(c):this._rightPerpendicular(c),l[0]+=c[0],l[1]+=c[1],this._addBezier3(e,s,this._mix(s,.33333,l,.66667),this._mix(i,.33333,l,.66667),i,4)}_addArrow(e,s,i){const h=s[0],o=s[1],r=s[s.length-1],l=this._sub(h,o);this._normalize(l);const c=this._crossProduct(l,this._sub(r,o)),p=.5*c,d=this._leftPerp(l),y=[r[0]-d[0]*c,r[1]-d[1]*c],R=s.length-1,N=[];N.push(i?[-d[0],-d[1]]:d);let W=[-l[0],-l[1]];for(let K=1;K<R-1;K++){const ut=this._sub(s[K+1],s[K]);this._normalize(ut);const Ct=this._dotProduct(ut,W),Ut=this._crossProduct(ut,W),Ft=Math.sqrt((1+Ct)/2),xt=this._sub(ut,W);this._normalize(xt),xt[0]/=Ft,xt[1]/=Ft,N.push(Ut<0?[-xt[0],-xt[1]]:xt),W=ut}N.push(this._rightPerp(W));for(let K=N.length-1;K>0;K--)e.push([s[K][0]+N[K][0]*p,s[K][1]+N[K][1]*p]);e.push([y[0]+N[0][0]*p,y[1]+N[0][1]*p]),e.push([y[0]+N[0][0]*c,y[1]+N[0][1]*c]),e.push(h),e.push([y[0]-N[0][0]*c,y[1]-N[0][1]*c]),e.push([y[0]-N[0][0]*p,y[1]-N[0][1]*p]);for(let K=1;K<N.length;K++)e.push([s[K][0]-N[K][0]*p,s[K][1]-N[K][1]*p])}_cp2(e,s,i){return e.length>=2?e[1]:this._add2(e[0],s*this._defaultSize,i*this._defaultSize)}_cp3(e,s,i,h){if(e.length>=3)return e[2];const o=this._mix(e[0],1-i,s,i),r=this._sub(s,e[0]);return this._normalize(r),this._rightPerpendicular(r),[o[0]+r[0]*h*this._defaultSize,o[1]+r[1]*h*this._defaultSize]}_arrowPath(e){if(e.length>2)return e;const s=e[0],i=this._cp2(e,-4,0),h=this._sub(s,i);this._normalize(h);const o=this._rightPerp(h);return[s,i,[s[0]+(o[0]-h[0])*this._defaultSize,s[1]+(o[1]-h[1])*this._defaultSize]]}_arrowLastSeg(e){const s=e[0],i=this._cp2(e,-4,0);let h;if(e.length>=3)h=e[e.length-1];else{const o=this._sub(s,i);this._normalize(o);const r=this._rightPerp(o);h=[s[0]+(r[0]-o[0])*this._defaultSize,s[1]+(r[1]-o[1])*this._defaultSize]}return[i,h]}_processGeom(e){if(!e)return null;const s=[];for(const i of e){if(!i||0===i.length)continue;const h=i.length;let o=i[0];switch(this._rule){case L.Em.PerpendicularFromFirstSegment:{const r=this._cp2(i,0,-1),l=this._cp3(i,r,.5,4),c=[];c.push(l),c.push(this._mid(o,r)),s.push(c);break}case L.Em.ReversedFirstSegment:{const r=this._cp2(i,0,-1);s.push([r,o]);break}case L.Em.PerpendicularToSecondSegment:{const r=this._cp2(i,-4,1),l=this._cp3(i,r,.882353,-1.94),c=[];c.push(this._mid(r,l)),c.push(o),s.push(c);break}case L.Em.SecondSegmentWithTicks:{const r=this._cp2(i,-4,1),l=this._cp3(i,r,.882353,-1.94),c=this._sub(l,r);let p;p=this._crossProduct(c,this._sub(o,r))>0?this._rightPerp(p):this._leftPerp(c);const d=[];d.push([r[0]+(p[0]-c[0])/3,r[1]+(p[1]-c[1])/3]),d.push(r),d.push(l),d.push([l[0]+(p[0]+c[0])/3,l[1]+(p[1]+c[1])/3]),s.push(d);break}case L.Em.DoublePerpendicular:{const r=this._cp2(i,0,-1),l=this._cp3(i,r,.5,3),c=this._mid(o,r),p=this._sub(c,l);this._normalize(p);const d=this._crossProduct(p,this._sub(o,l));this._leftPerpendicular(p);const y=[];y.push(o),y.push([l[0]+p[0]*d,l[1]+p[1]*d]),s.push(y);const R=[];R.push([l[0]-p[0]*d,l[1]-p[1]*d]),R.push(r),s.push(R);break}case L.Em.OppositeToFirstSegment:{const r=this._cp2(i,0,-1),l=this._cp3(i,r,.5,3),c=this._mid(o,r),p=this._sub(c,l);this._normalize(p);const d=this._crossProduct(p,this._sub(o,l));this._leftPerpendicular(p);const y=[];y.push([l[0]+p[0]*d,l[1]+p[1]*d]),y.push([l[0]-p[0]*d,l[1]-p[1]*d]),s.push(y);break}case L.Em.TriplePerpendicular:{const r=this._cp2(i,0,-1),l=this._cp3(i,r,.5,4),c=this._mid(o,r),p=this._sub(c,l);this._normalize(p);const d=this._crossProduct(p,this._sub(o,l));this._leftPerpendicular(p);const y=[];y.push([l[0]+p[0]*d*.8,l[1]+p[1]*d*.8]),y.push([c[0]+.8*(o[0]-c[0]),c[1]+.8*(o[1]-c[1])]),s.push(y),s.push([l,c]);const R=[];R.push([l[0]-p[0]*d*.8,l[1]-p[1]*d*.8]),R.push([c[0]+.8*(r[0]-c[0]),c[1]+.8*(r[1]-c[1])]),s.push(R);break}case L.Em.HalfCircleFirstSegment:{const r=this._cp2(i,0,-1),l=this._cp3(i,r,.5,4),c=this._mid(o,r);let p=this._sub(r,o);const d=Math.cos(Math.PI/18),y=Math.sin(Math.PI/18),R=Math.sqrt((1+d)/2),N=Math.sqrt((1-d)/2),W=[];let K;this._crossProduct(p,this._sub(l,o))>0?(W.push(o),p=this._sub(o,c),K=r):(W.push(r),p=this._sub(r,c),K=o),this._rotateDirect(p,R,N),p[0]/=R,p[1]/=R;for(let ut=1;ut<=18;ut++)W.push(this._add(c,p)),this._rotateDirect(p,d,y);W.push(K),s.push(W);break}case L.Em.HalfCircleSecondSegment:{const r=this._cp2(i,0,-1),l=this._cp3(i,r,1,-1);let c=this._sub(o,r);this._normalize(c);const p=this._crossProduct(c,this._sub(l,r))/2;this._leftPerpendicular(c);const d=[r[0]+c[0]*p,r[1]+c[1]*p];c=this._sub(r,d);const y=Math.cos(Math.PI/18);let R=Math.sin(Math.PI/18);p>0&&(R=-R);const N=[r];for(let W=1;W<=18;W++)this._rotateDirect(c,y,R),N.push(this._add(d,c));s.push(N);break}case L.Em.HalfCircleExtended:{const r=this._cp2(i,0,-2),l=this._cp3(i,r,1,-1);let c;if(h>=4)c=i[3];else{const W=this._sub(o,r);c=this._add(l,W)}const p=this._dist(r,l)/2/.75,d=this._sub(r,o);this._normalize(d,p);const y=this._sub(l,c);this._normalize(y,p),s.push([c,l]);const N=[this._clone(l)];this._addBezier3(N,l,this._add(l,y),this._add(r,d),r,4),N.push(o),s.push(N);break}case L.Em.OpenCircle:{const r=this._cp2(i,-2,0),l=this._sub(r,o),c=Math.cos(Math.PI/18),p=-Math.sin(Math.PI/18),d=[r];for(let y=1;y<=33;y++)this._rotateDirect(l,c,p),d.push(this._add(o,l));s.push(d);break}case L.Em.CoverageEdgesWithTicks:{const r=this._cp2(i,0,-1);let l,c;if(h>=3)l=i[2];else{const R=this._sub(r,o),N=this._leftPerp(R);l=[o[0]+N[0]-.25*R[0],o[1]+N[1]-.25*R[1]]}if(h>=4)c=i[3];else{const R=this._mid(o,r),N=this._sub(o,r);this._normalize(N),this._leftPerpendicular(N);const W=this._crossProduct(N,this._sub(l,R));this._rightPerpendicular(N),c=[l[0]+N[0]*W*2,l[1]+N[1]*W*2]}const p=this._sub(r,o);let d,y;d=this._crossProduct(p,this._sub(l,o))>0?this._rightPerp(p):this._leftPerp(p),y=[],y.push(l),y.push(o),y.push([o[0]+(d[0]-p[0])/3,o[1]+(d[1]-p[1])/3]),s.push(y),d=this._crossProduct(p,this._sub(c,r))>0?this._rightPerp(d):this._leftPerp(p),y=[],y.push([r[0]+(d[0]+p[0])/3,r[1]+(d[1]+p[1])/3]),y.push(r),y.push(c),s.push(y);break}case L.Em.GapExtentWithDoubleTicks:{const r=this._cp2(i,0,2),l=this._cp3(i,r,0,1);let c;if(h>=4)c=i[3];else{const p=this._sub(r,o);c=this._add(l,p)}this._addAngledTicks(s,o,r,this._mid(l,c)),this._addAngledTicks(s,l,c,this._mid(o,r));break}case L.Em.GapExtentMidline:{const r=this._cp2(i,2,0),l=this._cp3(i,r,0,1);let c;if(h>=4)c=i[3];else{const d=this._sub(r,o);c=this._add(l,d)}const p=[];p.push(this._mid(o,l)),p.push(this._mid(r,c)),s.push(p);break}case L.Em.Chevron:{const r=this._cp2(i,-1,-1);let l;if(h>=3)l=i[2];else{const c=this._sub(r,o);this._leftPerpendicular(c),l=this._add(o,c)}s.push([r,this._makeCtrlPt(o),l]);break}case L.Em.PerpendicularWithArc:{const r=this._cp2(i,0,-2),l=this._cp3(i,r,.5,-1);let c=this._sub(r,o);const p=this._norm(c);c[0]/=p,c[1]/=p;const d=this._crossProduct(c,this._sub(l,o));let y=this._dotProduct(c,this._sub(l,o));y<.05*p?y=.05*p:y>.95*p&&(y=.95*p);const R=[o[0]+c[0]*y,o[1]+c[1]*y];this._leftPerpendicular(c);let N=[];N.push([R[0]-c[0]*d,R[1]-c[1]*d]),N.push([R[0]+c[0]*d,R[1]+c[1]*d]),s.push(N);const W=[r[0]+c[0]*d,r[1]+c[1]*d];c=this._sub(r,W);const K=Math.cos(Math.PI/18);let ut=Math.sin(Math.PI/18);d<0&&(ut=-ut),N=[o,r];for(let Ct=1;Ct<=9;Ct++)this._rotateDirect(c,K,ut),N.push(this._add(W,c));s.push(N);break}case L.Em.ClosedHalfCircle:{const r=this._cp2(i,2,0),l=this._mid(o,r),c=this._sub(r,l),p=Math.cos(Math.PI/18),d=Math.sin(Math.PI/18),y=[o,r];for(let R=1;R<=18;R++)this._rotateDirect(c,p,d),y.push(this._add(l,c));s.push(y);break}case L.Em.TripleParallelExtended:{const r=this._cp2(i,0,-2),l=this._cp3(i,r,1,-2),c=this._mid(o,r),p=this._sub(l,r);this._normalize(p);const d=Math.abs(this._crossProduct(p,this._sub(c,r)))/2,y=this._dist(r,l),R=[r,o];R.push([o[0]+p[0]*y*.5,o[1]+p[1]*y*.5]),s.push(R);const N=[];N.push([c[0]-p[0]*d,c[1]-p[1]*d]),N.push([c[0]+p[0]*y*.375,c[1]+p[1]*y*.375]),(0,pt.qh)(N[N.length-1],1),N.push([c[0]+p[0]*y*.75,c[1]+p[1]*y*.75]),s.push(N),s.push([r,l]);break}case L.Em.ParallelWithTicks:{const r=this._cp2(i,3,0),l=this._cp3(i,r,.5,-1),c=this._sub(l,r);this._normalize(c);const p=this._crossProduct(c,this._sub(l,o));this._leftPerpendicular(c),this._addAngledTicks(s,o,r,l),this._addAngledTicks(s,this._mix(o,1,c,p),this._mix(r,1,c,p),this._mid(o,r));break}case L.Em.Parallel:{const r=this._cp2(i,3,0),l=this._cp3(i,r,.5,-1),c=this._sub(r,o);this._normalize(c);const p=this._leftPerp(c),d=this._crossProduct(c,this._sub(l,o));let y=[o,r];s.push(y),y=[],y.push([o[0]+p[0]*d,o[1]+p[1]*d]),y.push([r[0]+p[0]*d,r[1]+p[1]*d]),s.push(y);break}case L.Em.PerpendicularToFirstSegment:{const r=this._cp2(i,3,0),l=this._cp3(i,r,.5,-1),c=this._mid(o,r),p=this._sub(r,o);this._normalize(p);const d=this._crossProduct(p,this._sub(l,o));this._leftPerpendicular(p);const y=[];y.push([c[0]-p[0]*d*.25,c[1]-p[1]*d*.25]),y.push([c[0]+p[0]*d*1.25,c[1]+p[1]*d*1.25]),s.push(y);break}case L.Em.ParallelOffset:{const r=this._cp2(i,3,0),l=this._cp3(i,r,.5,-1),c=this._sub(r,o);this._normalize(c);const p=this._crossProduct(c,this._sub(l,o));this._leftPerpendicular(c);const d=[];d.push([o[0]-c[0]*p,o[1]-c[1]*p]),d.push([r[0]-c[0]*p,r[1]-c[1]*p]),s.push(d);const y=[];y.push([o[0]+c[0]*p,o[1]+c[1]*p]),y.push([r[0]+c[0]*p,r[1]+c[1]*p]),s.push(y);break}case L.Em.OffsetOpposite:{const r=this._cp2(i,3,0),l=this._cp3(i,r,.5,-1),c=this._sub(r,o);this._normalize(c);const p=this._crossProduct(c,this._sub(l,o));this._leftPerpendicular(c);const d=[];d.push([o[0]-c[0]*p,o[1]-c[1]*p]),d.push([r[0]-c[0]*p,r[1]-c[1]*p]),s.push(d);break}case L.Em.OffsetSame:{const r=this._cp2(i,3,0),l=this._cp3(i,r,.5,-1),c=this._sub(r,o);this._normalize(c);const p=this._crossProduct(c,this._sub(l,o));this._leftPerpendicular(c);const d=[];d.push([o[0]+c[0]*p,o[1]+c[1]*p]),d.push([r[0]+c[0]*p,r[1]+c[1]*p]),s.push(d);break}case L.Em.CircleWithArc:{let r=this._cp2(i,3,0);const l=this._cp3(i,r,.5,-1);let c,p;if(h>=4)c=i[3],p=this._crossProduct(this._sub(c,r),this._sub(l,r))>0;else{c=r,p=this._crossProduct(this._sub(c,o),this._sub(l,o))>0;const W=24*this._geomUnitsPerPoint,K=this._sub(c,o);this._normalize(K,W);const ut=Math.sqrt(2)/2;this._rotateDirect(K,ut,p?ut:-ut),r=this._add(o,K)}const d=this._sub(r,o),y=Math.cos(Math.PI/18),R=Math.sin(Math.PI/18),N=[r];for(let W=1;W<=36;W++)this._rotateDirect(d,y,R),N.push(this._add(o,d));this._add90DegArc(N,r,c,l,p),(0,pt.qh)(N[N.length-8],1),s.push(N);break}case L.Em.DoubleJog:{let r,l,c=this._cp2(i,-3,1);if(r=h>=3?i[2]:this._add(o,this._sub(o,c)),h>=4)l=i[3];else{const Ct=o;o=c,l=r;const Ut=this._dist(o,Ct),Ft=this._dist(l,Ct);let xt=30*this._geomUnitsPerPoint;.5*Ut<xt&&(xt=.5*Ut),.5*Ft<xt&&(xt=.5*Ft),c=this._mix(o,xt/Ut,Ct,(Ut-xt)/Ut),r=this._mix(l,xt/Ft,Ct,(Ft-xt)/Ft)}const p=this._mid(o,c),d=this._mid(l,r),y=this._dist(o,c),R=this._dist(r,l);let N=Math.min(y,R)/8;N=Math.min(N,24*this._geomUnitsPerPoint);const W=Math.cos(Math.PI/4);let K=this._sub(o,c);this._normalize(K,N),this._crossProduct(K,this._sub(l,c))>0?this._rotateDirect(K,W,-W):this._rotateDirect(K,W,W);let ut=[];ut.push(c),ut.push(this._add(p,K)),ut.push(this._sub(p,K)),ut.push(o),s.push(ut),K=this._sub(l,r),this._normalize(K,N),this._crossProduct(K,this._sub(o,r))<0?this._rotateDirect(K,W,W):this._rotateDirect(K,W,-W),ut=[],ut.push(r),ut.push(this._add(d,K)),ut.push(this._sub(d,K)),ut.push(l),s.push(ut);break}case L.Em.PerpendicularOffset:{const r=this._cp2(i,-4,1),l=this._cp3(i,r,.882353,-1.94),c=this._sub(l,r);this._crossProduct(c,this._sub(o,r))>0?this._rightPerpendicular(c):this._leftPerpendicular(c);const p=[c[0]/8,c[1]/8],d=this._sub(this._mid(r,l),p);s.push([d,o]);break}case L.Em.LineExcludingLastSegment:{const r=this._arrowPath(i),l=[];let c=r.length-2;for(;c--;)l.push(r[c]);s.push(l);break}case L.Em.MultivertexArrow:{const r=this._arrowPath(i),l=[];this._addArrow(l,r,!1),s.push(l);break}case L.Em.CrossedArrow:{const r=this._arrowPath(i),l=[];this._addArrow(l,r,!0),s.push(l);break}case L.Em.ChevronArrow:{const[r,l]=this._arrowLastSeg(i),c=10*this._geomUnitsPerPoint,p=this._sub(o,r);this._normalize(p);const d=this._crossProduct(p,this._sub(l,r)),y=this._leftPerp(p),R=[l[0]-y[0]*d*2,l[1]-y[1]*d*2],N=[];N.push([l[0]+p[0]*c,l[1]+p[1]*c]),N.push(o),N.push([R[0]+p[0]*c,R[1]+p[1]*c]),s.push(N);break}case L.Em.ChevronArrowOffset:{const[r,l]=this._arrowLastSeg(i),c=this._sub(o,r);this._normalize(c);const p=this._crossProduct(c,this._sub(l,r));this._leftPerpendicular(c);const d=[l[0]-c[0]*p,l[1]-c[1]*p],y=[];y.push([d[0]+c[0]*p*.5,d[1]+c[1]*p*.5]),y.push(this._mid(d,o)),y.push([d[0]-c[0]*p*.5,d[1]-c[1]*p*.5]),s.push(y);break}case L.Em.PartialFirstSegment:{const[r,l]=this._arrowLastSeg(i),c=this._sub(o,r);this._normalize(c);const p=this._crossProduct(c,this._sub(l,r));this._leftPerpendicular(c),s.push([r,[l[0]-c[0]*p,l[1]-c[1]*p]]);break}case L.Em.Arch:{const r=this._cp2(i,0,-1),l=this._cp3(i,r,.5,1),c=this._sub(o,r),p=this._mix(l,1,c,.55),d=this._mix(l,1,c,-.55),y=[o];this._addBezier2(y,o,p,l,4),this._addBezier2(y,l,d,r,4),s.push(y);break}case L.Em.CurvedParallelTicks:{const r=this._cp2(i,-4,1),l=this._cp3(i,r,.882353,-1.94),c=this._sub(l,r);this._crossProduct(c,this._sub(o,r))>0?this._rightPerpendicular(c):this._leftPerpendicular(c);const p=[c[0]/8,c[1]/8],d=this._sub(this._mid(r,l),p),y=this._sub(this._mix(r,.75,l,.25),p),R=this._sub(this._mix(r,.25,l,.75),p),N=[r];this._addBezier2(N,r,y,d,3),this._addBezier2(N,d,R,l,3),s.push(N);for(let W=0;W<8;W++){const K=N[2*W+1],ut=[this._clone(K)];ut.push(this._add(K,[c[0]/4,c[1]/4])),s.push(ut)}break}case L.Em.Arc90Degrees:{const r=this._cp2(i,0,-1),l=this._cp3(i,r,.5,1),c=[r];this._add90DegArc(c,r,o,l),s.push(c);break}default:s.push(i)}}return s}}let D=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(s,i,h,o,r){return new it(s,i,h)}}return f.instance=null,f})();class it extends pt.zY{constructor(e,s,i){super(e,!0,!0),this._curveHelper=new Q,this._beginCut=(void 0!==s.beginCut?s.beginCut:1)*i,this._endCut=(void 0!==s.endCut?s.endCut:1)*i,this._middleCut=(void 0!==s.middleCut?s.middleCut:0)*i,this._invert=void 0!==s.invert&&s.invert,this._beginCut<0&&(this._beginCut=0),this._endCut<0&&(this._endCut=0),this._middleCut<0&&(this._middleCut=0)}processPath(e){const s=this._beginCut,i=this._endCut,h=this._middleCut,o=this._curveHelper.calculatePathLength(e),r=[];if(this._invert){if(0!==s||0!==i||0!==h)if(s+i+h>=o)r.push(e);else{let l=this._curveHelper.getSubCurve(e,0,s);l&&r.push(l),l=this._curveHelper.getSubCurve(e,.5*(o-h),.5*(o+h)),l&&r.push(l),l=this._curveHelper.getSubCurve(e,o-i,i),l&&r.push(l)}}else if(0===s&&0===i&&0===h)r.push(e);else if(!(s+i+h>=o))if(0===h){const l=this._curveHelper.getSubCurve(e,s,o-i);l&&r.push(l)}else{let l=this._curveHelper.getSubCurve(e,s,.5*(o-h));l&&r.push(l),l=this._curveHelper.getSubCurve(e,.5*(o+h),o-i),l&&r.push(l)}return 0===r.length?null:{paths:r}}}class zt{constructor(){this._values=[],this.extPtGap=0,this.ctrlPtGap=0,this._length=0,this._currentValue=0}isEmpty(){return 0===this._values.length}size(){return this._values.length}init(e,s,i=!0){if(this._setEmpty(),!e||0===e.length)return!1;for(let h=0;h<e.length;h++){let o=Math.abs(e[h]);i&&o<1e-7&&(o=1e-7),this._values.push(o),this._length+=o}return s&&1&e.length&&(this._length*=2),0!==this._length&&(this.ctrlPtGap=this.extPtGap=0,this._currentValue=-1,!0)}scale(e){const s=this._values?this._values.length:0;for(let i=0;i<s;++i)this._values[i]*=e;this._length*=e,this.extPtGap*=e,this.ctrlPtGap*=e}addValue(e){this._length+=e,this._values.push(e)}firstValue(){return this._values[0]}lastValue(){return this._values[this._values.length-1]}nextValue(){return this._currentValue++,this._currentValue===this._values.length&&(this._currentValue=0),this._values[this._currentValue]}reset(){this._currentValue=-1}length(){return this._length}_setEmpty(){this.extPtGap=this.ctrlPtGap=this._length=0,this._currentValue=-1,this._values.length=0}}class yt{constructor(){this.pt=null,this.ca=0,this.sa=0}}var Tt,f;(f=Tt||(Tt={}))[f.FAIL=0]="FAIL",f[f.END=1]="END",f[f.CONTINUE=2]="CONTINUE";class _t{constructor(){this.reset()}reset(){this.segment=-1,this.segmentLength=0,this.abscissa=0,this.isPathEnd=!1,this.isPartEnd=!1}isValid(){return-1!==this.segment}copyTo(e){e.segment=this.segment,e.segmentLength=this.segmentLength,e.abscissa=this.abscissa,e.isPathEnd=this.isPathEnd,e.isPartEnd=this.isPartEnd}}class B extends Q{constructor(e=0,s=!1){super(e,s),this._tolerance=at,this._currentPosition=new _t}updateTolerance(e){this._tolerance=at*e}init(e,s,i=!0){return i?(this._patternLength=s.length(),this._partExtPtGap=s.extPtGap,this._partCtrlPtGap=s.ctrlPtGap):(this._patternLength=0,this._partExtPtGap=0,this._partCtrlPtGap=0),this._currentPosition.reset(),this._partSegCount=0,this._path=e,this._seg=-1,this._setPosAtNextPart()}curPositionIsValid(){return this._currentPosition.isValid()}nextPosition(e,s=Tt.FAIL){const i=new _t;return!!this._nextPosition(e,i,null,s)&&(i.copyTo(this._currentPosition),!0)}curPointAndAngle(e){e.pt=this._getPoint(this._currentPosition);const[s,i]=this._getAngle(this._currentPosition);e.ca=s,e.sa=i}nextPointAndAngle(e,s,i=Tt.FAIL){const h=new _t;if(!this._nextPosition(e,h,null,i))return!1;h.copyTo(this._currentPosition),s.pt=this._getPoint(h);const[o,r]=this._getAngle(h);return s.ca=o,s.sa=r,!0}nextCurve(e){if(0===e)return null;const s=[],i=new _t;return this._nextPosition(e,i,s,Tt.END)?(i.copyTo(this._currentPosition),s):null}isPathEnd(){return this._currentPosition.isPathEnd}getPathEnd(){if(-1===this._currentPosition.segment)throw new Error("missing segment");return this._path[this._currentPosition.segment+1]}_nextPosition(e,s,i,h){if(this._currentPosition.isPathEnd)return!1;let o=this._currentPosition.abscissa;for(this._currentPosition.segmentLength>0&&(o/=this._currentPosition.segmentLength),this._currentPosition.copyTo(s);s.abscissa+e*this._partLengthRatio>s.segmentLength+this._tolerance;){if(i){if(0===i.length)if(0===o){const l=this._path[s.segment];i.push([l[0],l[1]])}else i.push(this.getSegCoord2D(this._path,s.segment,o));const r=this._path[s.segment+1];i.push([r[0],r[1]])}if(o=0,e-=(s.segmentLength-s.abscissa)/this._partLengthRatio,this._partSegCount)s.segment=this._nextSegment(),s.segmentLength=this.calculateSegLength(this._path,s.segment),s.abscissa=0,this._partSegCount--;else{if(!this._setPosAtNextPart())return h!==Tt.FAIL&&(s.segmentLength=this.calculateSegLength(this._path,s.segment),s.isPartEnd=!0,h===Tt.END?(s.abscissa=s.segmentLength,s.isPathEnd=!0):s.abscissa=s.segmentLength+e,!0);this._currentPosition.copyTo(s)}}if(s.abscissa+=e*this._partLengthRatio,i){if(0===i.length)if(0===o){const l=this._path[s.segment];i.push([l[0],l[1]])}else i.push(this.getSegCoord2D(this._path,s.segment,o));const r=s.abscissa/s.segmentLength;if(1===r){const l=this._path[s.segment+1];i.push([l[0],l[1]])}else i.push(this.getSegCoord2D(this._path,s.segment,r))}return this._partSegCount||Math.abs(s.abscissa-s.segmentLength)<this._tolerance&&(s.isPathEnd=this._partIsLast,s.isPartEnd=!0),!0}_getPoint(e){if(-1===e.segment)throw new Error("missing segment");return this.getSegCoord2D(this._path,e.segment,e.segmentLength<=0?0:e.abscissa/e.segmentLength)}_getAngle(e){if(-1===e.segment)throw new Error("missing segment");return this.getSegAngleCS(this._path,e.segment,e.segmentLength<=0?0:e.abscissa/e.segmentLength)}_setPosAtNextPart(){for(;this._partSegCount;)this._hasNextSegment()&&this._nextSegment(),this._partSegCount--;if(!this._hasNextSegment())return!1;for(this._partLength=0,this._partIsLast=!0,this._partSegCount=0;this._hasNextSegment();)if(this._partLength+=this.calculateSegLength(this._path,this._nextSegment()),this._partSegCount++,1===(0,pt.zv)(this._path[this._getEndPointIndex()])){this._partIsLast=!this._hasNextSegment();break}let e=this._partSegCount;for(;e;)this._previousSegment(),--e;this._currentPosition.segment=this._nextSegment(),this._currentPosition.segmentLength=this.calculateSegLength(this._path,this._currentPosition.segment),this._currentPosition.abscissa=0,this._currentPosition.isPathEnd=this._currentPosition.isPartEnd=!1,--this._partSegCount;const s=this._getStartPointIndex();this._ctrlPtBegin=1===(0,pt.zv)(this._path[s]);let i=s+this._partSegCount+1;if(i>=this._path.length&&(i=0),this._ctrlPtEnd=1===(0,pt.zv)(this._path[i]),this._patternLength>0){const h=this._ctrlPtBegin?this._partCtrlPtGap:this._partExtPtGap,o=this._ctrlPtEnd?this._partCtrlPtGap:this._partExtPtGap;let r=Math.round((this._partLength-(h+o))/this._patternLength);r<=0&&(r=h+o>0?0:1),this._partLengthRatio=this._partLength/(h+o+r*this._patternLength),this._partLengthRatio<.01&&(this._partLengthRatio=1)}else this._partLengthRatio=1;return!0}_hasNextSegment(){return this._seg<this._path.length-2}_previousSegment(){return--this._seg}_nextSegment(){return++this._seg}_getStartPointIndex(){return this._seg}_getEndPointIndex(){return this._seg+1}}let q=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(s,i,h,o,r){return new j(s,i,h)}}return f.instance=null,f})();class j extends pt.zY{constructor(e,s,i){super(e,!0,!0),this._firstCurve=null,this._walker=new B,this._walker.updateTolerance(i),this._endings=s.lineDashEnding,this._customDashPos=-(s.offsetAlongLine??0)*i,this._offsetAtEnd=(s.customEndingOffset??0)*i,this._pattern=new zt,this._pattern.init(s.dashTemplate,!0),this._pattern.scale(i)}processPath(e){if(0===this._pattern.length())return this.iteratePath=!1,{paths:[e]};if(!this.iteratePath){let h=!0;switch(this._endings){case L.sj.HalfPattern:case L.sj.HalfGap:default:this._pattern.extPtGap=0;break;case L.sj.FullPattern:this.isClosed||(this._pattern.extPtGap=.5*this._pattern.firstValue());break;case L.sj.FullGap:this.isClosed||(this._pattern.extPtGap=.5*this._pattern.lastValue());break;case L.sj.NoConstraint:this.isClosed||(h=!1);break;case L.sj.Custom:this.isClosed||(this._pattern.extPtGap=.5*this._offsetAtEnd)}const o=this._walker.calculatePathLength(e);if(this._pattern.isEmpty()||o<.1*this._pattern.length())return{paths:[e]};if(!this._walker.init(e,this._pattern,h))return{paths:[e]}}let s;if(this.iteratePath)s=this._pattern.nextValue();else{let h;switch(this._endings){case L.sj.HalfPattern:default:h=.5*this._pattern.firstValue();break;case L.sj.HalfGap:h=.5*-this._pattern.lastValue();break;case L.sj.FullGap:h=-this._pattern.lastValue();break;case L.sj.FullPattern:h=0;break;case L.sj.NoConstraint:case L.sj.Custom:h=-this._customDashPos}let o=h/this._pattern.length();o-=Math.floor(o),h=o*this._pattern.length(),this._pattern.reset(),s=this._pattern.nextValue();let r=!1;for(;h>=s;)h-=s,s=this._pattern.nextValue(),r=!r;s-=h,r?(this._walker.nextPosition(s),s=this._pattern.nextValue()):this.isClosed&&(this._firstCurve=this._walker.nextCurve(s),s=this._pattern.nextValue(),this._walker.nextPosition(s),s=this._pattern.nextValue())}let i=this._walker.nextCurve(s);return i?this._walker.isPathEnd()?(this.iteratePath=!1,this._firstCurve&&(this._firstCurve.splice(0,1),V.mergePath(i,this._firstCurve),this._firstCurve=null)):(s=this._pattern.nextValue(),!this._walker.nextPosition(s)||this._walker.isPathEnd()?(this.iteratePath=!1,this._firstCurve&&(i=this._firstCurve,this._firstCurve=null)):this.iteratePath=!0):(this.iteratePath=!1,i=this._firstCurve,this._firstCurve=null),{paths:[i]}}}let Z=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(s,i,h,o,r){return new rt(s,i,h,o,r)}}return f.instance=null,f})();class rt{constructor(e,s,i,h,o){this._inputGeometries=e,this._tileKey=h,this._geometryEngine=o,this._width=(void 0!==s.width?s.width:2)*i,this._option=s.option}next(){let e;for(;e=this._inputGeometries.next();){if((0,nt.YX)(e)&&this._width>0){if(Math.min(e.xmax-e.xmin,e.ymax-e.ymin)-2*this._width<0)return e;const s=[];return s.push([[e.xmin,e.ymin],[e.xmin,e.ymax],[e.xmax,e.ymax],[e.xmax,e.ymin],[e.xmin,e.ymin]]),s.push([[e.xmin+this._width,e.ymin+this._width],[e.xmax-this._width,e.ymin+this._width],[e.xmax-this._width,e.ymax-this._width],[e.xmin+this._width,e.ymax-this._width],[e.xmin+this._width,e.ymin+this._width]]),{rings:s}}if((0,nt.oU)(e)){let s=null;const i=this._geometryEngine;let h=e;if(this._tileKey&&(h=(0,A.ib)(e,Math.abs(this._width)+1),!h||!h.rings||0===h.rings.length))continue;if((0,ht.pC)(i)&&(s=i.buffer(St.Z.WebMercator,h,-this._width,1)),this._width>0){const o=[];for(const r of e.rings)r&&o.push(r);if(s)for(const r of s.rings)r&&o.push(r.reverse());if(o.length)return{rings:o}}}}return null}}let dt=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(s,i,h,o,r){return new Nt(s,i,h)}}return f.instance=null,f})();class Nt extends pt.zY{constructor(e,s,i){super(e,!1,!0),this._curveHelper=new Q,this._length=(void 0!==s.length?s.length:20)*i,this._angle=void 0!==s.angle?s.angle:225,this._position=void 0!==s.position?s.position:50,this._length<0&&(this._length=-this._length),this._position<20&&(this._position=20),this._position>80&&(this._position=80),this._mirror=!1}processPath(e){if(this._curveHelper.isEmpty(e,!1))return null;const s=e[0],i=e[e.length-1];this._curveHelper.normalize([i[0]-s[0],i[1]-s[1]]);const o=[s[0]+(i[0]-s[0])*this._position/100,s[1]+(i[1]-s[1])*this._position/100],r=Math.cos((90-this._angle)/180*Math.PI);let l=Math.sin((90-this._angle)/180*Math.PI);return this._mirror&&(l=-l),this._mirror=!this._mirror,{paths:[[s,[o[0]-this._length/2*r,o[1]-this._length/2*l],[o[0]+this._length/2*r,o[1]+this._length/2*l],i]]}}}let kt=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(s,i,h,o,r){return new Gt(s,i,h)}}return f.instance=null,f})();class Gt{constructor(e,s,i){this._inputGeometries=e,this._offsetX=void 0!==s.offsetX?s.offsetX*i:0,this._offsetY=void 0!==s.offsetY?-s.offsetY*i:0}next(){let e=this._inputGeometries.next();for(;e;){if((0,nt.YX)(e))return{xmin:e.xmin+this._offsetX,xmax:e.xmax+this._offsetX,ymin:e.ymin+this._offsetY,ymax:e.ymax+this._offsetY};if((0,nt.oU)(e)){const s=(0,At.d9)(e);return this._moveMultipath(s.rings,this._offsetX,this._offsetY),s}if((0,nt.l9)(e)){const s=(0,At.d9)(e);return this._moveMultipath(s.paths,this._offsetX,this._offsetY),s}if((0,nt.aW)(e)){const s=(0,At.d9)(e);return this._movePath(s.points,this._offsetX,this._offsetY),s}if((0,nt.wp)(e))return{x:e.x+this._offsetX,y:e.y+this._offsetY};e=this._inputGeometries.next()}return null}_moveMultipath(e,s,i){if(e)for(const h of e)this._movePath(h,s,i)}_movePath(e,s,i){if(e)for(const h of e)h[0]+=s,h[1]+=i}}let Xt=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(s,i,h,o,r){return new lt(s,i,h,o,r)}}return f.instance=null,f})();class lt{constructor(e,s,i,h,o){this._inputGeometries=e,this._tileKey=h,this._geometryEngine=o,this._curveHelper=new Q,this._offset=(s.offset??1)*i,this._method=s.method,this._option=s.option,this._offsetFlattenError=at*i}next(){let e;for(;e=this._inputGeometries.next();){if(0===this._offset)return e;if((0,nt.YX)(e)){if(this._method===L.id.Rounded&&this._offset>0){const o=this._curveHelper.offset([[e.xmin,e.ymin],[e.xmin,e.ymax],[e.xmax,e.ymax],[e.xmax,e.ymin],[e.xmin,e.ymin]],-this._offset,this._method,4,this._offsetFlattenError);return o?{rings:[o]}:null}if(Math.min(e.xmax-e.xmin,e.ymax-e.ymin)+2*this._offset>0)return{xmin:e.xmin-this._offset,xmax:e.xmax+this._offset,ymin:e.ymin-this._offset,ymax:e.ymax+this._offset}}const s=this._geometryEngine;if((0,ht.Wi)(s))return null;let i=e;if((0,nt.oU)(e)){if(this._tileKey&&(i=(0,A.ib)(e,Math.abs(this._offset)+1),!i||!i.rings||0===i.rings.length))continue}else if((0,nt.l9)(e)&&this._tileKey&&(i=(0,A.yn)(e,Math.abs(this._offset)+1),!i||!i.paths||0===i.paths.length))continue;return s.offset(St.Z.WebMercator,i,-this._offset,1,this._method,4,this._offsetFlattenError)}return null}}let a=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(s,i,h,o,r){return new _(s,i,h)}}return f.instance=null,f})();class _{constructor(e,s,i){this._inputGeometries=e,this._reverse=void 0===s.reverse||s.reverse}next(){let e=this._inputGeometries.next();for(;e;){if(!this._reverse)return e;if((0,nt.l9)(e)){const s=(0,At.d9)(e);return(0,pt.ov)(s.paths),s}e=this._inputGeometries.next()}return null}}var I=G(6848),b=G(71949);let k=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(s,i,h,o,r){return new F(s,i,h)}}return f.instance=null,f})();class F{constructor(e,s,i){this._inputGeometries=e,this._rotateAngle=void 0!==s.angle?s.angle*Math.PI/180:0}next(){let e=this._inputGeometries.next();for(;e;){if(0===this._rotateAngle)return e;const s=(0,I.Ue)();(0,b.$P)(s,e);const i=(s[2]+s[0])/2,h=(s[3]+s[1])/2;if((0,nt.YX)(e)){const o={rings:[[[e.xmin,e.ymin],[e.xmin,e.ymax],[e.xmax,e.ymax],[e.xmax,e.ymin],[e.xmin,e.ymin]]]};return this._rotateMultipath(o.rings,i,h),o}if((0,nt.oU)(e)){const o=(0,At.d9)(e);return this._rotateMultipath(o.rings,i,h),o}if((0,nt.l9)(e)){const o=(0,At.d9)(e);return this._rotateMultipath(o.paths,i,h),o}if((0,nt.aW)(e)){const o=(0,At.d9)(e);return this._rotatePath(o.points,i,h),o}if((0,nt.wp)(e))return e;e=this._inputGeometries.next()}return null}_rotateMultipath(e,s,i){if(e)for(const h of e)this._rotatePath(h,s,i)}_rotatePath(e,s,i){if(e){const h=Math.cos(this._rotateAngle),o=Math.sin(this._rotateAngle);for(const r of e){const l=r[0]-s,c=r[1]-i;r[0]=s+l*h-c*o,r[1]=i+l*o+c*h}}}}let x=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(s,i,h,o,r){return new et(s,i,h)}}return f.instance=null,f})();class et{constructor(e,s,i){this._inputGeometries=e,this._xFactor=void 0!==s.xScaleFactor?s.xScaleFactor:1.15,this._yFactor=void 0!==s.yScaleFactor?s.yScaleFactor:1.15}next(){let e=this._inputGeometries.next();for(;e;){if(1===this._xFactor&&1===this._yFactor)return e;const s=(0,I.Ue)();(0,b.$P)(s,e);const i=(s[2]+s[0])/2,h=(s[3]+s[1])/2;if((0,nt.YX)(e)){const o={rings:[[[e.xmin,e.ymin],[e.xmin,e.ymax],[e.xmax,e.ymax],[e.xmax,e.ymin],[e.xmin,e.ymin]]]};return this._scaleMultipath(o.rings,i,h),o}if((0,nt.oU)(e)){const o=(0,At.d9)(e);return this._scaleMultipath(o.rings,i,h),o}if((0,nt.l9)(e)){const o=(0,At.d9)(e);return this._scaleMultipath(o.paths,i,h),o}if((0,nt.aW)(e)){const o=(0,At.d9)(e);return this._scalePath(o.points,i,h),o}if((0,nt.wp)(e))return e;e=this._inputGeometries.next()}return null}_scaleMultipath(e,s,i){if(e)for(const h of e)this._scalePath(h,s,i)}_scalePath(e,s,i){if(e)for(const h of e){const r=(h[1]-i)*this._yFactor;h[0]=s+(h[0]-s)*this._xFactor,h[1]=i+r}}}let Pt=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(s,i,h,o,r){return new z(s,i,h)}}return f.instance=null,f})();class z{constructor(e,s,i){this._inputGeometries=e,this._height=(void 0!==s.amplitude?s.amplitude:2)*i,this._period=(void 0!==s.period?s.period:3)*i,this._style=s.waveform,this._height<=0&&(this._height=Math.abs(this._height)),this._period<=0&&(this._period=Math.abs(this._period)),this._pattern=new zt,this._pattern.addValue(this._period),this._pattern.addValue(this._period),this._walker=new B,this._walker.updateTolerance(i)}next(){let e=this._inputGeometries.next();for(;e;){if(0===this._height||0===this._period)return e;if((0,nt.l9)(e)){const s=this._processGeom(e.paths);if(s.length)return{paths:s}}if((0,nt.oU)(e)){const s=this._processGeom(e.rings);if(s.length)return{rings:s}}e=this._inputGeometries.next()}return null}_processGeom(e){const s=[];for(const i of e)if(this._walker.init(i,this._pattern))switch(this._style){case L.zQ.Sinus:default:s.push(this._constructCurve(i,!1));break;case L.zQ.Square:s.push(this._constructSquare(i));break;case L.zQ.Triangle:s.push(this._constructTriangle(i));break;case L.zQ.Random:s.push(this._constructCurve(i,!0))}else s.push(i);return s}_constructCurve(e,s){const i=new V,h=this._walker.calculatePathLength(e);let o=Math.round(h/this._period);0===o&&(o=1);const c=this._period/16,p=1/(16*o+1),d=2*Math.PI*h/(h/o),y=2*Math.PI*Math.random(),R=2*Math.PI*Math.random(),N=2*Math.PI*Math.random(),W=.75-Math.random()/2,K=.75-Math.random()/2,ut=new yt;this._walker.curPointAndAngle(ut),i.startPath(ut.pt);let Ct=0;for(;;){if(!this._walker.nextPointAndAngle(c,ut)){i.lineTo(e[e.length-1]);break}{const Ut=Ct;let Ft;if(Ct+=p,s){const xt=this._height/2*(1+.3*Math.sin(W*d*Ut+y));Ft=xt*Math.sin(d*Ut+R),Ft+=xt*Math.sin(K*d*Ut+N),Ft/=2}else Ft=.5*this._height*Math.sin(.5*d*Ut);i.lineTo([ut.pt[0]-Ft*ut.sa,ut.pt[1]+Ft*ut.ca])}}return i.path()}_constructSquare(e){const s=new V,i=this._walker.calculatePathLength(e);Math.round(i/this._period);let h=!0;for(;;){let o=!1;if(this._walker.curPositionIsValid()){const r=new yt;this._walker.curPointAndAngle(r);const l=new yt;if(this._walker.nextPointAndAngle(this._period,l)){const c=new yt;this._walker.nextPointAndAngle(this._period,c)&&(h?(s.startPath(r.pt),h=!1):s.lineTo(r.pt),s.lineTo([r.pt[0]-this._height/2*r.sa,r.pt[1]+this._height/2*r.ca]),s.lineTo([l.pt[0]-this._height/2*l.sa,l.pt[1]+this._height/2*l.ca]),s.lineTo([l.pt[0]+this._height/2*l.sa,l.pt[1]-this._height/2*l.ca]),s.lineTo([c.pt[0]+this._height/2*c.sa,c.pt[1]-this._height/2*c.ca]),o=!0)}}if(!o){s.lineTo(this._walker.getPathEnd());break}}return s.path()}_constructTriangle(e){const s=new V,i=this._walker.calculatePathLength(e);Math.round(i/this._period);let h=!0;for(;;){let o=!1;if(this._walker.curPositionIsValid()){const r=new yt;this._walker.curPointAndAngle(r);const l=new yt;if(this._walker.nextPointAndAngle(this._period/2,l)){const c=new yt;this._walker.nextPointAndAngle(this._period,c)&&(this._walker.nextPosition(this._period/2)&&(h?(s.startPath(r.pt),h=!1):s.lineTo(r.pt),s.lineTo([l.pt[0]-this._height/2*l.sa,l.pt[1]+this._height/2*l.ca]),s.lineTo([c.pt[0]+this._height/2*c.sa,c.pt[1]-this._height/2*c.ca])),o=!0)}}if(!o){s.lineTo(this._walker.getPathEnd());break}}return s.path()}}let u=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(s,i,h,o,r){return new g(s,i,h)}}return f.instance=null,f})();class g extends pt.v1{constructor(e,s,i){super(e,!0,!0),this._geometryWalker=new B,this._geometryWalker.updateTolerance(i),this._angleToLine=s.angleToLine??!0,this._offset=(s.offset?s.offset:0)*i,this._originalEndings=s.endings,this._offsetAtEnd=(s.customEndingOffset?s.customEndingOffset:0)*i,this._position=-(s.offsetAlongLine?s.offsetAlongLine:0)*i,this._pattern=new zt,this._pattern.init(s.placementTemplate,!1),this._pattern.scale(i),this._endings=this._originalEndings}processPath(e){if(this._pattern.isEmpty())return null;let s;if(this.iteratePath)s=this._pattern.nextValue();else{this._endings=this._originalEndings===L.JS.WithFullGap&&this.isClosed?L.JS.WithMarkers:this._originalEndings,this._pattern.extPtGap=0;let h,o=!0;switch(this._endings){case L.JS.NoConstraint:h=-this._position,h=this._adjustPosition(h),o=!1;break;case L.JS.WithHalfGap:default:h=-this._pattern.lastValue()/2;break;case L.JS.WithFullGap:h=-this._pattern.lastValue(),this._pattern.extPtGap=this._pattern.lastValue();break;case L.JS.WithMarkers:h=0;break;case L.JS.Custom:h=-this._position,h=this._adjustPosition(h),this._pattern.extPtGap=.5*this._offsetAtEnd}if(!this._geometryWalker.init(e,this._pattern,o))return null;this._pattern.reset();let r=0;for(;h>r;)h-=r,r=this._pattern.nextValue();r-=h,s=r,this.iteratePath=!0}const i=new yt;return this._geometryWalker.nextPointAndAngle(s,i)?this._endings===L.JS.WithFullGap&&this._geometryWalker.isPathEnd()?(this.iteratePath=!1,null):this._endings===L.JS.WithMarkers&&this._geometryWalker.isPathEnd()&&(this.iteratePath=!1,this.isClosed)?null:(this.internalPlacement.setTranslate(i.pt[0]-this._offset*i.sa,i.pt[1]+this._offset*i.ca),this._angleToLine&&this.internalPlacement.setRotateCS(i.ca,i.sa),this.internalPlacement):(this.iteratePath=!1,null)}_adjustPosition(e){let s=e/this._pattern.length();return s-=Math.floor(s),s*this._pattern.length()}}let C=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(s,i,h,o,r){return new w(s,i,h)}}return f.instance=null,f})();class w extends pt.v1{constructor(e,s,i){super(e,!1,!0),this._curveHelper=new Q,this._angleToLine=void 0===s.angleToLine||s.angleToLine,this._offset=void 0!==s.offset?s.offset*i:0,this._type=s.extremityPlacement,this._position=void 0!==s.offsetAlongLine?s.offsetAlongLine*i:0,this._beginProcessed=!1}processPath(e){let s;switch(this._type){case L.Tx.Both:default:this._beginProcessed?(s=this._atExtremities(e,this._position,!1),this._beginProcessed=!1,this.iteratePath=!1):(s=this._atExtremities(e,this._position,!0),this._beginProcessed=!0,this.iteratePath=!0);break;case L.Tx.JustBegin:s=this._atExtremities(e,this._position,!0);break;case L.Tx.JustEnd:s=this._atExtremities(e,this._position,!1);case L.Tx.None:}return s}_atExtremities(e,s,i){const h=e.length;if(h<2)return null;const r=i?h:-1,l=i?1:-1;let c,p=0,d=i?e[0]:e[h-1];for(let y=i?1:h-2;y!==r;y+=l){c=d,d=e[y];const R=this._curveHelper.calculateLength(c,d);if(p+R>s){const N=(s-p)/R,[W,K]=this._curveHelper.getAngleCS(c,d,N),ut=(0,pt.XV)(c,d,N);return this.internalPlacement.setTranslate(ut[0]-this._offset*K,ut[1]+this._offset*W),this._angleToLine&&this.internalPlacement.setRotateCS(-W,-K),this.internalPlacement}p+=R}return null}}let S=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(s,i,h,o,r){return new n(s,i,h)}}return f.instance=null,f})();class n extends pt.v1{constructor(e,s,i){super(e,!0,!0),this._walker=new B,this._walker.updateTolerance(i),this._angleToLine=void 0===s.angleToLine||s.angleToLine,this._offset=void 0!==s.offset?s.offset*i:0,this._beginGap=void 0!==s.beginPosition?s.beginPosition*i:0,this._endGap=void 0!==s.endPosition?s.endPosition*i:0,this._flipFirst=void 0===s.flipFirst||s.flipFirst,this._pattern=new zt,this._pattern.init(s.positionArray,!1,!1),this._subPathLen=0,this._posCount=this._pattern.size(),this._isFirst=!0,this._prevPos=0}processPath(e){if(this._pattern.isEmpty())return null;let s;if(this.iteratePath){const l=this._pattern.nextValue()*this._subPathLen,c=this._beginGap+l;s=c-this._prevPos,this._prevPos=c}else{if(this._posCount=this._pattern.size(),this._isFirst=!0,this._prevPos=0,this._subPathLen=this._walker.calculatePathLength(e)-this._beginGap-this._endGap,this._subPathLen<0)return this.iteratePath=!1,null;if(!this._walker.init(e,this._pattern,!1))return null;this._pattern.reset();const l=this._pattern.nextValue()*this._subPathLen,c=this._beginGap+l;s=c-this._prevPos,this._prevPos=c,this.iteratePath=!0}const i=new yt;if(!this._walker.nextPointAndAngle(s,i,Tt.END))return this.iteratePath=!1,null;let o,r;return this.internalPlacement.setTranslate(i.pt[0]-this._offset*i.sa,i.pt[1]+this._offset*i.ca),this._angleToLine?(o=i.ca,r=i.sa):(o=1,r=0),this._isFirst&&this._flipFirst&&(o=-o,r=-r),this.internalPlacement.setRotateCS(o,r),this._isFirst=!1,this._posCount--,0===this._posCount&&(this.iteratePath=!1),this.internalPlacement}}var P=G(37313),m=G(46806);const v=512,X=24;let Y=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(s,i,h,o,r){return new $(s,i,h,o,r)}}return f.instance=null,f})();class ${constructor(e,s,i,h,o){if(this._xMin=0,this._xMax=0,this._yMin=0,this._yMax=0,this._currentX=0,this._currentY=0,this._accelerationMap=null,this._testInsidePolygon=!1,this._verticalSubdivision=!0,this._stepX=Math.abs(s.stepX??16)*i,this._stepY=Math.abs(s.stepY??16)*i,0!==this._stepX&&0!==this._stepY&&e&&function T(f){return void 0!==f.rings}(e)&&e.rings){if(this._gridType=s.gridType??L.bj.Fixed,this._gridType===L.bj.Random)this._randomLCG=new P.Z(1*(s.seed??13)),this._randomness=(s.randomness??100)/100,this._gridAngle=0,this._shiftOddRows=!1,this._cosAngle=1,this._sinAngle=0,this._offsetX=0,this._offsetY=0,this._buildRandomValues();else{if(this._randomness=0,this._gridAngle=s.gridAngle??0,this._shiftOddRows=s.shiftOddRows??!1,this._offsetX=(s.offsetX??0)*i,this._offsetY=(s.offsetY??0)*i,this._cosAngle=Math.cos(this._gridAngle/180*Math.PI),this._sinAngle=-Math.sin(this._gridAngle/180*Math.PI),this._stepX)if(this._offsetX<0)for(;this._offsetX<-.5*this._stepX;)this._offsetX+=this._stepX;else for(;this._offsetX>=.5*this._stepX;)this._offsetX-=this._stepX;if(this._stepY)if(this._offsetY<0)for(;this._offsetY<-.5*this._stepY;)this._offsetY+=this._stepY;else for(;this._offsetY>=.5*this._stepY;)this._offsetY-=this._stepY}if(this._graphicOriginX=0,this._graphicOriginY=0,null!=h){const[r,l,c]=h.split("/"),p=parseFloat(l),d=parseFloat(c);this._graphicOriginX=-d*v,this._graphicOriginY=p*v,this._testInsidePolygon=!0}this._internalPlacement=new m.u,this._calculateMinMax(e),this._geometry=e}}next(){return this._geometry?this._nextInside():null}_buildRandomValues(){if(!$._randValues){$._randValues=[];for(let e=0;e<X;e++)for(let s=0;s<X;s++)$._randValues.push(this._randomLCG.getFloat()),$._randValues.push(this._randomLCG.getFloat())}}_calculateMinMax(e){let s,i,h,o,r,l,c,p,d,y,R,N,W,K;this._xMin=0,this._xMax=0,this._yMin=0,this._yMax=0,c=p=W=R=Number.MAX_VALUE,d=y=K=N=-Number.MAX_VALUE;const ut=1!==this._cosAngle;let Ct=0;for(const xt of e.rings){const qt=xt?xt.length:0;for(let Vt=0;Vt<qt;Vt++)l=xt[Vt][0],r=xt[Vt][1],s=l-this._graphicOriginX-this._offsetX,i=r-this._graphicOriginY-this._offsetY,ut?(h=this._cosAngle*s-this._sinAngle*i,o=this._sinAngle*s+this._cosAngle*i):(h=s,o=i),c=Math.min(c,h),d=Math.max(d,h),p=Math.min(p,o),y=Math.max(y,o),R=Math.min(R,r),N=Math.max(N,r),W=Math.min(W,l),K=Math.max(K,l),Ct++}R=R!==Number.MAX_VALUE?R:-v-this._stepY,N=N!==-Number.MAX_VALUE?N:this._stepY,W=W!==Number.MAX_VALUE?W:-this._stepX,K=K!==-Number.MAX_VALUE?K:v+this._stepX;const Ut=N-R,Ft=K-W;if(this._verticalSubdivision=Ut>=Ft,this._polygonMin=this._verticalSubdivision?R:W,this._testInsidePolygon){let xt=0-this._graphicOriginX-this._offsetX-this._stepX,qt=v-this._graphicOriginX-this._offsetX+this._stepX,Vt=-v-this._graphicOriginY-this._offsetY-this._stepY,oe=0-this._graphicOriginY-this._offsetY+this._stepY;if(ut){const xe=[[xt,Vt],[xt,oe],[qt,Vt],[qt,oe]];xt=Vt=Number.MAX_VALUE,qt=oe=-Number.MAX_VALUE;for(const de of xe){const Kt=this._cosAngle*de[0]-this._sinAngle*de[1],he=this._sinAngle*de[0]+this._cosAngle*de[1];xt=Math.min(xt,Kt),qt=Math.max(qt,Kt),Vt=Math.min(Vt,he),oe=Math.max(oe,he)}}c=c!==Number.MAX_VALUE?Math.max(c,xt):xt,p=p!==Number.MAX_VALUE?Math.max(p,Vt):Vt,d=d!==-Number.MAX_VALUE?Math.min(d,qt):qt,y=y!==-Number.MAX_VALUE?Math.min(y,oe):oe}this._xMin=Math.round(c/this._stepX),this._xMax=Math.round(d/this._stepX),this._yMin=Math.round(p/this._stepY),this._yMax=Math.round(y/this._stepY),this._currentX=this._xMax+1,this._currentY=this._yMin-1,this._testInsidePolygon&&Ct>12&&(Ut>25||Ft>25)&&this._buildAccelerationMap(e,W,K,R,N)}_buildAccelerationMap(e,s,i,h,o){const{rings:r}=e,l=new Map,c=this._verticalSubdivision,p=c?o-h:i-s;let d=Math.ceil(p/10);if(d<=1)return;const y=Math.floor(p/d);let R,N,W,K,ut,Ct,Ut,Ft,xt,qt;d++,this._delta=y,c?(Ft=-v-this._stepY,xt=this._stepY,qt=h):(Ft=-this._stepX,xt=v+this._stepX,qt=s);for(let Vt=0;Vt<r.length;Vt++)if(R=r[Vt],!(R.length<2))for(let oe=1;oe<R.length;oe++){if(N=R[oe-1],W=R[oe],c){if(N[1]===W[1]||N[1]<Ft&&W[1]<Ft||N[1]>xt&&W[1]>xt)continue;K=Math.min(N[1],W[1]),ut=Math.max(N[1],W[1])}else{if(N[0]===W[0]||N[0]<Ft&&W[0]<Ft||N[0]>xt&&W[0]>xt)continue;K=Math.min(N[0],W[0]),ut=Math.max(N[0],W[0])}for(;K<ut;)Ct=Math.floor((K-qt)/y),st(Ct,Vt,oe,l),K+=y;Ut=Math.floor((ut-qt)/y),Ut>Ct&&st(Ut,Vt,oe,l)}this._accelerationMap=l}_nextInside(){for(;;){if(this._currentX>this._xMax){if(this._currentY++,this._currentY>this._yMax)return null;this._currentX=this._xMin,this._shiftOddRows&&this._currentY%2&&this._currentX--}let e=this._currentX*this._stepX+this._offsetX;this._shiftOddRows&&this._currentY%2&&(e+=.5*this._stepX);const s=this._currentY*this._stepY+this._offsetY;let i,h;if(this._currentX++,this._gridType===L.bj.Random){const o=(this._currentX%X+X)%X,r=(this._currentY%X+X)%X;i=this._graphicOriginX+e+this._stepX*this._randomness*(.5-$._randValues[r*X+o])*2/3,h=this._graphicOriginY+s+this._stepY*this._randomness*(.5-$._randValues[r*X+o+1])*2/3}else i=this._graphicOriginX+this._cosAngle*e+this._sinAngle*s,h=this._graphicOriginY-this._sinAngle*e+this._cosAngle*s;if(!this._testInsidePolygon||this._isInsidePolygon(i,h,this._geometry))return this._internalPlacement.setTranslate(i,h),this._internalPlacement}}_isInsidePolygon(e,s,i){const{rings:h}=i;if((0,ht.Wi)(this._accelerationMap))return function ot(f,e,s){const{rings:i}=s;let h,o,r,l=0;for(const c of i){h=c.length;for(let p=1;p<h;++p)o=c[p-1],r=c[p],o[1]>e!=r[1]>e&&((r[0]-o[0])*(e-o[1])-(r[1]-o[1])*(f-o[0])>0?l++:l--)}return 0!==l}(e,s,i);const o=this._verticalSubdivision,l=Math.floor(((o?s:e)-this._polygonMin)/this._delta),c=this._accelerationMap.get(l);if(!c)return!1;let p,d,y,R,N,W=0;for(const K of c){N=K[0];const ut=h[N];if(R=K[1],p=ut[R-1],d=ut[R],o){if(p[1]>s==d[1]>s)continue;y=(d[0]-p[0])*(s-p[1])-(d[1]-p[1])*(e-p[0])}else{if(p[0]>e==d[0]>e)continue;y=(d[1]-p[1])*(e-p[0])-(d[0]-p[0])*(s-p[1])}y>0?W++:W--}return 0!==W}}function st(f,e,s,i){let h=i.get(f);h||(h=[],i.set(f,h)),h.push([e,s])}let Lt=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(s,i,h,o,r){return new Et(s,i,h)}}return f.instance=null,f})();class Et extends pt.v1{constructor(e,s,i){super(e,!0,!0),this._curveHelper=new Q,this._angleToLine=void 0===s.angleToLine||s.angleToLine,this._offset=void 0!==s.offset?s.offset*i:0,this._relativeTo=s.relativeTo,this._position=void 0!==s.startPointOffset?s.startPointOffset*i:0,this._epsilon=.001*i}processPath(e){const s=this._position;if(this._relativeTo===L.CS.SegmentMidpoint){for(this.iteratePath||(this._segmentCount=e.length,this._curSegment=1,this.iteratePath=!0);this._curSegment<this._segmentCount;){const h=this._curSegment;this._curSegment++;const o=e[h-1],r=e[h],l=this._curveHelper.calculateLength(o,r);if(l<this._epsilon)continue;const c=.5+this._position/l,[p,d]=this._curveHelper.getAngleCS(o,r,c),y=(0,pt.XV)(o,r,c);return this.internalPlacement.setTranslate(y[0]-this._offset*d,y[1]+this._offset*p),this._angleToLine&&this.internalPlacement.setRotateCS(p,d),this.internalPlacement}return this.iteratePath=!1,null}this._relativeTo===L.CS.LineEnd&&(0,pt.hh)(e);const i=this.onLine(e,s);return this._relativeTo===L.CS.LineEnd&&(0,pt.hh)(e),i}onLine(e,s){let i,h=!1;switch(this._relativeTo){case L.CS.LineMiddle:default:i=this._curveHelper.calculatePathLength(e)/2+s;break;case L.CS.LineBeginning:i=s;break;case L.CS.LineEnd:i=s,h=!0}const o=e.length;let r,l=0,c=e[0];for(let p=1;p<o;++p){r=c,c=e[p];const d=this._curveHelper.calculateLength(r,c);if(l+d>i){const y=(i-l)/d,[R,N]=this._curveHelper.getAngleCS(r,c,y),W=(0,pt.XV)(r,c,y),K=h?-this._offset:this._offset;return this.internalPlacement.setTranslate(W[0]-K*N,W[1]+K*R),this._angleToLine&&(h?this.internalPlacement.setRotateCS(-R,-N):this.internalPlacement.setRotateCS(R,N)),this.internalPlacement}l+=d}return null}}let wt=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(s,i,h,o,r){return new Ht(s,i,h)}}return f.instance=null,f})();class Ht extends pt.v1{constructor(e,s,i){super(e,!0,!0),this._curveHelper=new Q,this._angleToLine=void 0===s.angleToLine||s.angleToLine,this._offset=void 0!==s.offset?s.offset*i:0,this._endPoints=void 0===s.placeOnEndPoints||s.placeOnEndPoints,this._controlPoints=void 0===s.placeOnControlPoints||s.placeOnControlPoints,this._regularVertices=void 0===s.placeOnRegularVertices||s.placeOnRegularVertices,this._tags=[],this._tagIterator=0}processPath(e){if(this.iteratePath||(this._preparePath(e),this.iteratePath=!0),this._tagIterator>=this._tags.length)return this._tags.length=0,this._tagIterator=0,this.iteratePath=!1,null;const s=this._tags[this._tagIterator];this._angleToLine&&this.internalPlacement.setRotate(s[2]);let i=s[0],h=s[1];if(0!==this._offset){const o=Math.cos(s[2]),r=Math.sin(s[2]);i-=this._offset*r,h+=this._offset*o}return this.internalPlacement.setTranslate(i,h),this._tagIterator++,this.internalPlacement}_preparePath(e){this._tags.length=0,this._tagIterator=0;const s=(0,pt.QK)(e),i=e.length-1;let h,o,r=0,l=0,c=0,p=0,d=0;for(;r<i;){r++,h=e[r-1],o=e[r];const y=(0,pt.zv)(h),R=(0,pt.zv)(o);(this._angleToLine||0!==this._offset)&&(p=this._curveHelper.getAngle(h,o,0)),1===r?s?(l=p,c=y):(this._endPoints||this._controlPoints&&1===y)&&this._tags.push([h[0],h[1],p]):1===y?this._controlPoints&&this._tags.push([h[0],h[1],jt(d,p)]):this._regularVertices&&this._tags.push([h[0],h[1],jt(d,p)]),(this._angleToLine||0!==this._offset)&&(d=this._curveHelper.getAngle(h,o,1)),r===i&&(s?1===R||1===c?this._controlPoints&&this._tags.push([o[0],o[1],jt(d,l)]):this._regularVertices&&this._tags.push([o[0],o[1],jt(d,l)]):(this._endPoints||this._controlPoints&&1===R)&&this._tags.push([o[0],o[1],d]))}this._tagIterator=0}}function jt(f,e){const s=Math.PI;for(;Math.abs(e-f)>s+2e-15;)e-f>s?e-=2*s:e+=2*s;return(f+e)/2}var Zt=G(67087),Bt=G(78127);class ne{constructor(e=Jt){this._data=[],this._compare=e}get size(){return this._data.length}enqueue(e){if(null==e)return;const{_data:s,_compare:i}=this;s.push(e);let h=s.length-1>>>0;const o=s[h];for(;h>0;){const r=h-1>>1,l=s[r];if(!(i(l,o)<=0))break;s[r]=o,s[h]=l,h=r}}dequeue(){const{_data:e,_compare:s}=this,i=e[0],h=e.pop();if(0===e.length)return i;e[0]=h;let o=0;const r=e.length,l=e[0];let c,p,d=null;for(;;){const y=2*o+1,R=2*o+2;if(d=null,y<r&&(c=e[y],s(c,l)>0&&(d=y)),R<r&&(p=e[R],(null===d&&s(p,l)<=0||null!==d&&s(p,c)<=0)&&(d=R)),null===d)break;e[o]=e[d],e[d]=l,o=d}return i}}const Jt=(f,e)=>f<e?-1:f>e?1:0;var Qt=G(12818),$t=G(76438);function ce(f,e){const{rings:s}=e;let i=0;for(const h of s){const o=h.length;for(let r=1;r<o;++r){const l=h[r-1],c=h[r];l[1]>f[1]!=c[1]>f[1]&&((c[0]-l[0])*(f[1]-l[1])-(c[1]-l[1])*(f[0]-l[0])>0?i++:i--)}}return 0!==i}function le(f,e,s){if(s&&ce(f,e))return{coord:f,distance:0};let i=1/0,h=0,o=0;const r=[0,0],{rings:l}=e;for(const c of l)if(!(c.length<2))for(let p=0;p<c.length-1;p++){(0,Qt.Tx)(r,f,c,p);const d=pe(f,r);d<i&&(i=d,h=r[0],o=r[1])}return{coord:[h,o],distance:Math.sqrt(i)}}function me(f,e,s,i){const h=[e,0];let o=1/0,r=1/0,l=!1,c=!1;const p=[[e,i[1]-1],[e,i[3]+1]],d=[0,0],y=[0,0],R=[0,0],N=[[0,0],[0,0]],W=(0,I.Ue)(),{rings:K}=f;for(const ut of K)if(!(ut.length<2))for(let Ct=1;Ct<ut.length;Ct++){if(N[0][0]=ut[Ct-1][0],N[0][1]=ut[Ct-1][1],N[1][0]=ut[Ct][0],N[1][1]=ut[Ct][1],null===Pe(W,N)||(y[0]=p[0][0],y[1]=p[0][1],R[0]=p[1][0],R[1]=p[1][1],0===se(W,y,R))||!(0,$t.UT)(p[0],p[1],N[0],N[1],d))continue;const Ut=d[1];o>r?Ut<o&&(o=Ut,l=!0):Ut<r&&(r=Ut,c=!0)}return l&&c?h[1]=(o+r)/2:h[0]=h[1]=NaN,h}function Pe(f,e){if(e.length<2)return null;f||(f=(0,I.Ue)());const[s,i]=e[0],[h,o]=e[1];return f[0]=Math.min(s,h),f[1]=Math.min(i,o),f[2]=Math.max(s,h),f[3]=Math.max(i,o),f}const _e=1,ue=4,ge=3,Me=12;function se(f,e,s){let i=te(e,f),h=te(s,f);const o=f[0],r=f[1],l=f[2],c=f[3];if(i&h)return 0;if(!(i|h))return 4;const p=(i?1:0)|(h?2:0);do{const d=s[0]-e[0],y=s[1]-e[1];if(d>y)i&ge?(i&_e?(e[1]+=y*(o-e[0])/d,e[0]=o):(e[1]+=y*(l-e[0])/d,e[0]=l),i=te(e,f)):h&ge?(h&_e?(s[1]+=y*(o-s[0])/d,s[0]=o):(s[1]+=y*(l-s[0])/d,s[0]=l),h=te(s,f)):i?(i&ue?(e[0]+=d*(r-e[1])/y,e[1]=r):(e[0]+=d*(c-e[1])/y,e[1]=c),i=te(e,f)):(h&ue?(s[0]+=d*(r-s[1])/y,s[1]=r):(s[0]+=d*(c-s[1])/y,s[1]=c),h=te(s,f));else if(i&Me?(i&ue?(e[0]+=d*(r-e[1])/y,e[1]=r):(e[0]+=d*(c-e[1])/y,e[1]=c),i=te(e,f)):h&Me?(h&ue?(s[0]+=d*(r-s[1])/y,s[1]=r):(s[0]+=d*(c-s[1])/y,s[1]=c),h=te(s,f)):i?(i&_e?(e[1]+=y*(o-e[0])/d,e[0]=o):(e[1]+=y*(l-e[0])/d,e[0]=l),i=te(e,f)):(h&_e?(s[1]+=y*(o-s[0])/d,s[0]=o):(s[1]+=y*(l-s[0])/d,s[0]=l),h=te(s,f)),i&h)return 0}while(i|h);return p}function te(f,e){return(f[0]<e[0]?1:0)|(f[0]>e[2]?1:0)<<1|(f[1]<e[1]?1:0)<<2|(f[1]>e[3]?1:0)<<3}function ie(f,e,s){return f+(e-f)*s}function pe(f,e){return(f[0]-e[0])*(f[0]-e[0])+(f[1]-e[1])*(f[1]-e[1])}function ye(f,e){if(f<e)return-1;if(f>e)return 1;if(f===e)return 0;const s=isNaN(f),i=isNaN(e);return s<i?-1:s>i?1:0}class fe{constructor(e,s,i,h){this.x=e,this.y=s,this.cellSize=i,this.distancefromCellCenter=(0,Qt.ko)(e,s,h),this.maxDistanceToPolygon=this.distancefromCellCenter+this.cellSize*Math.SQRT2}}let Ie=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(s,i,h,o,r){return new ke(s,i,h)}}return f.instance=null,f})();class ke{constructor(e,s,i){this._geometry=e,this._offsetX=void 0!==s.offsetX?s.offsetX*i:0,this._offsetY=void 0!==s.offsetY?s.offsetY*i:0,this._method=void 0!==s.method?s.method:L.Lh.OnPolygon,this._internalPlacement=new m.u}next(){const e=this._geometry;return this._geometry=null,e&&function we(f){return void 0!==f.rings}(e)?this._polygonCenter(e):null}_polygonCenter(e){let s=!1;switch(this._method){case L.Lh.CenterOfMass:{const i=(0,Bt.NA)(e);i&&(this._internalPlacement.setTranslate(i[0]+this._offsetX,i[1]+this._offsetY),s=!0)}break;case L.Lh.BoundingBoxCenter:{const i=(0,I.Ue)();(0,b.$P)(i,e),i&&(this._internalPlacement.setTranslate((i[2]+i[0])/2+this._offsetX,(i[3]+i[1])/2+this._offsetY),s=!0)}break;default:{let i;i=(0,Zt.Z)("polylabel-placement-enabled")?function ve(f){if(!f||!f.rings||0===f.rings.length)return null;const e=(0,b.lC)((0,I.Ue)(),f.rings[0]);if(!e)return null;const s=e[2]-e[0],i=e[3]-e[1];if(0===s||0===i)return[e[0]+s/2,e[1]+i/2];const h=Math.max(Math.min(s,i)/100,1),o=new ne((N,W)=>W.maxDistanceToPolygon-N.maxDistanceToPolygon),r=Math.min(s,i);let l=r/2,c=0,p=0;for(c=e[0];c<e[2];c+=r)for(p=e[1];p<e[3];p+=r)o.enqueue(new fe(c+l,p+l,l,f));const d=(0,Bt.a)(f.rings,!1);if(null===d)return null;let y,R=new fe(d[0],d[1],0,f);for(;o.size>0;)y=(0,ht.Wg)(o.dequeue()),y.distancefromCellCenter>R.distancefromCellCenter&&(R=y),y.maxDistanceToPolygon-R.distancefromCellCenter<=h||(l=y.cellSize/2,o.enqueue(new fe(y.x-l,y.y-l,l,f)),o.enqueue(new fe(y.x+l,y.y-l,l,f)),o.enqueue(new fe(y.x-l,y.y+l,l,f)),o.enqueue(new fe(y.x+l,y.y+l,l,f)));return[R.x,R.y]}(e):function ee(f){const{rings:e}=f;if(!e||0===e.length)return null;const s=(0,b.$P)((0,I.Ue)(),f);if(!s)return null;const i=4*(Math.abs(s[0])+Math.abs(s[2])+Math.abs(s[1])+Math.abs(s[3])+1)*222045e-19;let h=0,o=0;for(let Kt=0;Kt<e.length;Kt++){const he=(0,Qt.Sm)(e[Kt]);he>o&&(o=he,h=Kt)}if(Math.abs(o)<=2*i*i){const Kt=(0,b.lC)((0,I.Ue)(),e[h]);return[(Kt[0]+Kt[2])/2,(Kt[1]+Kt[3])/2]}const r=(0,Bt.DS)(e[h],!1,(0,I.Ue)());if(null===r)return null;if(1===e.length&&e[0].length<4)return r;const l=[[NaN,NaN],[NaN,NaN],[NaN,NaN],[NaN,NaN]],c=[NaN,NaN,NaN,NaN],p=[NaN,NaN,NaN,NaN];let d=!1,y=le(r,f,!0);0===y.distance&&(d=!0,l[0][0]=r[0],l[0][1]=r[1],y=le(r,f,!1)),c[0]=y.distance,p[0]=0;const R=[NaN,NaN];let N=!1,W=.25,K=-1;const ut=(0,b.lC)((0,I.Ue)(),e[h]);let Ct=NaN;do{if(Ct=NaN,l[1]=me(f,ie(ut[0],ut[2],W),0,s),isNaN(l[1][0])||isNaN(l[1][1])||(y=le(l[1],f,!1),Ct=y.distance),!isNaN(Ct)&&Ct>i&&ce(l[1],f))N=!0,c[1]=Ct,p[1]=pe(l[1],r);else if(!isNaN(Ct)&&Ct>K&&(K=Ct,R[0]=l[1][0],R[1]=l[1][1]),W-=.01,W<.1){if(!(K>=0))break;N=!0,c[1]=K,l[1][0]=R[0],l[1][1]=R[1],p[1]=pe(l[1],r)}}while(!N);N=!1,W=.5,K=-1;let Ut=.01,Ft=1;do{if(Ct=NaN,l[2]=me(f,ie(ut[0],ut[2],W),0,s),isNaN(l[2][0])||isNaN(l[2][1])||(y=le(l[2],f,!1),Ct=y.distance),!isNaN(Ct)&&Ct>i&&ce(l[2],f))N=!0,c[2]=Ct,p[2]=pe(l[2],r);else if(!isNaN(Ct)&&Ct>K)K=Ct,R[0]=l[2][0],R[1]=l[2][1];else if(Ct>K&&(K=Ct,R[0]=l[2][0],R[1]=l[2][1]),W=.5+Ut*Ft,Ut+=.01,Ft*=-1,W<.3||W>.7){if(!(K>=0))break;N=!0,c[2]=K,l[2][0]=R[0],l[2][1]=R[1],p[2]=pe(l[2],r)}}while(!N);N=!1,W=.75,K=-1;do{if(Ct=NaN,l[3]=me(f,ie(ut[0],ut[2],W),0,s),isNaN(l[3][0])||isNaN(l[3][1])||(y=le(l[3],f,!1),Ct=y.distance),!isNaN(Ct)&&Ct>i&&ce(l[3],f))N=!0,c[3]=Ct,p[3]=pe(l[3],r);else if(Ct>K&&(K=Ct,R[0]=l[3][0],R[1]=l[3][1]),W+=.01,W>.9){if(!(K>=0))break;N=!0,c[3]=K,l[3][0]=R[0],l[3][1]=R[1],p[3]=pe(l[3],r)}}while(!N);const xt=[0,1,2,3],qt=d?0:1;let Vt;for(let Kt=qt;Kt<4;Kt++)for(let he=qt;he<3;he++){const be=p[he],Ce=p[he+1];ye(be,Ce)>0&&(Vt=xt[he],xt[he]=xt[he+1],xt[he+1]=Vt,p[he]=Ce,p[he+1]=be)}let oe=qt,xe=0,de=0;for(let Kt=qt;Kt<4;Kt++){switch(Kt){case 0:de=2*c[xt[Kt]];break;case 1:de=1.66666666*c[xt[Kt]];break;case 2:de=1.33333333*c[xt[Kt]];break;case 3:de=c[xt[Kt]]}de>xe&&(xe=de,oe=xt[Kt])}return l[oe]}(e),null!==i&&(this._internalPlacement.setTranslate(i[0]+this._offsetX,i[1]+this._offsetY),s=!0)}}return s?this._internalPlacement:null}}function Ee(f){if(!f)return null;switch(f.type){case"CIMGeometricEffectAddControlPoints":return mt.local();case"CIMGeometricEffectArrow":return gt.local();case"CIMGeometricEffectBuffer":return vt.local();case"CIMGeometricEffectControlMeasureLine":return It.local();case"CIMGeometricEffectCut":return D.local();case"CIMGeometricEffectDashes":return q.local();case"CIMGeometricEffectDonut":return Z.local();case"CIMGeometricEffectJog":return dt.local();case"CIMGeometricEffectMove":return kt.local();case"CIMGeometricEffectOffset":return Xt.local();case"CIMGeometricEffectReverse":return a.local();case"CIMGeometricEffectRotate":return k.local();case"CIMGeometricEffectScale":return x.local();case"CIMGeometricEffectWave":return Pt.local()}return null}function Le(f){if(!f)return null;switch(f.type){case"CIMMarkerPlacementAlongLineSameSize":return u.local();case"CIMMarkerPlacementAtExtremities":return C.local();case"CIMMarkerPlacementAtRatioPositions":return S.local();case"CIMMarkerPlacementInsidePolygon":return Y.local();case"CIMMarkerPlacementOnLine":return Lt.local();case"CIMMarkerPlacementOnVertices":return wt.local();case"CIMMarkerPlacementPolygonCenter":return Ie.local()}return null}},46806:(ae,Wt,G)=>{G.d(Wt,{u:()=>At});class At{constructor(){this.setIdentity()}getAngle(){return(null==this.rz||0===this.rz&&1!==this.rzCos&&0!==this.rzSin)&&(this.rz=Math.atan2(this.rzSin,this.rzCos)),this.rz}setIdentity(){this.tx=0,this.ty=0,this.tz=0,this.s=1,this.rx=0,this.ry=0,this.rz=0,this.rzCos=1,this.rzSin=0}setTranslate(mt,Ot){this.tx=mt,this.ty=Ot}setTranslateZ(mt){this.tz=mt}setRotateCS(mt,Ot){this.rz=void 0,this.rzCos=mt,this.rzSin=Ot}setRotate(mt){this.rz=mt,this.rzCos=void 0,this.rzSin=void 0}setRotateY(mt){this.ry=mt}setScale(mt){this.s=mt}setMeasure(mt){this.m=mt}}},14862:(ae,Wt,G)=>{G.d(Wt,{cD:()=>q,uQ:()=>_t,Tu:()=>B,zA:()=>yt,x1:()=>rt,et:()=>Nt,g:()=>dt});var At=G(65489),nt=G(36416),pt=G(88684),mt=G(28191),Ot=G(53661),L=G(5261),at=G(55798),V=G(6848),Q=G(71949),tt=G(78127),H=G(71182),ft=G(23975);class gt{applyColorSubstituition(a,_){if(!_)return a;this._rasterizationCanvas||(this._rasterizationCanvas=document.createElement("canvas"));const{width:I,height:b}=a,k=this._rasterizationCanvas,F=k.getContext("2d");a!==k&&(k.width=I,k.height=b,F.drawImage(a,0,0,I,b));const x=F.getImageData(0,0,I,b).data;if(_)for(const Pt of _)if(Pt&&Pt.oldColor&&4===Pt.oldColor.length&&Pt.newColor&&4===Pt.newColor.length){const[z,u,g,C]=Pt.oldColor,[w,S,n,P]=Pt.newColor;if(z===w&&u===S&&g===n&&C===P)continue;for(let m=0;m<x.length;m+=4)z===x[m]&&u===x[m+1]&&g===x[m+2]&&C===x[m+3]&&(x[m]=w,x[m+1]=S,x[m+2]=n,x[m+3]=P)}const et=new ImageData(x,I,b);return F.putImageData(et,0,0),k}tintImageData(a,_){if(!_||_.length<4)return a;this._rasterizationCanvas||(this._rasterizationCanvas=document.createElement("canvas"));const{width:I,height:b}=a,k=this._rasterizationCanvas,F=k.getContext("2d");a!==k&&(k.width=I,k.height=b,F.drawImage(a,0,0,I,b));const x=F.getImageData(0,0,I,b),et=new Uint8Array(x.data),Pt=[_[0]/255,_[1]/255,_[2]/255,_[3]/255];for(let u=0;u<et.length;u+=4)et[u+0]*=Pt[0],et[u+1]*=Pt[1],et[u+2]*=Pt[2],et[u+3]*=Pt[3];const z=new ImageData(new Uint8ClampedArray(et.buffer),I,b);return F.putImageData(z,0,0),k}}var E=G(5780),O=G(46806),ht=G(20877);function A(lt){const a=lt.getFrame(0);if(a instanceof HTMLImageElement||a instanceof HTMLCanvasElement)return a;const _=document.createElement("canvas");_.width=lt.width,_.height=lt.height;const I=_.getContext("2d");return a instanceof ImageData?I.putImageData(a,0,0):I.drawImage(a,0,0),_}var St=G(61164),vt=G(42353),bt=G(2047),It=G(81925),Rt=G(80696),D=G(18659);const it=Math.PI/180,zt=mt.Z.getLogger("esri.symbols.cim.CIMSymbolDrawHelper");class yt{constructor(a){this._t=a}static createIdentity(){return new yt([1,0,0,0,1,0])}clone(){return new yt(this._t.slice())}transform(a){const _=this._t;return[_[0]*a[0]+_[1]*a[1]+_[2],_[3]*a[0]+_[4]*a[1]+_[5]]}static createScale(a,_){return new yt([a,0,0,0,_,0])}scale(a,_){const I=this._t;return I[0]*=a,I[1]*=a,I[2]*=a,I[3]*=_,I[4]*=_,I[5]*=_,this}scaleRatio(){return Math.sqrt(this._t[0]*this._t[0]+this._t[1]*this._t[1])}static createTranslate(a,_){return new yt([0,0,a,0,0,_])}translate(a,_){const I=this._t;return I[2]+=a,I[5]+=_,this}static createRotate(a){const _=Math.cos(a),I=Math.sin(a);return new yt([_,-I,0,I,_,0])}rotate(a){return yt.multiply(this,yt.createRotate(a),this)}angle(){const a=this._t[0],_=this._t[3],I=Math.sqrt(a*a+_*_);return[a/I,_/I]}static multiply(a,_,I){const b=a._t,k=_._t,x=b[1]*k[0]+b[4]*k[1],et=b[2]*k[0]+b[5]*k[1]+k[2],Pt=b[0]*k[3]+b[3]*k[4],z=b[1]*k[3]+b[4]*k[4],u=b[2]*k[3]+b[5]*k[4]+k[5],g=I._t;return g[0]=b[0]*k[0]+b[3]*k[1],g[1]=x,g[2]=et,g[3]=Pt,g[4]=z,g[5]=u,I}invert(){const a=this._t;let _=a[0]*a[4]-a[1]*a[3];return 0===_?new yt([0,0,0,0,0,0]):(_=1/_,new yt([a[4]*_,-a[1]*_,(a[1]*a[5]-a[2]*a[4])*_,-a[3]*_,a[0]*_,(a[2]*a[3]-a[0]*a[5])*_]))}}class Tt{constructor(a,_){this._resourceManager=a,this._transfos=[],this._sizeTransfos=[],this._geomUnitsPerPoint=1,this._placementPool=new L.Z(O.u,void 0,void 0,100),this._earlyReturn=!1,this._mapRotation=0,this._transfos.push(_||yt.createIdentity()),this._sizeTransfos.push(_?_.scaleRatio():1)}setTransform(a,_){this._transfos=[a||yt.createIdentity()],this._sizeTransfos=[_||(a?a.scaleRatio():1)]}setGeomUnitsPerPoint(a){this._geomUnitsPerPoint=a}transformPt(a){return this._transfos[this._transfos.length-1].transform(a)}transformSize(a){return a*this._sizeTransfos[this._sizeTransfos.length-1]}reverseTransformPt(a){return this._transfos[this._transfos.length-1].invert().transform(a)}reverseTransformSize(a){return a/this._sizeTransfos[this._sizeTransfos.length-1]}getTransformAngle(){return this._transfos[this._transfos.length-1].angle()}geomUnitsPerPoint(){return this.isEmbedded()?1:this._geomUnitsPerPoint}isEmbedded(){return this._transfos.length>1}back(){return this._transfos[this._transfos.length-1]}push(a,_){const I=_?a.scaleRatio():1;yt.multiply(a,this.back(),a),this._transfos.push(a),this._sizeTransfos.push(this._sizeTransfos[this._sizeTransfos.length-1]*I)}pop(){this._transfos.splice(-1,1),this._sizeTransfos.splice(-1,1)}drawSymbol(a,_,I){if(a)switch(a.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":this.drawMultiLayerSymbol(a,_);break;case"CIMTextSymbol":this.drawTextSymbol(a,_,I)}}drawMultiLayerSymbol(a,_){if(!a||!_)return;const I=a.symbolLayers;if(!I)return;const b=a.effects;if(b&&b.length>0){const k=this.executeEffects(b,_);if(k){let F=k.next();for(;F;)this.drawSymbolLayers(I,F),F=k.next()}}else this.drawSymbolLayers(I,_)}executeEffects(a,_){const I=this._resourceManager.geometryEngine;let b=new ft.MU(_);for(const k of a){const F=(0,E.h)(k);F&&(b=F.execute(b,k,this.geomUnitsPerPoint(),null,I))}return b}drawSymbolLayers(a,_){let I=a.length;for(;I--;){const b=a[I];if(!b||!1===b.enable)continue;const k=b.effects;if(k&&k.length>0){const F=this.executeEffects(k,_);if(F){let x=null;for(;(x=F.next())&&(this.drawSymbolLayer(b,x),!this._earlyReturn););}}else this.drawSymbolLayer(b,_);if(this._earlyReturn)return}}drawSymbolLayer(a,_){switch(a.type){case"CIMSolidFill":this.drawSolidFill(_,a.color);break;case"CIMHatchFill":this.drawHatchFill(_,a);break;case"CIMPictureFill":this.drawPictureFill(_,a);break;case"CIMGradientFill":this.drawGradientFill(_,a);break;case"CIMSolidStroke":this.drawSolidStroke(_,a.color,a.width,a.capStyle,a.joinStyle,a.miterLimit);break;case"CIMPictureStroke":this.drawPictureStroke(_,a);break;case"CIMGradientStroke":this.drawGradientStroke(_,a);break;case"CIMCharacterMarker":case"CIMPictureMarker":case"CIMVectorMarker":this.drawMarkerLayer(a,_)}}drawHatchFill(a,_){const I=this._buildHatchPolyline(_,a,this.geomUnitsPerPoint());I&&(this.pushClipPath(a),this.drawMultiLayerSymbol(_.lineSymbol,I),this.popClipPath())}drawPictureFill(a,_){}drawGradientFill(a,_){}drawPictureStroke(a,_){}drawGradientStroke(a,_){}drawMarkerLayer(a,_){const I=a.markerPlacement;if(I){const b=(0,E.W)(I);if(b){const k="CIMMarkerPlacementInsidePolygon"===I.type||"CIMMarkerPlacementPolygonCenter"===I.type&&I.clipAtBoundary;k&&this.pushClipPath(_);const F=b.execute(_,I,this.geomUnitsPerPoint(),null,this._resourceManager.geometryEngine);if(F){let x=null;for(;(x=F.next())&&(this.drawMarker(a,x),!this._earlyReturn););}k&&this.popClipPath()}}else{const b=this._placementPool.acquire();if((0,H.wp)(_))b.tx=_.x,b.ty=_.y,this.drawMarker(a,b);else if((0,H.oU)(_)){const k=(0,tt.tO)(_);k&&([b.tx,b.ty]=k,this.drawMarker(a,b))}else for(const k of _.points)if(b.tx=k[0],b.ty=k[1],this.drawMarker(a,b),this._earlyReturn)break;this._placementPool.release(b)}}drawMarker(a,_){switch(a.type){case"CIMCharacterMarker":case"CIMPictureMarker":this.drawPictureMarker(a,_);break;case"CIMVectorMarker":this.drawVectorMarker(a,_)}}drawPictureMarker(a,_){if(!a)return;const I=this._resourceManager.getResource(a.url),b=a.size??10;if((0,Ot.Wi)(I)||b<=0)return;const k=I.width,F=I.height;if(!k||!F)return;const x=k/F,et=a.scaleX??1,Pt=yt.createIdentity(),z=a.anchorPoint;if(z){let n=z.x,P=z.y;"Absolute"!==a.anchorPointUnits&&(n*=b*x*et,P*=b),Pt.translate(-n,-P)}let u=a.rotation??0;a.rotateClockwise&&(u=-u),this._mapRotation&&(u+=this._mapRotation),u&&Pt.rotate(u*it);let g=a.offsetX??0,C=a.offsetY??0;if(g||C){if(this._mapRotation){const n=it*this._mapRotation,P=Math.cos(n),m=Math.sin(n),v=g*m+C*P;g=g*P-C*m,C=v}Pt.translate(g,C)}const w=this.geomUnitsPerPoint();1!==w&&Pt.scale(w,w);const S=_.getAngle();S&&Pt.rotate(S),Pt.translate(_.tx,_.ty),this.push(Pt,!1),this.drawImage(a,b),this.pop()}drawVectorMarker(a,_){if(!a)return;const I=a.markerGraphics;if(!I)return;const b=a.size??10,k=a.frame,F=k?k.ymax-k.ymin:0,x=b&&F?b/F:1,et=yt.createIdentity();k&&et.translate(.5*-(k.xmax+k.xmin),.5*-(k.ymax+k.ymin));const Pt=a.anchorPoint;if(Pt){let S=Pt.x,n=Pt.y;"Absolute"!==a.anchorPointUnits?k&&(S*=k.xmax-k.xmin,n*=k.ymax-k.ymin):(S/=x,n/=x),et.translate(-S,-n)}1!==x&&et.scale(x,x);let z=a.rotation??0;a.rotateClockwise&&(z=-z),this._mapRotation&&(z+=this._mapRotation),z&&et.rotate(z*it);let u=a.offsetX??0,g=a.offsetY??0;if(u||g){if(this._mapRotation){const S=it*this._mapRotation,n=Math.cos(S),P=Math.sin(S),m=u*P+g*n;u=u*n-g*P,g=m}et.translate(u,g)}const C=this.geomUnitsPerPoint();1!==C&&et.scale(C,C);const w=_.getAngle();w&&et.rotate(w),et.translate(_.tx,_.ty),this.push(et,a.scaleSymbolsProportionally);for(const S of I)if(S&&S.symbol&&S.geometry||zt.error("Invalid marker graphic",S),this.drawSymbol(S.symbol,S.geometry,S.textString),this._earlyReturn)break;this.pop()}drawTextSymbol(a,_,I){if(!a||!(0,H.wp)(_)||(a.height??10)<=0)return;const b=yt.createIdentity();let k=a.angle??0;k=-k,k&&b.rotate(k*it);const F=a.offsetX??0,x=a.offsetY??0;(F||x)&&b.translate(F,x);const et=this.geomUnitsPerPoint();1!==et&&b.scale(et,et),b.translate(_.x,_.y),this.push(b,!1),this.drawText(a,I),this.pop()}_buildHatchPolyline(a,_,I){let b=(void 0!==a.separation?a.separation:4)*I,k=void 0!==a.rotation?a.rotation:0;if(0===b)return null;b<0&&(b=-b);let F=0;const x=.5*b;for(;F>x;)F-=b;for(;F<-x;)F+=b;const et=(0,V.Ue)();(0,Q.$P)(et,_),et[0]-=x,et[1]-=x,et[2]+=x,et[3]+=x;const Pt=[[et[0],et[1]],[et[0],et[3]],[et[2],et[3]],[et[2],et[1]]];for(;k>180;)k-=180;for(;k<0;)k+=180;const z=Math.cos(k*it),u=Math.sin(k*it),g=-b*u,C=b*z;let w,S,n,P;F=(void 0!==a.offsetX?a.offsetX*I:0)*u-(void 0!==a.offsetY?a.offsetY*I:0)*z,w=n=Number.MAX_VALUE,S=P=-Number.MAX_VALUE;for(const T of Pt){const Y=T[0],$=T[1],ot=z*Y+u*$,st=-u*Y+z*$;w=Math.min(w,ot),n=Math.min(n,st),S=Math.max(S,ot),P=Math.max(P,st)}n=Math.floor(n/b)*b;let m=z*w-u*n-g*F/b,v=u*w+z*n-C*F/b,M=z*S-u*n-g*F/b,U=u*S+z*n-C*F/b;const J=1+Math.round((P-n)/b),X=[];for(let T=0;T<J;T++)m+=g,v+=C,M+=g,U+=C,X.push([[m,v],[M,U]]);return{paths:X}}}class _t extends Tt{constructor(a,_){super(a,_),this.reset()}reset(){this._xmin=this._ymin=1/0,this._xmax=this._ymax=-1/0,this._clipCount=0}envelope(){return new St.Z(this._xmin,this._ymin,this._xmax-this._xmin,this._ymax-this._ymin)}bounds(){return(0,V.al)(this._xmin,this._ymin,this._xmax,this._ymax)}drawSolidFill(a){if(a&&!(this._clipCount>0))if((0,H.oU)(a))this._processPath(a.rings,0);else if((0,H.l9)(a))this._processPath(a.paths,0);else if((0,H.YX)(a)){const _=Z(a);_&&this._processPath(_.rings,0)}else console.error("drawSolidFill Unexpected geometry type!")}drawSolidStroke(a,_,I){if(!a||this._clipCount>0)return;const b=.5*this.transformSize(I??0);if((0,H.oU)(a))this._processPath(a.rings,b);else if((0,H.l9)(a))this._processPath(a.paths,b);else if((0,H.YX)(a)){const k=Z(a);k&&this._processPath(k.rings,b)}else console.error("drawSolidStroke unexpected geometry type!")}drawMarkerLayer(a,_){(0,H.oU)(_)&&a.markerPlacement&&("CIMMarkerPlacementInsidePolygon"===a.markerPlacement.type||"CIMMarkerPlacementPolygonCenter"===a.markerPlacement.type&&a.markerPlacement.clipAtBoundary)?this._processPath(_.rings,0):super.drawMarkerLayer(a,_)}drawHatchFill(a,_){this.drawSolidFill(a)}drawPictureFill(a,_){this.drawSolidFill(a)}drawGradientFill(a,_){this.drawSolidFill(a)}drawPictureStroke(a,_){this.drawSolidStroke(a,null,_.width)}drawGradientStroke(a,_){this.drawSolidStroke(a,null,_.width)}pushClipPath(a){this.drawSolidFill(a),this._clipCount++}popClipPath(){this._clipCount--}drawImage(a,_){const{url:I}=a,b=a.scaleX??1;let k=b*_,F=_;const x=this._resourceManager.getResource(I);!_&&(0,Ot.pC)(x)&&(k=b*x.width,F=x.height),this._merge(this.transformPt([-k/2,-F/2]),0),this._merge(this.transformPt([-k/2,F/2]),0),this._merge(this.transformPt([k/2,-F/2]),0),this._merge(this.transformPt([k/2,F/2]),0)}drawText(a,_){if(!_||0===_.length)return;this._textRasterizer||(this._textRasterizer=new vt.Z);const I=kt(a),[b,k]=this._textRasterizer.computeTextSize(_,I);let F=0;switch(a.horizontalAlignment){case"Left":F=b/2;break;case"Right":F=-b/2}let x=0;switch(a.verticalAlignment){case"Bottom":x=k/2;break;case"Top":x=-k/2;break;case"Baseline":x=k/6}this._merge(this.transformPt([-b/2+F,-k/2+x]),0),this._merge(this.transformPt([-b/2+F,k/2+x]),0),this._merge(this.transformPt([b/2+F,-k/2+x]),0),this._merge(this.transformPt([b/2+F,k/2+x]),0)}_processPath(a,_){if(a)for(const I of a){const b=I?I.length:0;if(b>1){this._merge(this.transformPt(I[0]),_);for(let k=1;k<b;k++)this._merge(this.transformPt(I[k]),_)}}}_merge(a,_){a[0]-_<this._xmin&&(this._xmin=a[0]-_),a[0]+_>this._xmax&&(this._xmax=a[0]+_),a[1]-_<this._ymin&&(this._ymin=a[1]-_),a[1]+_>this._ymax&&(this._ymax=a[1]+_)}}class B extends Tt{constructor(){super(...arguments),this._searchPoint=[0,0],this._searchDistPoint=0,this._textInfo=null}hitTest(a,_,I,b,k,F){const x=F*(0,at.F2)(1);return this.setTransform(),this.setGeomUnitsPerPoint(x),this._searchPoint=[(a[0]+a[2])/2,(a[1]+a[3])/2],this._searchDistPoint=(a[2]-a[0])/2/x,this._textInfo=b,this._mapRotation=_&&("CIMPointSymbol"===_.type&&"Map"!==_.angleAlignment||"CIMTextSymbol"===_.type)?k:0,this._earlyReturn=!1,this.drawSymbol(_,I),this._earlyReturn}drawSolidFill(a,_){this._hitTestFill(a)}drawHatchFill(a,_){this._hitTestFill(a)}drawPictureFill(a,_){this._hitTestFill(a)}drawGradientFill(a,_){this._hitTestFill(a)}drawSolidStroke(a,_,I,b,k,F){this._hitTestStroke(a,I)}drawPictureStroke(a,_){this._hitTestStroke(a,_.width)}drawGradientStroke(a,_){this._hitTestStroke(a,_.width)}drawMarkerLayer(a,_){a.markerPlacement&&("CIMMarkerPlacementInsidePolygon"===a.markerPlacement.type||"CIMMarkerPlacementPolygonCenter"===a.markerPlacement.type&&a.markerPlacement.clipAtBoundary)?this._hitTestFill(_):super.drawMarkerLayer(a,_)}pushClipPath(a){}popClipPath(){}drawImage(a,_){const{url:I}=a,b=a.scaleX??1,k=this._resourceManager.getResource(I);if((0,Ot.Wi)(k)||0===k.height||0===_)return;const F=_*this.geomUnitsPerPoint(),x=F*b*(k.width/k.height),et=this.reverseTransformPt(this._searchPoint),Pt=this._searchDistPoint;Math.abs(et[0])<x/2+Pt&&Math.abs(et[1])<F/2+Pt&&(this._earlyReturn=!0)}drawText(a,_){const I=this._textInfo;if(!I)return;const b=I.get(a);if(!b)return;const{text:k,mosaicItem:F}=b;if(!F?.glyphMosaicItems?.length)return;const x=a.height??10,{lineGapType:et,lineGap:Pt}=a,z=et?Nt(et,Pt??0,x):0,u=(0,At.E)(k)[1],g=F.glyphMosaicItems,C="CIMBackgroundCallout"===a.callout?.type,w=(0,D.Nr)(g,u,{scale:x/Rt.Ex,angle:0,xOffset:0,yOffset:0,hAlign:rt(a.horizontalAlignment),vAlign:dt(a.verticalAlignment),maxLineWidth:512,lineHeight:Rt.xm*Math.max(.25,Math.min(z||1,4)),decoration:a.font.decoration||"none",isCIM:!0,hasBackground:C}),S=this.reverseTransformPt(this._searchPoint),n=S[0],P=S[1];for(const m of w.glyphs)if(n>m.xTopLeft&&n<m.xBottomRight&&P>-m.yBottomRight&&P<-m.yTopLeft){this._earlyReturn=!0;break}}_hitTestFill(a){let _=null;if((0,H.YX)(a))_=[[[a.xmin,a.ymin],[a.xmin,a.ymax],[a.xmax,a.ymax],[a.xmax,a.ymin],[a.xmin,a.ymin]]];else if((0,H.oU)(a))_=a.rings;else{if(!(0,H.l9)(a))return;_=a.paths}const I=this.reverseTransformPt(this._searchPoint);if(this._pointInPolygon(I,_)&&(this._earlyReturn=!0),!this._earlyReturn){const b=this.reverseTransformSize(this._searchDistPoint)*this.geomUnitsPerPoint();this._nearLine(I,_,b)&&(this._earlyReturn=!0)}}_hitTestStroke(a,_){let I=null;if((0,H.YX)(a))I=[[[a.xmin,a.ymin],[a.xmin,a.ymax],[a.xmax,a.ymax],[a.xmax,a.ymin],[a.xmin,a.ymin]]];else if((0,H.oU)(a))I=a.rings;else{if(!(0,H.l9)(a))return;I=a.paths}const b=this.reverseTransformPt(this._searchPoint),k=(_??0)*this.geomUnitsPerPoint(),F=this.reverseTransformSize(this._searchDistPoint)*this.geomUnitsPerPoint();this._nearLine(b,I,k/2+F)&&(this._earlyReturn=!0)}_pointInPolygon(a,_){let I=0;for(const b of _){const k=b.length;for(let F=1;F<k;F++){const x=b[F-1],et=b[F];x[1]>a[1]!=et[1]>a[1]&&((et[0]-x[0])*(a[1]-x[1])-(et[1]-x[1])*(a[0]-x[0])>0?I++:I--)}}return 0!==I}_nearLine(a,_,I){for(const b of _){const k=b.length;for(let F=1;F<k;F++){const x=b[F-1],et=b[F];let Pt=(et[0]-x[0])*(et[0]-x[0])+(et[1]-x[1])*(et[1]-x[1]);if(0!==Pt&&(Pt=Math.sqrt(Pt),Math.abs(((et[0]-x[0])*(a[1]-x[1])-(et[1]-x[1])*(a[0]-x[0]))/Pt)<I)){const u=((et[0]-x[0])*(a[0]-x[0])+(et[1]-x[1])*(a[1]-x[1]))/Pt;if(u>-I&&u<Pt+I)return!0}}}return!1}}class q extends Tt{constructor(a,_,I,b){super(_,I),this._applyAdditionalRenderProps=b,this._colorSubstitutionHelper=new gt,this._ctx=a}drawSolidFill(a,_){if(!a)return;if((0,H.oU)(a))this._buildPath(a.rings,!0);else if((0,H.l9)(a))this._buildPath(a.paths,!0);else if((0,H.YX)(a))this._buildPath(Z(a).rings,!0);else{if(!(0,H.aW)(a))return;console.log("CanvasDrawHelper.drawSolidFill - No implementation!")}const I=this._ctx;I.fillStyle="string"==typeof _?_:"rgba("+Math.round(_[0])+","+Math.round(_[1])+","+Math.round(_[2])+","+(_[3]??255)/255+")",I.fill("evenodd")}drawSolidStroke(a,_,I,b,k,F){if(!a||!_||0===I)return;if((0,H.oU)(a))this._buildPath(a.rings,!0);else if((0,H.l9)(a))this._buildPath(a.paths,!1);else{if(!(0,H.YX)(a))return void console.log("CanvasDrawHelper.drawSolidStroke isn't implemented!");this._buildPath(Z(a).rings,!0)}const x=this._ctx;x.strokeStyle="string"==typeof _?_:"rgba("+Math.round(_[0])+","+Math.round(_[1])+","+Math.round(_[2])+","+(_[3]??255)/255+")",x.lineWidth=Math.max(this.transformSize(I),.5),this._setCapStyle(b),this._setJoinStyle(k),x.miterLimit=F,x.stroke()}pushClipPath(a){if(this._ctx.save(),(0,H.oU)(a))this._buildPath(a.rings,!0);else if((0,H.l9)(a))this._buildPath(a.paths,!0);else{if(!(0,H.YX)(a))return;this._buildPath(Z(a).rings,!0)}this._ctx.clip("evenodd")}popClipPath(){this._ctx.restore()}drawImage(a,_){const{colorSubstitutions:I,url:b,tintColor:k}=a,F=a.scaleX??1,x=this._resourceManager.getResource(b);if((0,Ot.Wi)(x))return;let et=_*(x.width/x.height),Pt=_;_||(et=x.width,Pt=x.height);const z=(0,bt.TB)(b)||"src"in x&&(0,bt.TB)(x.src);let u="getFrame"in x?A(x):x;I&&(u=this._colorSubstitutionHelper.applyColorSubstituition(u,I)),this._applyAdditionalRenderProps&&!z&&k&&(u=this._colorSubstitutionHelper.tintImageData(u,k));const g=this.transformPt([0,0]),[C,w]=this.getTransformAngle(),S=this.transformSize(1),n=this._ctx;n.save(),n.setTransform({m11:F*S*C,m12:F*S*w,m21:-S*w,m22:S*C,m41:g[0],m42:g[1]}),n.drawImage(u,-et/2,-Pt/2,et,Pt),n.restore()}drawText(a,_){if(!_||0===_.length)return;this._textRasterizer||(this._textRasterizer=new vt.Z);const I=kt(a);I.size*=this.transformSize((0,at.Wz)(1));const b=this._textRasterizer.rasterizeText(_,I);if(!b)return;const{size:k,anchorX:F,anchorY:x,canvas:et}=b,Pt=k[0]*(F+.5),z=k[1]*(x-.5),u=this._ctx,g=this.transformPt([0,0]),[C,w]=this.getTransformAngle();u.save(),u.setTransform({m11:1*C,m12:1*w,m21:-1*w,m22:1*C,m41:g[0]-1*Pt,m42:g[1]+1*z}),u.drawImage(et,0,0),u.restore()}drawPictureFill(a,_){if(!a)return;let{colorSubstitutions:I,height:b,offsetX:k,offsetY:F,rotation:x,scaleX:et,tintColor:Pt,url:z}=_;const u=this._resourceManager.getResource(z);if((0,Ot.Wi)(u))return;if((0,H.oU)(a))this._buildPath(a.rings,!0);else if((0,H.l9)(a))this._buildPath(a.paths,!0);else if((0,H.YX)(a))this._buildPath(Z(a).rings,!0);else{if(!(0,H.aW)(a))return;console.log("CanvasDrawHelper.drawPictureFill - No implementation!")}const g=this._ctx,C=(0,bt.TB)(z)||"src"in u&&(0,bt.TB)(u.src);let w,S="getFrame"in u?A(u):u;if(I&&(S=this._colorSubstitutionHelper.applyColorSubstituition(S,I)),this._applyAdditionalRenderProps){C||Pt&&(S=this._colorSubstitutionHelper.tintImageData(S,Pt)),w=g.createPattern(S,"repeat");const n=this.transformSize(1);x||(x=0),k?k*=n:k=0,F?F*=n:F=0,b&&(b*=n);const P=b?b/u.height:1,m=et&&b?et*b/u.width:1;if(0!==x||1!==P||1!==m||0!==k||0!==F){const v=new DOMMatrix;v.rotateSelf(0,0,-x).translateSelf(k,F).scaleSelf(m,P,1),w.setTransform(v)}}else w=g.createPattern(S,"repeat");g.save(),g.fillStyle=w,g.fill("evenodd"),g.restore()}drawPictureStroke(a,_){if(!a)return;let{colorSubstitutions:I,capStyle:b,joinStyle:k,miterLimit:F,tintColor:x,url:et,width:Pt}=_;const z=this._resourceManager.getResource(et);if((0,Ot.Wi)(z))return;let u;if((0,H.oU)(a))u=a.rings;else if((0,H.l9)(a))u=a.paths;else{if(!(0,H.YX)(a))return(0,H.aW)(a)?void console.log("CanvasDrawHelper.drawPictureStroke - No implementation!"):void 0;u=Z(a).rings}Pt||(Pt=z.width);const g=(0,bt.TB)(et)||"src"in z&&(0,bt.TB)(z.src);let C="getFrame"in z?A(z):z;I&&(C=this._colorSubstitutionHelper.applyColorSubstituition(C,I)),this._applyAdditionalRenderProps&&(g||x&&(C=this._colorSubstitutionHelper.tintImageData(C,x)));const w=Math.max(this.transformSize((0,at.F2)(Pt)),.5),S=w/C.width,n=this._ctx,P=n.createPattern(C,"repeat-y");let m,v;n.save(),this._setCapStyle(b),this._setJoinStyle(k),void 0!==F&&(n.miterLimit=F),n.lineWidth=w;for(let M of u)if(M=(0,pt.d9)(M),Xt(M),M&&!(M.length<=1)){m=this.transformPt(M[0]);for(let U=1;U<M.length;U++){v=this.transformPt(M[U]);const J=j(m,v),X=new DOMMatrix;X.translateSelf(0,m[1]-w/2).scaleSelf(S,S,1).rotateSelf(0,0,90-J),P.setTransform(X),n.strokeStyle=P,n.beginPath(),n.moveTo(m[0],m[1]),n.lineTo(v[0],v[1]),n.stroke(),m=v}}n.restore()}_buildPath(a,_){const I=this._ctx;if(I.beginPath(),a)for(const b of a){const k=b?b.length:0;if(k>1){let F=this.transformPt(b[0]);I.moveTo(F[0],F[1]);for(let x=1;x<k;x++)F=this.transformPt(b[x]),I.lineTo(F[0],F[1]);_&&I.closePath()}}}_setCapStyle(a){switch(a){case ht.kP.Butt:this._ctx.lineCap="butt";break;case ht.kP.Round:this._ctx.lineCap="round";break;case ht.kP.Square:this._ctx.lineCap="square"}}_setJoinStyle(a){switch(a){case ht.r4.Bevel:this._ctx.lineJoin="bevel";break;case ht.r4.Round:this._ctx.lineJoin="round";break;case ht.r4.Miter:this._ctx.lineJoin="miter"}}}function j(lt,a){return 180/Math.PI*Math.atan2(a[1]-lt[1],a[0]-lt[0])}const Z=lt=>lt?{spatialReference:lt.spatialReference,rings:[[[lt.xmin,lt.ymin],[lt.xmin,lt.ymax],[lt.xmax,lt.ymax],[lt.xmax,lt.ymin],[lt.xmin,lt.ymin]]]}:null,rt=lt=>{switch(lt){case"Left":return It.M7.Left;case"Right":return It.M7.Right;case"Center":return It.M7.Center;case"Justify":return zt.warnOnce("Horizontal alignment 'justify' is not implemented. Falling back to 'center'."),It.M7.Center}},dt=lt=>{switch(lt){case"Top":return It.TR.Top;case"Center":return It.TR.Center;case"Bottom":return It.TR.Bottom;case"Baseline":return It.TR.Baseline}},Nt=(lt,a,_)=>{switch(lt){case"ExtraLeading":return 1+a/_;case"Multiple":return a;case"Exact":return a/_}};function kt(lt,a=1){const _=(0,bt.BX)(lt),I=(0,bt.wi)(lt.fontStyleName),b=(0,nt.BN)(lt.fontFamilyName),{weight:k,style:F}=I,x=a*(lt.height||5),et=(0,bt.X_)(lt.horizontalAlignment),Pt=(0,bt.FG)(lt.verticalAlignment),z=(0,bt.W7)(lt),u=(0,bt.$Z)(lt.haloSymbol),g=u?a*(0|lt.haloSize):0;return{color:z,size:x,horizontalAlignment:et,verticalAlignment:Pt,font:{family:b,style:(0,bt.pJ)(F),weight:(0,bt.On)(k),decoration:_},halo:{size:g||0,color:u,style:F},pixelRatio:1,premultiplyColors:!0}}const Gt=1e-4;function Xt(lt){let a,_,I,b,k,F=lt[0],x=1;for(;x<lt.length;)a=lt[x][0]-F[0],_=lt[x][1]-F[1],b=0!==a?_/a:Math.PI/2,void 0!==I&&b-I<=Gt?(lt.splice(x-1,1),F=k):(k=F,F=lt[x],x++),I=b}},77213:(ae,Wt,G)=>{G.d(Wt,{B$:()=>rt,E0:()=>dt,U1:()=>b,bP:()=>Z,rW:()=>Tt});var At=G(71670),nt=G(25764),pt=G(65489),mt=G(88684),Ot=G(28191),L=G(53661),at=G(37313),V=G(55798),Q=G(6848),tt=G(71949),H=G(77238),ft=G(46806),gt=G(14862),E=G(20877),O=G(2047),ht=G(13763),A=G(12693),St=G(80696),vt=G(18659);const bt=Math.PI,It=bt/2,Mt=96/72,zt=Math.PI/180,yt=Ot.Z.getLogger("esri.symbols.cim.CIMSymbolHelper");function Tt(z){if(!z||!z.type)return null;let u;switch(z.type){case"cim":return z.data;case"web-style":return z;case"simple-marker":{const g=rt.fromSimpleMarker(z);if(!g)return null;u=g;break}case"picture-marker":u=rt.fromPictureMarker(z);break;case"simple-line":u=rt.fromSimpleLineSymbol(z);break;case"simple-fill":u=rt.fromSimpleFillSymbol(z);break;case"picture-fill":u=rt.fromPictureFillSymbol(z);break;case"text":u=rt.fromTextSymbol(z)}return{type:"CIMSymbolReference",symbol:u}}function _t(z,u,g){switch(u.type){case"CIMSymbolReference":return _t(z,u.symbol,g);case"CIMPointSymbol":null==g&&(g={x:0,y:0}),z.drawSymbol(u,g);break;case"CIMLineSymbol":null==g&&(g={paths:[[[0,0],[10,0]]]}),z.drawSymbol(u,g);break;case"CIMPolygonSymbol":null==g&&(g={rings:[[[0,0],[0,10],[10,10],[10,0],[0,0]]]}),z.drawSymbol(u,g);break;case"CIMTextSymbol":z.drawSymbol(u,{x:0,y:0});break;case"CIMVectorMarker":{const C=new ft.u;z.drawMarker(u,C);break}}return z.envelope()}function B(z){if(!z)return 0;switch(z.type){case"CIMMarkerPlacementAlongLineSameSize":case"CIMMarkerPlacementAlongLineRandomSize":case"CIMMarkerPlacementAtExtremities":case"CIMMarkerPlacementAtMeasuredUnits":case"CIMMarkerPlacementAtRatioPositions":case"CIMMarkerPlacementOnLine":case"CIMMarkerPlacementOnVertices":return Math.abs(z.offset);default:return 0}}function q(z){if(!z)return 0;switch(z.type){case"CIMGeometricEffectArrow":return Math.abs(.5*z.width);case"CIMGeometricEffectBuffer":return Math.abs(z.size);case"CIMGeometricEffectExtension":case"CIMGeometricEffectRadial":return Math.abs(z.length);case"CIMGeometricEffectJog":return Math.abs(.5*z.length);case"CIMGeometricEffectMove":return Math.max(Math.abs((0,O.NA)(z.offsetX)),Math.abs((0,O.NA)(z.offsetY)));case"CIMGeometricEffectOffset":case"CIMGeometricEffectOffsetTangent":return Math.abs(z.offset);case"CIMGeometricEffectRegularPolygon":return Math.abs(z.radius);case"CIMGeometricEffectRotate":case"CIMGeometricEffectScale":default:return 0;case"CIMGeometricEffectTaperedPolygon":return.5*Math.max(Math.abs(z.fromWidth),Math.abs(z.toWidth));case"CIMGeometricEffectWave":return Math.abs(z.amplitude)}}function j(z){if(!z)return 0;let u=0;for(const g of z)u+=q(g);return u}class Z{getSymbolInflateSize(u,g,C,w,S){return u||(u=[0,0,0,0]),g?this._getInflateSize(u,g,C,w,S):u}static safeSize(u){const g=Math.max(Math.abs(u[0]),Math.abs(u[2])),C=Math.max(Math.abs(u[1]),Math.abs(u[3]));return Math.sqrt(g*g+C*C)}_vectorMarkerBounds(u,g,C,w){let S=!0;const n=(0,Q.Ue)();if(g&&g.markerGraphics)for(const P of g.markerGraphics){const m=[0,0,0,0];P.geometry&&((0,tt.$P)(n,P.geometry),m[0]=0,m[1]=0,m[2]=0,m[3]=0,this.getSymbolInflateSize(m,P.symbol,C,0,w),n[0]+=m[0],n[1]+=m[1],n[2]+=m[2],n[3]+=m[3],S?(u[0]=n[0],u[1]=n[1],u[2]=n[2],u[3]=n[3],S=!1):(u[0]=Math.min(u[0],n[0]),u[1]=Math.min(u[1],n[1]),u[2]=Math.max(u[2],n[2]),u[3]=Math.max(u[3],n[3])))}return u}_getInflateSize(u,g,C,w,S){if(function k(z){return void 0!==z.symbolLayers}(g)){const n=this._getLayersInflateSize(u,g.symbolLayers,C,w,S),P=j(g.effects);return P>0&&(n[0]-=P,n[1]-=P,n[2]+=P,n[3]+=P),n}return this._getTextInflatedSize(u,g,S)}_getLayersInflateSize(u,g,C,w,S){let n=!0;if(!g)return u;for(const P of g){if(!P)continue;let m=[0,0,0,0];switch(P.type){case"CIMSolidFill":case"CIMPictureFill":case"CIMHatchFill":case"CIMGradientFill":break;case"CIMSolidStroke":case"CIMPictureStroke":case"CIMGradientStroke":{let U=P.width;null!=U&&(U/=P.capStyle===E.kP.Square||P.joinStyle===E.r4.Miter?1.4142135623730951:2,m[0]=-U,m[1]=-U,m[2]=U,m[3]=U);break}case"CIMCharacterMarker":case"CIMVectorMarker":case"CIMPictureMarker":{const M=P;if("CIMVectorMarker"===P.type){const Y=P;if(m=this._vectorMarkerBounds(m,Y,C,S),Y.frame){const $=(Y.frame.xmin+Y.frame.xmax)/2,ot=(Y.frame.ymin+Y.frame.ymax)/2;if(m[0]-=$,m[1]-=ot,m[2]-=$,m[3]-=ot,null!=Y.size){const st=Y.size/(Y.frame.ymax-Y.frame.ymin);m[0]*=st,m[1]*=st,m[2]*=st,m[3]*=st}}}else if("CIMPictureMarker"===P.type){const Y=P,$=C.getResource(Y.url);let ot=1;if((0,L.pC)($)&&$.height&&(ot=$.width/$.height),null!=M.size){const st=M.size/2,ct=M.size*ot*Y.scaleX/2;m=[-ct,-st,ct,st]}}else if(null!=M.size){const Y=M.size/2;m=[-Y,-Y,Y,Y]}if(M.anchorPoint){let Y,$;"Absolute"===M.anchorPointUnits?(Y=M.anchorPoint.x,$=M.anchorPoint.y):(Y=M.anchorPoint.x*(m[2]-m[0]),$=M.anchorPoint.y*(m[3]-m[1])),m[0]-=Y,m[1]-=$,m[2]-=Y,m[3]-=$}let U=(0,O.NA)(M.rotation);if(M.rotateClockwise&&(U=-U),w&&(U-=w),U){const Y=zt*U,$=Math.cos(Y),ot=Math.sin(Y),st=(0,Q.Ue)([A.B1,A.B1,-A.B1,-A.B1]);(0,Q.Ho)(st,[m[0]*$-m[1]*ot,m[0]*ot+m[1]*$]),(0,Q.Ho)(st,[m[0]*$-m[3]*ot,m[0]*ot+m[3]*$]),(0,Q.Ho)(st,[m[2]*$-m[1]*ot,m[2]*ot+m[1]*$]),(0,Q.Ho)(st,[m[2]*$-m[3]*ot,m[2]*ot+m[3]*$]),m=st}let J=(0,O.NA)(M.offsetX),X=(0,O.NA)(M.offsetY);if(w){const Y=zt*w,$=Math.cos(Y),ot=Math.sin(Y),st=J*ot+X*$;J=J*$-X*ot,X=st}m[0]+=J,m[1]+=X,m[2]+=J,m[3]+=X;const T=B(M.markerPlacement);T>0&&(m[0]-=T,m[1]-=T,m[2]+=T,m[3]+=T);break}}const v=j(P.effects);v>0&&(m[0]-=v,m[1]-=v,m[2]+=v,m[3]+=v),n?(u[0]=m[0],u[1]=m[1],u[2]=m[2],u[3]=m[3],n=!1):(u[0]=Math.min(u[0],m[0]),u[1]=Math.min(u[1],m[1]),u[2]=Math.max(u[2],m[2]),u[3]=Math.max(u[3],m[3]))}return u}_getTextInflatedSize(u,g,C){const w=g.height??10;if(u[0]=-w/2,u[1]=-w/2,u[2]=w/2,u[3]=w/2,!C)return u;const S=C.get(g);if(!S)return u;const{text:n,mosaicItem:P}=S;if(!P?.glyphMosaicItems?.length)return u;const{lineGapType:m,lineGap:v}=g,M=m?(0,gt.et)(m,v??0,w):0,U=(0,pt.E)(n)[1],J=P.glyphMosaicItems,X="CIMBackgroundCallout"===g.callout?.type,T=(0,vt.Nr)(J,U,{scale:w/St.Ex,angle:(0,O.NA)(g.angle),xOffset:(0,O.NA)(g.offsetX),yOffset:(0,O.NA)(g.offsetY),hAlign:(0,gt.x1)(g.horizontalAlignment),vAlign:(0,gt.g)(g.verticalAlignment),maxLineWidth:512,lineHeight:St.xm*Math.max(.25,Math.min(M||1,4)),decoration:g.font.decoration||"none",isCIM:!0,hasBackground:X}).boundsT;return u[0]=T.x-T.halfWidth,u[1]=-T.y-T.halfHeight,u[2]=T.x+T.halfWidth,u[3]=-T.y+T.halfHeight,u}}class rt{static getEnvelope(u,g,C){if(!u)return null;const w=new gt.uQ(C);if(Array.isArray(u)){let S;for(const n of u)S?S.union(_t(w,n,g)):S=_t(w,n,g);return S}return _t(w,u,g)}static getTextureAnchor(u,g){const C=this.getEnvelope(u,null,g);if(!C)return[0,0,0];const P=C.height*Mt+2;return[-(C.x+.5*C.width)*Mt/(C.width*Mt+2),-(C.y+.5*C.height)*Mt/P,P]}static rasterize(u,g,C,w,S=!0){const n=C||this.getEnvelope(g,null,w);if(!n)return[null,0,0,0,0];const P=(n.x+.5*n.width)*Mt,m=(n.y+.5*n.height)*Mt;u.width=n.width*Mt,u.height=n.height*Mt,C||(u.width+=2,u.height+=2);const v=u.getContext("2d"),M=gt.zA.createScale(Mt,-Mt);M.translate(.5*u.width-P,.5*u.height+m);const U=new gt.cD(v,w,M);switch(g.type){case"CIMPointSymbol":U.drawSymbol(g,{type:"point",x:0,y:0});break;case"CIMVectorMarker":{const T=new ft.u;U.drawMarker(g,T);break}}const J=v.getImageData(0,0,u.width,u.height),X=new Uint8Array(J.data);if(S){let T;for(let Y=0;Y<X.length;Y+=4)T=X[Y+3]/255,X[Y]=X[Y]*T,X[Y+1]=X[Y+1]*T,X[Y+2]=X[Y+2]*T}return[X,u.width,u.height,-P/u.width,-m/u.height]}static fromTextSymbol(u){const{angle:g,color:C,font:w,haloColor:S,haloSize:n,horizontalAlignment:P,kerning:m,text:v,verticalAlignment:M,xoffset:U,yoffset:J,backgroundColor:X,borderLineColor:T,borderLineSize:Y}=u;let $,ot,st,ct,Lt,Et;w&&($=w.family,ot=w.style,st=w.weight,ct=w.size,Lt=w.decoration);let wt=!1;return v&&(wt=(0,pt.E)(v)[1]),(X||Y)&&(Et={type:"CIMBackgroundCallout",margin:null,backgroundSymbol:{type:"CIMPolygonSymbol",symbolLayers:[{type:"CIMSolidFill",color:lt(X)},{type:"CIMSolidStroke",color:lt(T),width:Y}]},accentBarSymbol:null,gap:null,leaderLineSymbol:null,lineStyle:null}),{type:"CIMPointSymbol",symbolLayers:[{type:"CIMVectorMarker",enable:!0,anchorPointUnits:"Relative",dominantSizeAxis3D:"Y",size:10,billboardMode3D:"FaceNearPlane",frame:{xmin:-5,ymin:-5,xmax:5,ymax:5},markerGraphics:[{type:"CIMMarkerGraphic",geometry:{x:0,y:0},symbol:{type:"CIMTextSymbol",angle:g,blockProgression:E.zV.BTT,depth3D:1,extrapolateBaselines:!0,fontEffects:E.eZ.Normal,fontEncoding:E.DD.Unicode,fontFamilyName:$||"Arial",fontStyleName:a(ot,st),fontType:E.Ky.Unspecified,haloSize:n,height:ct,hinting:E.Dd.Default,horizontalAlignment:Gt(P??"center"),kerning:m,letterWidth:100,ligatures:!0,lineGapType:"Multiple",offsetX:(0,O.NA)(U),offsetY:(0,O.NA)(J),strikethrough:"line-through"===Lt,underline:"underline"===Lt,symbol:{type:"CIMPolygonSymbol",symbolLayers:[{type:"CIMSolidFill",enable:!0,color:lt(C)}]},haloSymbol:{type:"CIMPolygonSymbol",symbolLayers:[{type:"CIMSolidFill",enable:!0,color:lt(S)}]},shadowColor:[0,0,0,255],shadowOffsetX:1,shadowOffsetY:1,textCase:"Normal",textDirection:wt?E.UX.RTL:E.UX.LTR,verticalAlignment:Xt(M??"baseline"),verticalGlyphOrientation:E.RS.Right,wordSpacing:100,billboardMode3D:E.UR.FaceNearPlane,callout:Et},textString:v}],scaleSymbolsProportionally:!0,respectFrame:!0}],scaleX:1,angleAlignment:"Display"}}static fromPictureFillSymbol(u){const{height:g,outline:C,width:w,xoffset:S,xscale:n,yoffset:P,yscale:m}=u,v=[],M={type:"CIMPolygonSymbol",symbolLayers:v};if(C){const{cap:Y,join:$,miterLimit:ot,width:st}=C;v.push({type:"CIMSolidStroke",color:lt(C.color),capStyle:Nt(Y),joinStyle:kt($),miterLimit:ot,width:st})}let U=u.url;"esriPFS"===u.type&&u.imageData&&(U=u.imageData);const J="angle"in u?u.angle??0:0;return v.push({type:"CIMPictureFill",invertBackfaceTexture:!1,scaleX:1,textureFilter:E.Qb.Picture,tintColor:null,url:U,height:(g??0)*(m||1),width:(w??0)*(n||1),offsetX:(0,O.NA)(S),offsetY:(0,O.NA)(P),rotation:(0,O.NA)(-J),colorSubstitutions:null}),M}static fromSimpleFillSymbol(u){const{color:g,style:C,outline:w}=u,S=[],n={type:"CIMPolygonSymbol",symbolLayers:S};let P=null;if(w){const{cap:m,join:v,style:M}=w;"solid"!==M&&"none"!==M&&"esriSLSSolid"!==M&&"esriSLSNull"!==M&&(P=[{type:"CIMGeometricEffectDashes",dashTemplate:b(M,m),lineDashEnding:"NoConstraint",scaleDash:!0,offsetAlongLine:null}]),S.push({type:"CIMSolidStroke",color:lt(w.color),capStyle:Nt(m),joinStyle:kt(v),miterLimit:w.miterLimit,width:w.width,effects:P})}if(C&&"solid"!==C&&"none"!==C&&"esriSFSSolid"!==C&&"esriSFSNull"!==C){const m={type:"CIMLineSymbol",symbolLayers:[{type:"CIMSolidStroke",color:lt(g),capStyle:E.kP.Butt,joinStyle:E.r4.Miter,width:.75}]};let v=0;const M=(0,V.Wz)(x(C)?8:10);switch(C){case"vertical":case"esriSFSVertical":v=90;break;case"forward-diagonal":case"esriSFSForwardDiagonal":case"diagonal-cross":case"esriSFSDiagonalCross":v=-45;break;case"backward-diagonal":case"esriSFSBackwardDiagonal":v=45;break;case"cross":case"esriSFSCross":v=0}S.push({type:"CIMHatchFill",lineSymbol:m,offsetX:0,offsetY:0,rotation:v,separation:M}),"cross"===C||"esriSFSCross"===C?S.push({type:"CIMHatchFill",lineSymbol:(0,mt.d9)(m),offsetX:0,offsetY:0,rotation:90,separation:M}):"diagonal-cross"!==C&&"esriSFSDiagonalCross"!==C||S.push({type:"CIMHatchFill",lineSymbol:(0,mt.d9)(m),offsetX:0,offsetY:0,rotation:45,separation:M})}else!C||"solid"!==C&&"esriSFSSolid"!==C||S.push({type:"CIMSolidFill",enable:!0,color:lt(g)});return n}static fromSimpleLineSymbol(u){const{cap:g,color:C,join:w,marker:S,miterLimit:n,style:P,width:m}=u;let v=null;"solid"!==P&&"none"!==P&&"esriSLSSolid"!==P&&"esriSLSNull"!==P&&(v=[{type:"CIMGeometricEffectDashes",dashTemplate:b(P,g),lineDashEnding:"NoConstraint",scaleDash:!0,offsetAlongLine:null}]);const M=[];if(S){let U;switch(S.placement){case"begin-end":U=E.Tx.Both;break;case"begin":U=E.Tx.JustBegin;break;case"end":U=E.Tx.JustEnd;break;default:U=E.Tx.None}const J=rt.fromSimpleMarker(S,m,C).symbolLayers[0];J.markerPlacement={type:"CIMMarkerPlacementAtExtremities",angleToLine:!0,offset:0,extremityPlacement:U,offsetAlongLine:0},M.push(J)}return"none"!==P&&"esriSLSNull"!==P&&M.push({type:"CIMSolidStroke",color:lt(C),capStyle:Nt(g),joinStyle:kt(w),miterLimit:n,width:m,effects:v}),{type:"CIMLineSymbol",symbolLayers:M}}static fromPictureMarker(u){const{angle:g,height:C,width:w,xoffset:S,yoffset:n}=u;let P=u.url;return"esriPMS"===u.type&&u.imageData&&(P=u.imageData),{type:"CIMPointSymbol",symbolLayers:[{type:"CIMPictureMarker",invertBackfaceTexture:!1,scaleX:1,textureFilter:E.Qb.Picture,tintColor:null,url:P,size:C,width:w,offsetX:(0,O.NA)(S),offsetY:(0,O.NA)(n),rotation:(0,O.NA)(-g)}]}}static fromSimpleMarker(u,g,C){const{style:w}=u,S=u.color??C;if("path"===w){const v=[];if("outline"in u&&u.outline){const J=u.outline;v.push({type:"CIMSolidStroke",enable:!0,width:(0,V.F2)(Math.round((0,V.Wz)(J.width))),color:lt(J.color)})}v.push({type:"CIMSolidFill",enable:!0,color:lt(S),path:u.path});const[M,U]=F("square");return{type:"CIMPointSymbol",symbolLayers:[{type:"CIMVectorMarker",enable:!0,rotation:(0,O.NA)(-u.angle),size:(0,O.NA)(u.size||6),offsetX:(0,O.NA)(u.xoffset),offsetY:(0,O.NA)(u.yoffset),frame:M,markerGraphics:[{type:"CIMMarkerGraphic",geometry:U,symbol:{type:"CIMPolygonSymbol",symbolLayers:v}}]}]}}const[n,P]=F(w);let m;if(P&&n){const v=[];if("outline"in u&&u.outline){const U=u.outline;v.push({type:"CIMSolidStroke",enable:!0,width:null!=U.width&&U.width>.667?(0,V.F2)(Math.round((0,V.Wz)(U.width))):U.width,color:lt(U.color)})}else!g||"line-marker"!==u.type||"cross"!==u.style&&"x"!==u.style||v.push({type:"CIMSolidStroke",enable:!0,width:g,color:lt(S)});v.push({type:"CIMSolidFill",enable:!0,color:lt(S)});const M={type:"CIMPolygonSymbol",symbolLayers:v};m={type:"CIMPointSymbol",symbolLayers:[{type:"CIMVectorMarker",enable:!0,rotation:(0,O.NA)(-u.angle),size:(0,O.NA)(u.size||6*g),offsetX:(0,O.NA)(u.xoffset),offsetY:(0,O.NA)(u.yoffset),frame:n,markerGraphics:[{type:"CIMMarkerGraphic",geometry:P,symbol:M}]}]}}return m}static fromCIMHatchFill(u,g){const C=g*(u.separation??4),w=C/2,S=(0,mt.d9)(u.lineSymbol);S.symbolLayers?.forEach(m=>{switch(m.type){case"CIMSolidStroke":null!=m.width&&(m.width*=g),m.effects?.forEach(v=>{"CIMGeometricEffectDashes"===v.type&&(v.dashTemplate=v.dashTemplate.map(M=>M*g))});break;case"CIMVectorMarker":{null!=m.size&&(m.size*=g);const v=m.markerPlacement;null!=v&&"placementTemplate"in v&&(v.placementTemplate=v.placementTemplate.map(M=>M*g));break}}});let n=this._getLineSymbolPeriod(S)||4;for(;n<4;)n*=2;const P=n/2;return{type:"CIMVectorMarker",frame:{xmin:-P,xmax:P,ymin:-w,ymax:w},markerGraphics:[{type:"CIMMarkerGraphic",geometry:{paths:[[[-P,0],[P,0]]]},symbol:S}],size:C}}static fetchResources(u,g,C){if(u&&g)switch(u.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":{const w=u.symbolLayers;if(!w)return;for(const S of w)switch(Pt(S,g,C),S.type){case"CIMPictureFill":case"CIMHatchFill":case"CIMGradientFill":case"CIMPictureStroke":case"CIMGradientStroke":case"CIMCharacterMarker":case"CIMPictureMarker":"url"in S&&S.url&&C.push(g.fetchResource(S.url,null));break;case"CIMVectorMarker":{const n=S.markerGraphics;if(!n)continue;for(const P of n)if(P){const m=P.symbol;m&&rt.fetchResources(m,g,C)}}}}}}static _getLineSymbolPeriod(u){if(u){const g=this._getEffectsRepeat(u.effects);if(g)return g;if(u.symbolLayers)for(const C of u.symbolLayers)if(C){const w=this._getEffectsRepeat(C.effects);if(w)return w;switch(C.type){case"CIMCharacterMarker":case"CIMPictureMarker":case"CIMVectorMarker":case"CIMObjectMarker3D":case"CIMglTFMarker3D":{const S=this._getPlacementRepeat(C.markerPlacement);if(S)return S}}}}return 0}static _getEffectsRepeat(u){if(u)for(const g of u)if(g)switch(g.type){case"CIMGeometricEffectDashes":{const C=g.dashTemplate;if(C&&C.length){let w=0;for(const S of C)w+=S;return 1&C.length&&(w*=2),w}break}case"CIMGeometricEffectWave":return g.period;default:yt.error(`unsupported geometric effect type ${g.type}`)}return 0}static _getPlacementRepeat(u){if(u)switch(u.type){case"CIMMarkerPlacementAlongLineSameSize":case"CIMMarkerPlacementAlongLineRandomSize":case"CIMMarkerPlacementAlongLineVariableSize":{const g=u.placementTemplate;if(g&&g.length){let C=0;for(const w of g)C+=+w;return 1&g.length&&(C*=2),C}break}}return 0}static fromCIMInsidePolygon(u){const g=u.markerPlacement,C={...u};C.markerPlacement=null,C.anchorPoint=null;const w=Math.abs(g.stepX),S=Math.abs(g.stepY),n=(g.randomness??100)/100;let P,m,v,M;if("Random"===g.gridType){const U=(0,V.Wz)(St.C1),J=Math.max(Math.floor(U/w),1),X=Math.max(Math.floor(U/S),1);P=J*w/2,m=X*S/2,v=2*m;const T=new at.Z(g.seed),Y=n*w/1.5,$=n*S/1.5;M=[];for(let ot=0;ot<J;ot++)for(let st=0;st<X;st++){const ct=ot*w-P+Y*(.5-T.getFloat()),Lt=st*S-m+$*(.5-T.getFloat());M.push({x:ct,y:Lt}),0===ot&&M.push({x:ct+2*P,y:Lt}),0===st&&M.push({x:ct,y:Lt+2*m})}}else!0===g.shiftOddRows?(P=w/2,m=S,v=2*S,M=[{x:-P,y:0},{x:P,y:0},{x:0,y:m},{x:0,y:-m}]):(P=w/2,m=S/2,v=S,M=[{x:-w,y:0},{x:0,y:-S},{x:-w,y:-S},{x:0,y:0},{x:w,y:0},{x:0,y:S},{x:w,y:S},{x:-w,y:S},{x:w,y:-S}]);return{type:"CIMVectorMarker",frame:{xmin:-P,xmax:P,ymin:-m,ymax:m},markerGraphics:M.map(U=>({type:"CIMMarkerGraphic",geometry:U,symbol:{type:"CIMPointSymbol",symbolLayers:[C]}})),size:v}}static getSize(u){if(u)switch(u.type){case"CIMTextSymbol":return u.height;case"CIMPointSymbol":{let g=0;if(u.symbolLayers)for(const C of u.symbolLayers)if(C)switch(C.type){case"CIMCharacterMarker":case"CIMPictureMarker":case"CIMVectorMarker":case"CIMObjectMarker3D":case"CIMglTFMarker3D":{const w=C.size;null!=w&&w>g&&(g=w);break}}return g}case"CIMLineSymbol":case"CIMPolygonSymbol":{let g=0;if(u.symbolLayers)for(const C of u.symbolLayers)if(C)switch(C.type){case"CIMSolidStroke":case"CIMPictureStroke":case"CIMGradientStroke":{const w=C.width;null!=w&&w>g&&(g=w);break}case"CIMCharacterMarker":case"CIMPictureMarker":case"CIMVectorMarker":case"CIMObjectMarker3D":case"CIMglTFMarker3D":if(C.markerPlacement&&(0,O.gJ)(C.markerPlacement)){const w=C.size;null!=w&&w>g&&(g=w)}}return g}}}static getMarkerScaleRatio(u){return u&&"CIMVectorMarker"===u.type&&!1!==u.scaleSymbolsProportionally&&u.frame&&null!=u.size?u.size/(u.frame.ymax-u.frame.ymin):1}}class dt{static findApplicableOverrides(u,g,C){if(u&&g){if(u.primitiveName){let w=!1;for(const S of C)if(S.primitiveName===u.primitiveName){w=!0;break}if(!w)for(const S of g)S.primitiveName===u.primitiveName&&C.push(S)}switch(u.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(u.effects)for(const w of u.effects)dt.findApplicableOverrides(w,g,C);if(u.symbolLayers)for(const w of u.symbolLayers)dt.findApplicableOverrides(w,g,C);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMPictureStroke":case"CIMGradientStroke":case"CIMSolidFill":case"CIMPictureFill":case"CIMHatchFill":case"CIMGradientFill":case"CIMVectorMarker":case"CIMCharacterMarker":case"CIMPictureMarker":if(u.effects)for(const w of u.effects)dt.findApplicableOverrides(w,g,C);if(u.markerPlacement&&dt.findApplicableOverrides(u.markerPlacement,g,C),"CIMVectorMarker"===u.type){if(u.markerGraphics)for(const w of u.markerGraphics)dt.findApplicableOverrides(w,g,C),dt.findApplicableOverrides(w.symbol,g,C)}else"CIMCharacterMarker"===u.type?dt.findApplicableOverrides(u.symbol,g,C):"CIMHatchFill"===u.type?dt.findApplicableOverrides(u.lineSymbol,g,C):"CIMPictureMarker"===u.type&&dt.findApplicableOverrides(u.animatedSymbolProperties,g,C)}}}static findEffectOverrides(u,g,C){if(!g||!u)return;const w=u.length;for(let S=0;S<w;S++){const n=u[S]?.primitiveName;if(n){let P=!1;for(const m of C)if(m.primitiveName===n){P=!0;break}if(!P)for(const m of g)m.primitiveName===n&&C.push(m)}}}static resolveSymbolOverrides(u,g,C,w,S,n,P){return(0,At.Z)(function*(){if(!u||!u.symbol)return null;let{symbol:m,primitiveOverrides:v}=u;const M=!!v;if(!M&&!w)return m;m=(0,mt.d9)(m);let U=!0;if(g||(g={attributes:{}},U=!1),M){if(U||(v=v.filter(J=>!J.valueExpressionInfo?.expression.includes("$feature"))),P||(v=v.filter(J=>!J.valueExpressionInfo?.expression.includes("$view"))),v.length>0){const J=(0,O.Qf)(g.attributes);yield dt.evaluateOverrides(v,g,{spatialReference:C,fields:J,geometryType:S},n,P)}dt.applyOverrides(m,v)}return w&&dt.applyDictionaryTextOverrides(m,g,w),m})()}static evaluateOverrides(u,g,C,w,S){return(0,At.Z)(function*(){if(!g)return;let n;for(const P of u){const m=P.valueExpressionInfo;if(m&&C&&C.geometryType){n||(n=[]),P.value=void 0;const v=(0,H.Yi)(m.expression,C.spatialReference,C.fields).then(M=>{P.value=(0,ht.Z)(M,g,{$view:S},C.geometryType,w)});n.push(v)}}void 0!==n&&n.length>0&&(yield Promise.all(n))})()}static applyDictionaryTextOverrides(u,g,C,w="Normal"){if(u&&u.type)switch(u.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":case"CIMTextSymbol":{const S=u.symbolLayers;if(!S)return;for(const n of S)n&&"CIMVectorMarker"===n.type&&dt.applyDictionaryTextOverrides(n,g,C,"CIMTextSymbol"===u.type?u.textCase:w)}break;case"CIMVectorMarker":{const S=u.markerGraphics;if(!S)return;for(const n of S)n&&dt.applyDictionaryTextOverrides(n,g,C)}break;case"CIMMarkerGraphic":{const S=u.textString;if(S&&S.includes("[")){const n=(0,O.H1)(S,C);u.textString=(0,O.E_)(g,n,w)}}}}static applyOverrides(u,g,C,w){if(u.primitiveName)for(const S of g)if(S.primitiveName===u.primitiveName){const n=et(S.propertyName);if(w&&w.push({cim:u,nocapPropertyName:n,value:u[n]}),S.expression&&(S.value=dt.toValue(S.propertyName,S.expression)),C){let P=!1;for(const m of C)m.primitiveName===u.primitiveName&&(P=!0);P||C.push(S)}(0,L.pC)(S.value)&&(u[n]=S.value)}switch(u.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(u.effects)for(const S of u.effects)dt.applyOverrides(S,g,C,w);if(u.symbolLayers)for(const S of u.symbolLayers)dt.applyOverrides(S,g,C,w);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMSolidFill":case"CIMVectorMarker":if(u.effects)for(const S of u.effects)dt.applyOverrides(S,g,C,w);if("CIMVectorMarker"===u.type&&u.markerGraphics)for(const S of u.markerGraphics)dt.applyOverrides(S,g,C,w),dt.applyOverrides(S.symbol,g,C,w)}}static restoreOverrides(u){for(const g of u)g.cim[g.nocapPropertyName]=g.value}static buildOverrideKey(u){let g="";for(const C of u)void 0!==C.value&&(g+=`${C.primitiveName}${C.propertyName}${JSON.stringify(C.value)}`);return g}static toValue(u,g){if("DashTemplate"===u)return g.split(" ").map(C=>Number(C));if("Color"===u){const C=new nt.Z(g).toRgba();return C[3]*=255,C}return g}}const Nt=z=>{if(!z)return E.kP.Butt;switch(z){case"butt":return E.kP.Butt;case"square":return E.kP.Square;case"round":return E.kP.Round}},kt=z=>{if(!z)return E.r4.Miter;switch(z){case"miter":return E.r4.Miter;case"round":return E.r4.Round;case"bevel":return E.r4.Bevel}},Gt=z=>{if((0,L.Wi)(z))return"Center";switch(z){case"left":return"Left";case"right":return"Right";case"center":return"Center"}},Xt=z=>{if((0,L.Wi)(z))return"Center";switch(z){case"baseline":return"Baseline";case"top":return"Top";case"middle":return"Center";case"bottom":return"Bottom"}},lt=z=>{if(!z)return[0,0,0,0];const{r:u,g,b:C,a:w}=z;return[u,g,C,255*w]},a=(z,u)=>{const g=_(u),C=I(z);return g&&C?`${g}-${C}`:`${g}${C}`},_=z=>{if(!z)return"";switch(z.toLowerCase()){case"bold":case"bolder":return"bold"}return""},I=z=>{if(!z)return"";switch(z.toLowerCase()){case"italic":case"oblique":return"italic"}return""},b=(z,u)=>{const g="butt"===u;switch(z){case"dash":case"esriSLSDash":return g?[4,3]:[3,4];case"dash-dot":case"esriSLSDashDot":return g?[4,3,1,3]:[3,4,0,4];case"dot":case"esriSLSDot":return g?[1,3]:[0,4];case"long-dash":case"esriSLSLongDash":return g?[8,3]:[7,4];case"long-dash-dot":case"esriSLSLongDashDot":return g?[8,3,1,3]:[7,4,0,4];case"long-dash-dot-dot":case"esriSLSDashDotDot":return g?[8,3,1,3,1,3]:[7,4,0,4,0,4];case"short-dash":case"esriSLSShortDash":return g?[4,1]:[3,2];case"short-dash-dot":case"esriSLSShortDashDot":return g?[4,1,1,1]:[3,2,0,2];case"short-dash-dot-dot":case"esriSLSShortDashDotDot":return g?[4,1,1,1,1,1]:[3,2,0,2,0,2];case"short-dot":case"esriSLSShortDot":return g?[1,1]:[0,2];case"solid":case"esriSLSSolid":case"none":return yt.error("Unexpected: style does not require rasterization"),[0,0];default:return yt.error(`Tried to rasterize SLS, but found an unexpected style: ${z}!`),[0,0]}},F=z=>{let C,w;const S=z;if("circle"===S||"esriSMSCircle"===S){let P=Math.acos(.995),m=Math.ceil(bt/P/4);0===m&&(m=1),P=It/m,m*=4;const v=[];v.push([50,0]);for(let M=1;M<m;M++)v.push([50*Math.cos(M*P),-50*Math.sin(M*P)]);v.push([50,0]),C={rings:[v]},w={xmin:-50,ymin:-50,xmax:50,ymax:50}}else if("cross"===S||"esriSMSCross"===S)C={rings:[[[0,50],[0,0],[50,0],[50,-0],[0,-0],[0,-50],[-0,-50],[-0,-0],[-50,-0],[-50,0],[-0,0],[-0,50],[0,50]]]},w={xmin:-50,ymin:-50,xmax:50,ymax:50};else if("diamond"===S||"esriSMSDiamond"===S)C={rings:[[[-50,0],[0,50],[50,0],[0,-50],[-50,0]]]},w={xmin:-50,ymin:-50,xmax:50,ymax:50};else if("square"===S||"esriSMSSquare"===S)C={rings:[[[-50,-50],[-50,50],[50,50],[50,-50],[-50,-50]]]},w={xmin:-50,ymin:-50,xmax:50,ymax:50};else if("x"===S||"esriSMSX"===S)C={rings:[[[0,0],[50,50],[50,50],[0,0],[50,-50],[50,-50],[0,-0],[-50,-50],[-50,-50],[-0,0],[-50,50],[-50,50],[0,0]]]},w={xmin:-50,ymin:-50,xmax:50,ymax:50};else if("triangle"===S||"esriSMSTriangle"===S){const n=57.735026918962575,P=-n,m=2/3*100,v=m-100;C={rings:[[[P,v],[0,m],[n,v],[P,v]]]},w={xmin:P,ymin:v,xmax:n,ymax:m}}else"arrow"===S&&(C={rings:[[[-50,50],[50,0],[-50,-50],[-33,-20],[-33,20],[-50,50]]]},w={xmin:-50,ymin:-50,xmax:50,ymax:50});return[w,C]},x=z=>"vertical"===z||"horizontal"===z||"cross"===z||"esriSFSCross"===z||"esriSFSVertical"===z||"esriSFSHorizontal"===z,et=z=>z&&z.charAt(0).toLowerCase()+z.substr(1);function Pt(z,u,g){if(z.effects&&!(0,L.pC)(u.geometryEngine)){if(u.geometryEnginePromise)return void g.push(u.geometryEnginePromise);(0,O.Cc)(z.effects)&&(u.geometryEnginePromise=(0,O.RI)(),g.push(u.geometryEnginePromise),u.geometryEnginePromise.then(C=>u.geometryEngine=C))}}},61164:(ae,Wt,G)=>{G.d(Wt,{Z:()=>At});class At{constructor(pt=0,mt=0,Ot=0,L=0){this.x=pt,this.y=mt,this.width=Ot,this.height=L}get isEmpty(){return this.width<=0||this.height<=0}union(pt){this.x=Math.min(this.x,pt.x),this.y=Math.min(this.y,pt.y),this.width=Math.max(this.width,pt.width),this.height=Math.max(this.height,pt.height)}}},79905:(ae,Wt,G)=>{G.d(Wt,{Fp:()=>mt,RL:()=>tt,UV:()=>Q,bk:()=>V});var At=G(1671),nt=G(71182),pt=G(61164);function mt(E){if(!E)return null;switch(E.type){case"CIMPointSymbol":{const O=E.symbolLayers;return O&&1===O.length?mt(O[0]):null}case"CIMVectorMarker":{const O=E.markerGraphics;if(!O||1!==O.length)return null;const ht=O[0];if(!ht)return null;const A=ht.geometry;if(!A)return null;const St=ht.symbol;return!St||"CIMPolygonSymbol"!==St.type&&"CIMLineSymbol"!==St.type||St.symbolLayers?.some(vt=>!!vt.effects)?null:{geom:A,asFill:"CIMPolygonSymbol"===St.type}}case"sdf":return{geom:E.geom,asFill:E.asFill}}return null}function at(E){let O=1/0,ht=-1/0,A=1/0,St=-1/0;for(const vt of E)for(const bt of vt)bt[0]<O&&(O=bt[0]),bt[0]>ht&&(ht=bt[0]),bt[1]<A&&(A=bt[1]),bt[1]>St&&(St=bt[1]);return[O,A,ht,St]}function V(E){return E?E.rings?at(E.rings):E.paths?at(E.paths):(0,nt.YX)(E)?[E.xmin,E.ymin,E.xmax,E.ymax]:null:null}function Q(E,O,ht,A,St){const[vt,bt,It,Rt]=E;if(It<vt||Rt<bt)return[0,0,0];const D=It-vt,it=Rt-bt,yt=Math.floor(31.5),Tt=(128-2*(yt+1))/Math.max(D,it),_t=Math.round(D*Tt)+2*yt,B=Math.round(it*Tt)+2*yt;let q=1;O&&(q=B/Tt/(O.ymax-O.ymin));let j=0,Z=0,rt=1;A&&(St?O&&ht&&O.ymax-O.ymin>0&&(rt=(O.xmax-O.xmin)/(O.ymax-O.ymin),j=A.x/(ht*rt),Z=A.y/ht):(j=A.x,Z=A.y)),O&&(j=.5*(O.xmax+O.xmin)+j*(O.xmax-O.xmin),Z=.5*(O.ymax+O.ymin)+Z*(O.ymax-O.ymin)),j-=vt,Z-=bt,j*=Tt,Z*=Tt,j+=yt,Z+=yt;let dt=j/_t-.5,Nt=Z/B-.5;return St&&ht&&(dt*=ht*rt,Nt*=ht),[q,dt,Nt]}function tt(E){const O=function Ot(E){return E?E.rings?E.rings:E.paths?E.paths:void 0!==E.xmin&&void 0!==E.ymin&&void 0!==E.xmax&&void 0!==E.ymax?[[[E.xmin,E.ymin],[E.xmin,E.ymax],[E.xmax,E.ymax],[E.xmax,E.ymin],[E.xmin,E.ymin]]]:null:null}(E.geom),ht=function L(E){let O=1/0,ht=-1/0,A=1/0,St=-1/0;for(const vt of E)for(const bt of vt)bt[0]<O&&(O=bt[0]),bt[0]>ht&&(ht=bt[0]),bt[1]<A&&(A=bt[1]),bt[1]>St&&(St=bt[1]);return new pt.Z(O,A,ht-O,St-A)}(O),vt=Math.floor(31.5),bt=(128-2*(vt+1))/Math.max(ht.width,ht.height),It=Math.round(ht.width*bt)+2*vt,Rt=Math.round(ht.height*bt)+2*vt,D=[];for(const Mt of O)if(Mt&&Mt.length>1){const zt=[];for(const yt of Mt){let[Tt,_t]=yt;Tt-=ht.x,_t-=ht.y,Tt*=bt,_t*=bt,Tt+=vt-.5,_t+=vt-.5,zt.push(E.asFill?[Tt,_t]:[Math.round(Tt),Math.round(_t)])}if(E.asFill){const yt=zt.length-1;zt[0][0]===zt[yt][0]&&zt[0][1]===zt[yt][1]||zt.push(zt[0])}D.push(zt)}const it=function H(E,O,ht,A){const St=O*ht,vt=new Array(St),bt=A*A+1;for(let It=0;It<St;++It)vt[It]=bt;for(const It of E){const Rt=It.length;for(let D=1;D<Rt;++D){const it=It[D-1],Mt=It[D];let zt,yt,Tt,_t;it[0]<Mt[0]?(zt=it[0],yt=Mt[0]):(zt=Mt[0],yt=it[0]),it[1]<Mt[1]?(Tt=it[1],_t=Mt[1]):(Tt=Mt[1],_t=it[1]);let B=Math.floor(zt)-A,q=Math.floor(yt)+A,j=Math.floor(Tt)-A,Z=Math.floor(_t)+A;B<0&&(B=0),q>O&&(q=O),j<0&&(j=0),Z>ht&&(Z=ht);const rt=Mt[0]-it[0],dt=Mt[1]-it[1],Nt=rt*rt+dt*dt;for(let kt=B;kt<q;kt++)for(let Gt=j;Gt<Z;Gt++){let Xt,lt,a=(kt-it[0])*rt+(Gt-it[1])*dt;a<0?(Xt=it[0],lt=it[1]):a>Nt?(Xt=Mt[0],lt=Mt[1]):(a/=Nt,Xt=it[0]+a*rt,lt=it[1]+a*dt);const _=(kt-Xt)*(kt-Xt)+(Gt-lt)*(Gt-lt),I=(ht-Gt-1)*O+kt;_<vt[I]&&(vt[I]=_)}}}for(let It=0;It<St;++It)vt[It]=Math.sqrt(vt[It]);return vt}(D,It,Rt,vt);return E.asFill&&function ft(E,O,ht,A,St){for(const vt of E){const bt=vt.length;for(let It=1;It<bt;++It){const Rt=vt[It-1],D=vt[It];let it,Mt,zt,yt;Rt[0]<D[0]?(it=Rt[0],Mt=D[0]):(it=D[0],Mt=Rt[0]),Rt[1]<D[1]?(zt=Rt[1],yt=D[1]):(zt=D[1],yt=Rt[1]);let Tt=Math.floor(it),_t=Math.floor(Mt)+1,B=Math.floor(zt),q=Math.floor(yt)+1;Tt<A&&(Tt=A),_t>O-A&&(_t=O-A),B<A&&(B=A),q>ht-A&&(q=ht-A);for(let j=B;j<q;++j){if(Rt[1]>j==D[1]>j)continue;const Z=(ht-j-1)*O;for(let rt=Tt;rt<_t;++rt)rt<(D[0]-Rt[0])*(j-Rt[1])/(D[1]-Rt[1])+Rt[0]&&(St[Z+rt]=-St[Z+rt]);for(let rt=A;rt<Tt;++rt)St[Z+rt]=-St[Z+rt]}}}}(D,It,Rt,vt,it),[gt(it,vt),It,Rt]}function gt(E,O){const ht=2*O,A=E.length,St=new Uint8Array(4*A);for(let vt=0;vt<A;++vt)(0,At.I)(.5-E[vt]/ht,St,4*vt);return St}},42353:(ae,Wt,G)=>{G.d(Wt,{Z:()=>mt});var At=G(55798);class mt{constructor(at){at&&(this._textRasterizationCanvas=at)}rasterizeText(at,V){this._textRasterizationCanvas||(this._textRasterizationCanvas=document.createElement("canvas"));const Q=this._textRasterizationCanvas,tt=Q.getContext("2d");this._setFontProperties(tt,V),this._parameters=V,this._textLines=at.split(/\r?\n/),this._lineHeight=this._computeLineHeight();const H=this._computeTextWidth(tt,V),{decoration:ft,weight:gt}=V.font;this._lineThroughWidthOffset=ft&&"line-through"===ft?.1*this._lineHeight:0;const E=this._lineHeight*this._textLines.length;Q.width=H+2*this._lineThroughWidthOffset,Q.height=E,this._renderedLineHeight=Math.round(this._lineHeight*V.pixelRatio),this._renderedHaloSize=V.halo.size*V.pixelRatio,this._renderedWidth=H*V.pixelRatio,this._renderedHeight=E*V.pixelRatio,this._lineThroughWidthOffset*=V.pixelRatio;const ht=V.halo&&V.halo.color?V.halo.color:[0,0,0,0];this._fillStyle=function pt(L){return`rgba(${L.slice(0,3).toString()},${L[3]})`}(V.color??[0,0,0,0]),this._haloStyle=function nt(L){return`rgb(${L.slice(0,3).toString()})`}(ht);const A=this._renderedLineHeight,St=this._renderedHaloSize;tt.save(),tt.clearRect(0,0,Q.width,Q.height),this._setFontProperties(tt,V);const vt=function Ot(L,at){return"center"===L?.5*at:"right"===L?at:0}(tt.textAlign,this._renderedWidth)+St,bt=St,It=St>0;let Rt=this._lineThroughWidthOffset,D=0;It&&this._renderHalo(tt,vt,bt,Rt,D,V),D+=bt,Rt+=vt;for(const B of this._textLines)It?(tt.globalCompositeOperation="destination-out",tt.fillStyle="rgb(0, 0, 0)",tt.fillText(B,Rt,D),tt.globalCompositeOperation="source-over",tt.fillStyle=this._fillStyle,tt.fillText(B,Rt,D)):(tt.fillStyle=this._fillStyle,tt.fillText(B,Rt,D)),ft&&"none"!==ft&&this._renderDecoration(tt,Rt,D,ft,gt),D+=A;tt.restore();const it=this._renderedWidth+2*this._lineThroughWidthOffset,Mt=this._renderedHeight,zt=tt.getImageData(0,0,it,Mt),yt=new Uint8Array(zt.data);if(V.premultiplyColors){let B;for(let q=0;q<yt.length;q+=4)B=yt[q+3]/255,yt[q]=yt[q]*B,yt[q+1]=yt[q+1]*B,yt[q+2]=yt[q+2]*B}let Tt,_t;switch(V.horizontalAlignment){case"left":Tt=-.5;break;case"right":Tt=.5;break;default:Tt=0}switch(V.verticalAlignment){case"bottom":_t=-.5;break;case"top":_t=.5;break;default:_t=0}return{size:[it,Mt],image:new Uint32Array(yt.buffer),sdf:!1,simplePattern:!1,anchorX:Tt,anchorY:_t,canvas:Q}}_renderHalo(at,V,Q,tt,H,ft){const gt=this._renderedWidth,E=this._renderedHeight;this._haloRasterizationCanvas||(this._haloRasterizationCanvas=document.createElement("canvas")),this._haloRasterizationCanvas.width=gt,this._haloRasterizationCanvas.height=E;const O=this._haloRasterizationCanvas,ht=O.getContext("2d");ht.clearRect(0,0,gt,E),this._setFontProperties(ht,ft);const{decoration:A,weight:St}=ft.font;ht.fillStyle=this._haloStyle,ht.strokeStyle=this._haloStyle,ht.lineJoin="round",this._renderHaloNative(ht,V,Q,A,St),at.globalAlpha=this._parameters.halo.color[3],at.drawImage(O,0,0,gt,E,tt,H,gt,E),at.globalAlpha=1}_renderHaloNative(at,V,Q,tt,H){const ft=this._renderedLineHeight,gt=this._renderedHaloSize;for(const E of this._textLines){const O=2*gt,ht=5,A=.1;for(let St=0;St<ht;St++){const vt=(1-(ht-1)*A+St*A)*O;at.lineWidth=vt,at.strokeText(E,V,Q),tt&&"none"!==tt&&this._renderDecoration(at,V,Q,tt,H,vt)}Q+=ft}}_setFontProperties(at,V){const Q=Math.max(V.size,.5),tt=V.font,H=`${tt.style} ${tt.weight} ${(0,At.F2)(Q*V.pixelRatio).toFixed(1)}px ${tt.family}, sans-serif`;let ft;switch(at.font=H,at.textBaseline="top",V.horizontalAlignment){case"left":default:ft="left";break;case"right":ft="right";break;case"center":ft="center"}at.textAlign=ft}computeTextSize(at,V){this._textRasterizationCanvas||(this._textRasterizationCanvas=document.createElement("canvas"));const Q=this._textRasterizationCanvas,tt=Q.getContext("2d");this._setFontProperties(tt,V),this._parameters=V,this._textLines=at.split(/\r?\n/),this._lineHeight=this._computeLineHeight();const H=this._computeTextWidth(tt,V),ft=this._lineHeight*this._textLines.length;return Q.width=H,Q.height=ft,[H*V.pixelRatio,ft*V.pixelRatio]}_computeTextWidth(at,V){let Q=0;for(const H of this._textLines)Q=Math.max(Q,at.measureText(H).width);const tt=V.font;return("italic"===tt.style||"oblique"===tt.style||"string"==typeof tt.weight&&("bold"===tt.weight||"bolder"===tt.weight)||"number"==typeof tt.weight&&tt.weight>600)&&(Q+=.3*at.measureText("w").width),Q+=2*this._parameters.halo.size,Math.round(Q)}_computeLineHeight(){let at=1.275*this._parameters.size;const V=this._parameters.font.decoration;return V&&"underline"===V&&(at*=1.3),Math.round(at+2*this._parameters.halo.size)}_renderDecoration(at,V,Q,tt,H,ft){const gt=.9*this._lineHeight,E="bold"===H?.06:"bolder"===H?.09:.04;switch(at.textAlign){case"center":V-=this._renderedWidth/2;break;case"right":V-=this._renderedWidth}const O=at.textBaseline;if("underline"===tt)switch(O){case"top":Q+=gt;break;case"middle":Q+=gt/2}else if("line-through"===tt)switch(O){case"top":Q+=gt/1.5;break;case"middle":Q+=gt/3}const ht=ft?1.5*ft:Math.ceil(gt*E);at.save(),at.beginPath(),at.strokeStyle=at.fillStyle,at.lineWidth=ht,at.moveTo(V-this._lineThroughWidthOffset,Q),at.lineTo(V+this._renderedWidth+2*this._lineThroughWidthOffset,Q),at.stroke(),at.restore()}}},61850:(ae,Wt,G)=>{G.d(Wt,{S:()=>C,c:()=>yt});var At=G(71670),nt=G(25764),pt=G(36416),mt=G(88684),Ot=G(28191),L=G(53661),at=G(55798),V=G(3758),Q=G(77238),tt=G(77213),H=G(20877);const ft=.05,E=new Set(["StartTimeOffset","Duration","RepeatDelay"]);function O(n,P){return E.has(P)?function gt(n){return Math.max(Math.round(n/ft),1)*ft}(n):n}var ht=G(79905),A=G(2047),St=G(46179),vt=G(13763),bt=G(80696),It=G(5934);const Rt=Ot.Z.getLogger("esri.symbols.cim.cimAnalyzer");function D(n){switch(n){case"Butt":return H.RL.BUTT;case"Square":return H.RL.SQUARE;default:return H.RL.ROUND}}function it(n){switch(n){case"Bevel":return H.AH.BEVEL;case"Miter":return H.AH.MITER;default:return H.AH.ROUND}}function Mt(n,P,m,v){let M;n[P]?M=n[P]:(M={},n[P]=M),M[m]=v}function zt(n){const P=n.markerPlacement;return P&&P.angleToLine?H.v2.MAP:H.v2.SCREEN}function yt(n,P,m,v,M){return Tt.apply(this,arguments)}function Tt(){return(Tt=(0,At.Z)(function*(n,P,m,v,M){const U=v??[];if(!n)return U;let J,X;const T={};if("CIMSymbolReference"!==n.type)return Rt.error("Expect cim type to be 'CIMSymbolReference'"),U;if(J=n.symbol,X=n.primitiveOverrides,X){const $=[];for(const ot of X){const st=ot.valueExpressionInfo;if(st&&P){const Lt=(0,Q.Yi)(st.expression,P.spatialReference,P.fields).then(Et=>{(0,L.Wi)(Et)||Mt(T,ot.primitiveName,ot.propertyName,Et)});$.push(Lt)}else null!=ot.value&&Mt(T,ot.primitiveName,ot.propertyName,ot.value)}$.length>0&&(yield Promise.all($))}const Y=[];switch(tt.B$.fetchResources(J,m,Y),Y.length>0&&(yield Promise.all(Y)),J?.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":!function _t(n,P,m,v,M,U,J){if(!n)return;const X=n.symbolLayers;if(!X)return;const T=n.effects;let Y=H.v2.SCREEN;const $=tt.B$.getSize(n)??0;"CIMPointSymbol"===n.type&&"Map"===n.angleAlignment&&(Y=H.v2.MAP);let ot=X.length;for(;ot--;){const st=X[ot];if(!st||!1===st.enable)continue;let ct;T&&T.length&&(ct=[...T]);const Lt=st.effects;Lt&&Lt.length&&(T?ct.push(...Lt):ct=[...Lt]);const Et=[];let wt;tt.E0.findEffectOverrides(ct,P,Et),wt=Et.length>0?Pt(ct,Et,m,v):ct;const Dt=[];switch(tt.E0.findApplicableOverrides(st,P,Dt),st.type){case"CIMSolidFill":B(st,wt,m,Dt,v,M);break;case"CIMPictureFill":q(st,wt,m,Dt,v,U,M);break;case"CIMHatchFill":j(st,wt,m,Dt,v,M);break;case"CIMGradientFill":Z(st,wt,m,Dt,v,M);break;case"CIMSolidStroke":rt(st,wt,m,Dt,v,M,"CIMPolygonSymbol"===n.type,$);break;case"CIMPictureStroke":dt(st,wt,m,Dt,v,M,"CIMPolygonSymbol"===n.type,$);break;case"CIMGradientStroke":Nt(st,wt,m,Dt,v,M,"CIMPolygonSymbol"===n.type,$);break;case"CIMCharacterMarker":if(kt(st,wt,m,Dt,v,M))break;break;case"CIMPictureMarker":if(kt(st,wt,m,Dt,v,M))break;"CIMLineSymbol"===n.type&&(Y=zt(st)),Gt(st,wt,m,Dt,v,U,M,Y,$);break;case"CIMVectorMarker":if(kt(st,wt,m,Dt,v,M))break;"CIMLineSymbol"===n.type&&(Y=zt(st)),Xt(st,wt,m,Dt,v,M,U,Y,$,J);break;default:Rt.error("Cannot analyze CIM layer",st.type)}}}(J,X,T,P,U,m,!!M)}return U})).apply(this,arguments)}function B(n,P,m,v,M,U){const J=n.primitiveName,X=(0,A.NO)(n.color),[T,Y]=w(v,J,P,null,null),$=(0,V.hP)(JSON.stringify(n)+Y).toString();U.push({type:"fill",templateHash:$,materialHash:T?()=>$:$,cim:n,materialOverrides:null,colorLocked:!!n.colorLocked,color:x(J,m,"Color",M,X,F),height:0,angle:0,offsetX:0,offsetY:0,scaleX:1,effects:P,applyRandomOffset:!1,sampleAlphaOnly:!0})}function q(n,P,m,v,M,U,J){const X=n.primitiveName,T=(0,A.cO)(n),[Y,$]=w(v,X,P,null,null),ot=(0,V.hP)(JSON.stringify(n)+$).toString(),st=(0,V.hP)(`${n.url}${JSON.stringify(n.colorSubstitutions)}`).toString();let ct=(0,A.NA)(n.scaleX);if("width"in n&&"number"==typeof n.width){const Lt=n.width;let Et=1;const wt=U.getResource(n.url);(0,L.pC)(wt)&&(Et=wt.width/wt.height),ct/=Et*(n.height/Lt)}J.push({type:"fill",templateHash:ot,materialHash:Y?()=>st:st,cim:n,materialOverrides:null,colorLocked:!!n.colorLocked,effects:P,color:x(X,m,"TintColor",M,T,F),height:x(X,m,"Height",M,n.height),scaleX:x(X,m,"ScaleX",M,ct),angle:x(X,m,"Rotation",M,(0,A.NA)(n.rotation)),offsetX:x(X,m,"OffsetX",M,(0,A.NA)(n.offsetX)),offsetY:x(X,m,"OffsetY",M,(0,A.NA)(n.offsetY)),url:n.url,applyRandomOffset:!1,sampleAlphaOnly:!1})}function j(n,P,m,v,M,U){const J=["Rotation","OffsetX","OffsetY"],X=v.filter(wt=>wt.primitiveName!==n.primitiveName||!J.includes(wt.propertyName)),T=n.primitiveName;let[Y,$]=w(v,T,P,null,null);const ot=(0,V.hP)(JSON.stringify(n)+$).toString(),st=(0,V.hP)(`${n.separation}${JSON.stringify(n.lineSymbol)}`).toString();let ct={r:255,g:255,b:255,a:1},Lt=!1;const Et=n.lineSymbol?.symbolLayers?.find(wt=>"CIMSolidStroke"===wt.type&&null!=m[wt.primitiveName]?.Color);if(Et){ct=(0,A.NO)(Et.color),ct=x(Et.primitiveName,m,"Color",M,ct,F);const wt="function"==typeof ct;Y=Y||wt,Lt=null!=Et.color||wt}U.push({type:"fill",templateHash:ot,materialHash:Y?g(st,m,X,M):st,cim:n,materialOverrides:X,colorLocked:!!n.colorLocked,effects:P,color:ct,height:x(T,m,"Separation",M,n.separation),scaleX:1,angle:x(T,m,"Rotation",M,(0,A.NA)(n.rotation)),offsetX:x(T,m,"OffsetX",M,(0,A.NA)(n.offsetX)),offsetY:x(T,m,"OffsetY",M,(0,A.NA)(n.offsetY)),applyRandomOffset:!1,sampleAlphaOnly:!0,hasUnresolvedReplacementColor:!Lt})}function Z(n,P,m,v,M,U){const J=n.primitiveName,[X,T]=w(v,J,P,null,null),Y=(0,V.hP)(JSON.stringify(n)+T).toString();U.push({type:"fill",templateHash:Y,materialHash:X?g(Y,m,v,M):Y,cim:n,materialOverrides:null,colorLocked:!!n.colorLocked,effects:P,color:{r:128,g:128,b:128,a:1},height:0,angle:0,offsetX:0,offsetY:0,scaleX:1,applyRandomOffset:!1,sampleAlphaOnly:!1})}function rt(n,P,m,v,M,U,J,X){const T=n.primitiveName,Y=(0,A.NO)(n.color),$=null!=n.width?n.width:4,ot=D(n.capStyle),st=it(n.joinStyle),ct=n.miterLimit,[Lt,Et]=w(v,T,P,null,null),wt=(0,V.hP)(JSON.stringify(n)+Et).toString();let Dt,Ht;if(P&&P instanceof Array&&P.length>0){const jt=P[P.length-1];if("CIMGeometricEffectDashes"===jt.type&&"NoConstraint"===jt.lineDashEnding&&null===jt.offsetAlongLine){const Zt=(P=[...P]).pop();Dt=Zt.dashTemplate,Ht=Zt.scaleDash}}U.push({type:"line",templateHash:wt,materialHash:Lt?()=>wt:wt,cim:n,materialOverrides:null,isOutline:J,colorLocked:!!n.colorLocked,effects:P,color:x(T,m,"Color",M,Y,F),width:x(T,m,"Width",M,$),cap:x(T,m,"CapStyle",M,ot),join:x(T,m,"JoinStyle",M,st),miterLimit:ct&&x(T,m,"MiterLimit",M,ct),referenceWidth:X,zOrder:k(n.name),dashTemplate:Dt,scaleDash:Ht,sampleAlphaOnly:!0})}function dt(n,P,m,v,M,U,J,X){const T=(0,V.hP)(`${n.url}${JSON.stringify(n.colorSubstitutions)}`).toString(),Y=n.primitiveName,$=(0,A.cO)(n),ot=null!=n.width?n.width:4,st=D(n.capStyle),ct=it(n.joinStyle),Lt=n.miterLimit,[Et,wt]=w(v,Y,P,null,null),Dt=(0,V.hP)(JSON.stringify(n)+wt).toString();U.push({type:"line",templateHash:Dt,materialHash:Et?()=>T:T,cim:n,materialOverrides:null,isOutline:J,colorLocked:!!n.colorLocked,effects:P,color:x(Y,m,"TintColor",M,$,F),width:x(Y,m,"Width",M,ot),cap:x(Y,m,"CapStyle",M,st),join:x(Y,m,"JoinStyle",M,ct),miterLimit:Lt&&x(Y,m,"MiterLimit",M,Lt),referenceWidth:X,zOrder:k(n.name),dashTemplate:null,scaleDash:!1,url:n.url,sampleAlphaOnly:!1})}function Nt(n,P,m,v,M,U,J,X){const T=n.primitiveName,Y=null!=n.width?n.width:4,$=D(n.capStyle),ot=it(n.joinStyle),st=n.miterLimit,[ct,Lt]=w(v,T,P,null,null),Et=(0,V.hP)(JSON.stringify(n)+Lt).toString();U.push({type:"line",templateHash:Et,materialHash:ct?g(Et,m,v,M):Et,cim:n,materialOverrides:null,isOutline:J,colorLocked:!!n.colorLocked,effects:P,color:{r:128,g:128,b:128,a:1},width:x(T,m,"Width",M,Y),cap:x(T,m,"CapStyle",M,$),join:x(T,m,"JoinStyle",M,ot),miterLimit:st&&x(T,m,"MiterLimit",M,st),referenceWidth:X,zOrder:k(n.name),dashTemplate:null,scaleDash:!1,sampleAlphaOnly:!1})}function kt(n,P,m,v,M,U){const{markerPlacement:J,type:X}=n;if(!J||"CIMMarkerPlacementInsidePolygon"!==J.type)return!1;if("CIMVectorMarker"===X||"CIMPictureMarker"===X){const Bt=n.primitiveName;if(Bt){const[Jt,Qt]=w(v,Bt,P,null,null);if(Jt)return!1}const ne=J.primitiveName;if(ne){const[Jt,Qt]=w(v,ne,P,null,null);if(Jt)return!1}if("CIMVectorMarker"===X){const{markerGraphics:Jt}=n;if(Jt)for(const Qt of Jt){const{symbol:$t}=Qt;if("CIMPolygonSymbol"===$t?.type&&$t.symbolLayers){const{symbolLayers:Yt}=$t;for(const ee of Yt)if("CIMSolidStroke"===ee.type)return!1}}}else{const{animatedSymbolProperties:Jt}=n;if(Jt)return!1}}const T=J,Y=Math.abs(T.stepX),$=Math.abs(T.stepY);if(0===Y||0===$)return!0;const ot=["Rotation","OffsetX","OffsetY"],st=v.filter(Bt=>Bt.primitiveName!==n.primitiveName||!ot.includes(Bt.propertyName)),ct="url"in n&&"string"==typeof n.url?n.url:void 0,[Lt,Et]=w(v,T.primitiveName,P,null,null),wt=(0,V.hP)(JSON.stringify(n)+Et).toString();let Dt,Ht,jt=null;if("Random"===J.gridType){const Bt=(0,at.Wz)(bt.C1),ne=Math.max(Math.floor(Bt/Y),1),Jt=Math.max(Math.floor(Bt/$),1);Dt=$*Jt,jt=Qt=>Qt?Qt*Jt:0,Ht=ne*Y/Dt}else J.shiftOddRows?(Dt=2*$,jt=Bt=>Bt?2*Bt:0,Ht=Y/$*.5):(Dt=$,jt=null,Ht=Y/$);const Zt=(0,A.cO)(n);return U.push({type:"fill",templateHash:wt,materialHash:Lt?g(wt,m,st,M):wt,cim:n,materialOverrides:st,colorLocked:!!n.colorLocked,effects:P,color:x(T.primitiveName,m,"TintColor",M,Zt,F),height:x(T.primitiveName,m,"StepY",M,Dt,jt),scaleX:Ht,angle:x(T.primitiveName,m,"GridAngle",M,T.gridAngle),offsetX:x(T.primitiveName,m,"OffsetX",M,(0,A.NA)(T.offsetX)),offsetY:x(T.primitiveName,m,"OffsetY",M,(0,A.NA)(T.offsetY)),url:ct,applyRandomOffset:"Random"===J.gridType,sampleAlphaOnly:!ct,hasUnresolvedReplacementColor:!0}),!0}function Gt(n,P,m,v,M,U,J,X,T){const Y=n.primitiveName,$=(0,A.NA)(n.size);let ot=(0,A.NA)(n.scaleX,1);const st=(0,A.NA)(n.rotation),ct=(0,A.NA)(n.offsetX),Lt=(0,A.NA)(n.offsetY),Et=(0,A.cO)(n),wt=(0,V.hP)(`${n.url}${JSON.stringify(n.colorSubstitutions)}${JSON.stringify(n.animatedSymbolProperties)}`).toString(),Dt=z(n.markerPlacement,v,m,M),Ht=function u(n,P,m,v){const M=[];if(tt.E0.findApplicableOverrides(n,P,M),null==n||0===M.length)return n;for(const U of M)if(U.valueExpressionInfo&&v?.geometryType){const J=m[U.primitiveName]&&m[U.primitiveName][U.propertyName];J instanceof Q.mz&&(U.fn=(X,T,Y)=>(0,vt.Z)(J,X,{$view:Y},v.geometryType,T))}return(U,J,X)=>{for(const $ of M)$.fn&&($.value=$.fn(U,J,X));const T=(0,mt.d9)(n),Y=n.primitiveName;for(const $ of M)if($.primitiveName===Y){const ot=et($.propertyName);if(null!=$.value){const st=O($.value,$.propertyName);st!==T[ot]&&(T[ot]=st)}}return T}}(n.animatedSymbolProperties,v,m,M),[jt,Zt]=w(v,Y,P,Dt,Ht),Bt=(0,V.hP)(JSON.stringify(n)+Zt).toString(),ne=n.anchorPoint??{x:0,y:0};if("width"in n&&"number"==typeof n.width){const $t=n.width;let Yt=1;const ee=U.getResource(n.url);(0,L.pC)(ee)&&(Yt=ee.width/ee.height),ot/=Yt*($/$t)}function Jt($t,Yt){return(0,L.pC)(Ht)?(0,A.hf)(Ht,$t,Yt):null}J.push({type:"marker",templateHash:Bt,materialHash:n.animatedSymbolProperties&&!0===n.animatedSymbolProperties.randomizeStartTime?($t,Yt,ee,ce)=>{const le=(0,It.$)(ce??0),me=Jt($t,Yt);return wt+`-MATERIALGROUP(${le})-ASP(${JSON.stringify(me)})`}:jt?($t,Yt)=>{const ee=Jt($t,Yt);return wt+`-ASP(${JSON.stringify(ee)})`}:wt,cim:n,materialOverrides:null,colorLocked:!!n.colorLocked,effects:P,scaleSymbolsProportionally:!1,alignment:X,size:x(Y,m,"Size",M,$),scaleX:x(Y,m,"ScaleX",M,ot),rotation:x(Y,m,"Rotation",M,st),offsetX:x(Y,m,"OffsetX",M,ct),offsetY:x(Y,m,"OffsetY",M,Lt),color:x(Y,m,"TintColor",M,Et,F),anchorPoint:{x:ne.x,y:-ne.y},isAbsoluteAnchorPoint:"Relative"!==n.anchorPointUnits,outlineColor:{r:0,g:0,b:0,a:0},outlineWidth:0,frameHeight:0,rotateClockwise:!!n.rotateClockwise,referenceSize:T,sizeRatio:1,markerPlacement:Dt,url:n.url,animatedSymbolProperties:Ht})}function Xt(n,P,m,v,M,U,J,X,T,Y){const $=n.markerGraphics;if(!$)return;let ot=0;if(n.scaleSymbolsProportionally){const ct=n.frame;ct&&(ot=ct.ymax-ct.ymin)}const st=z(n.markerPlacement,v,m,M);for(const ct of $)if(ct){const Lt=ct.symbol;if(!Lt)continue;switch(Lt.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":a(n,P,st,null,ct,v,m,M,U,J,X,T,ot,!!Y);break;case"CIMTextSymbol":lt(n,P,st,ct,m,v,M,U,X,T,ot)}}}function lt(n,P,m,v,M,U,J,X,T,Y,$){tt.E0.findApplicableOverrides(v,U,[]);const st=v.geometry;if(!("x"in st)||!("y"in st))return;const ct=v.symbol,Lt=(0,A.BX)(ct),Et=(0,A.wi)(ct.fontStyleName),wt=(0,pt.BN)(ct.fontFamilyName);ct.font={family:wt,decoration:Lt,...Et};const Dt=n.frame,Ht=st.x-.5*(Dt.xmin+Dt.xmax),jt=st.y-.5*(Dt.ymin+Dt.ymax),Zt=n.size/$,Bt=n.primitiveName,ne=(0,A.NA)(ct.height)*Zt,Jt=(0,A.NA)(ct.angle),Qt=(0,A.NA)(n.offsetX)+((0,A.NA)(ct.offsetX)+Ht)*Zt,$t=(0,A.NA)(n.offsetY)+((0,A.NA)(ct.offsetY)+jt)*Zt,Yt=(0,A.NO)((0,A.W7)(ct));let ee=(0,A.NO)((0,A.$Z)(ct)),ce=(0,A.F)(ct)??0;ce||(ee=(0,A.NO)((0,A.W7)(ct.haloSymbol)),ct.haloSize&&(ce=ct.haloSize*Zt));let le=null,me=null,Pe=0;if(ct.callout&&"CIMBackgroundCallout"===ct.callout.type){const ye=ct.callout;if(ye.backgroundSymbol){const fe=ye.backgroundSymbol.symbolLayers;if(fe)for(const re of fe)"CIMSolidFill"===re.type?le=(0,A.NO)(re.color):"CIMSolidStroke"===re.type&&(me=(0,A.NO)(re.color),Pe=(0,A.NA)(re.width))}}const[_e,ue]=w(U,Bt,P,m,null),ge=JSON.stringify(n.effects)+Number(n.colorLocked).toString()+JSON.stringify(n.anchorPoint)+n.anchorPointUnits+JSON.stringify(n.markerPlacement)+n.size.toString(),Me=(0,V.hP)(JSON.stringify(v)+ge+ue).toString();let se=x(v.primitiveName,M,"TextString",J,v.textString??"",A.QI,ct.textCase);if(null==se)return;const{fontStyleName:te}=ct,ie=wt+(te?"-"+te.toLowerCase():"-regular"),pe=ie;"string"==typeof se&&se.includes("[")&&ct.fieldMap&&(se=(0,A.Qs)(ct.fieldMap,se,ct.textCase)),X.push({type:"text",templateHash:Me,materialHash:_e||"function"==typeof se||se.match(/\[(.*?)\]/)?(ye,fe,re)=>pe+"-"+(0,A.hf)(se,ye,fe,re):pe+"-"+(0,V.hP)(se),cim:ct,materialOverrides:null,colorLocked:!!n.colorLocked,effects:P,alignment:T,anchorPoint:{x:n.anchorPoint?n.anchorPoint.x:0,y:n.anchorPoint?n.anchorPoint.y:0},isAbsoluteAnchorPoint:"Relative"!==n.anchorPointUnits,fontName:ie,decoration:Lt,weight:x(Bt,M,"Weight",J,Et.weight),style:x(Bt,M,"Size",J,Et.style),size:x(Bt,M,"Size",J,ne),angle:x(Bt,M,"Rotation",J,Jt),offsetX:x(Bt,M,"OffsetX",J,Qt),offsetY:x(Bt,M,"OffsetY",J,$t),horizontalAlignment:(0,A.X_)(ct.horizontalAlignment),verticalAlignment:(0,A.FG)(ct.verticalAlignment),text:se,color:Yt,outlineColor:ee,outlineSize:ce,backgroundColor:le,borderLineColor:me,borderLineWidth:Pe,referenceSize:Y,sizeRatio:1,markerPlacement:m})}function a(n,P,m,v,M,U,J,X,T,Y,$,ot,st,ct){const Lt=M.symbol,Et=Lt.symbolLayers;if(!Et)return;if(ct)return void I(n,P,m,v,M,J,U,X,T,Y,$,ot,st);let wt=Et.length;if(S(Et))return void function _(n,P,m,v,M,U,J,X,T,Y,$,ot,st){const ct=M.geometry,Lt=U[0],Et=U[1],wt=(0,ht.bk)(ct);if(!wt)return;const Dt="Relative"!==n.anchorPointUnits,[Ht,jt,Zt]=(0,ht.UV)(wt,n.frame,n.size,n.anchorPoint,Dt),Bt={type:"sdf",geom:ct,asFill:!0},ne=n.primitiveName,Jt=(0,A.NA)(n.size),Qt=(0,A.NA)(n.rotation),$t=(0,A.NA)(n.offsetX),Yt=(0,A.NA)(n.offsetY),ee=Et.path,ce=Et.primitiveName,le=Lt.primitiveName,me=(0,A.NO)((0,A.W7)(Et)),Pe=(0,A.NO)((0,A.$Z)(Lt)),_e=(0,A.F)(Lt)??0;let ue=!1,ge="";for(const ie of J)ie.primitiveName!==ce&&ie.primitiveName!==le&&ie.primitiveName!==ne||(void 0!==ie.value?ge+=`-${ie.primitiveName}-${ie.propertyName}-${JSON.stringify(ie.value)}`:ie.valueExpressionInfo&&(ue=!0));(0,L.pC)(m)&&"function"==typeof m&&(ue=!0);const Me=JSON.stringify({...n,markerGraphics:null}),se=(0,V.hP)(JSON.stringify(Bt)+ee).toString(),te={type:"marker",templateHash:(0,V.hP)(JSON.stringify(M)+JSON.stringify(Et)+JSON.stringify(Lt)+Me+ge).toString(),materialHash:ue?()=>se:se,cim:Bt,materialOverrides:null,colorLocked:!!n.colorLocked,effects:P,scaleSymbolsProportionally:!!n.scaleSymbolsProportionally,alignment:$,anchorPoint:{x:jt,y:Zt},isAbsoluteAnchorPoint:Dt,size:x(n.primitiveName,X,"Size",T,Jt),rotation:x(n.primitiveName,X,"Rotation",T,Qt),offsetX:x(n.primitiveName,X,"OffsetX",T,$t),offsetY:x(n.primitiveName,X,"OffsetY",T,Yt),scaleX:1,frameHeight:st,rotateClockwise:!!n.rotateClockwise,referenceSize:ot,sizeRatio:Ht,color:x(ce,X,"Color",T,me,F),outlineColor:x(le,X,"Color",T,Pe,F),outlineWidth:x(le,X,"Width",T,_e),markerPlacement:m,path:ee,animatedSymbolProperties:v};Y.push(te)}(n,P,m,v,M,Et,U,J,X,T,$,ot,st);const Dt=St.j.applyEffects(Lt.effects,M.geometry,Y.geometryEngine);if(Dt)for(;wt--;){const Ht=Et[wt];if(Ht&&!1!==Ht.enable)switch(Ht.type){case"CIMSolidFill":case"CIMSolidStroke":{const jt=St.j.applyEffects(Ht.effects,Dt,Y.geometryEngine),Zt=(0,ht.bk)(jt);if(!Zt)continue;const Bt="Relative"!==n.anchorPointUnits,[ne,Jt,Qt]=(0,ht.UV)(Zt,n.frame,n.size,n.anchorPoint,Bt),$t="CIMSolidFill"===Ht.type,Yt={type:"sdf",geom:jt,asFill:$t},ee=n.primitiveName,ce=(0,A.NA)(n.size)??10,le=(0,A.NA)(n.rotation),me=(0,A.NA)(n.offsetX),Pe=(0,A.NA)(n.offsetY),_e=Ht.path,ue=Ht.primitiveName,ge=(0,A.NO)($t?(0,A.W7)(Ht):(0,A.$Z)(Ht)),Me=$t?{r:0,g:0,b:0,a:0}:(0,A.NO)((0,A.$Z)(Ht)),se=(0,A.F)(Ht)??0;if(!$t&&!se)break;let te=!1,ie="";for(const re of U)re.primitiveName!==ue&&re.primitiveName!==ee||(void 0!==re.value?ie+=`-${re.primitiveName}-${re.propertyName}-${JSON.stringify(re.value)}`:re.valueExpressionInfo&&(te=!0));((0,L.pC)(P)&&"function"==typeof P||(0,L.pC)(m)&&"function"==typeof m)&&(te=!0);const pe=JSON.stringify({...n,markerGraphics:null}),ye=(0,V.hP)(JSON.stringify(Yt)+_e).toString(),fe={type:"marker",templateHash:(0,V.hP)(JSON.stringify(M)+JSON.stringify(Ht)+pe+ie).toString(),materialHash:te?()=>ye:ye,cim:Yt,materialOverrides:null,colorLocked:!!n.colorLocked,effects:P,scaleSymbolsProportionally:!!n.scaleSymbolsProportionally,alignment:$,anchorPoint:{x:Jt,y:Qt},isAbsoluteAnchorPoint:Bt,size:x(n.primitiveName,J,"Size",X,ce),rotation:x(n.primitiveName,J,"Rotation",X,le),offsetX:x(n.primitiveName,J,"OffsetX",X,me),offsetY:x(n.primitiveName,J,"OffsetY",X,Pe),scaleX:1,frameHeight:st,rotateClockwise:!!n.rotateClockwise,referenceSize:ot,sizeRatio:ne,color:x(ue,J,"Color",X,ge,F),outlineColor:x(ue,J,"Color",X,Me,F),outlineWidth:x(ue,J,"Width",X,se),markerPlacement:m,animatedSymbolProperties:v,path:_e};T.push(fe);break}default:I(n,P,m,v,M,J,U,X,T,Y,$,ot,st)}}}function I(n,P,m,v,M,U,J,X,T,Y,$,ot,st){const ct=function b(n,P){return{type:n.type,enable:!0,name:n.name,colorLocked:n.colorLocked,primitiveName:n.primitiveName,anchorPoint:n.anchorPoint,anchorPointUnits:n.anchorPointUnits,offsetX:0,offsetY:0,rotateClockwise:n.rotateClockwise,rotation:0,size:n.size,billboardMode3D:n.billboardMode3D,depth3D:n.depth3D,frame:n.frame,markerGraphics:[P],scaleSymbolsProportionally:n.scaleSymbolsProportionally,respectFrame:n.respectFrame,clippingPath:n.clippingPath}}(n,M),Lt=["Rotation","OffsetX","OffsetY"],Et=J.filter(Yt=>Yt.primitiveName!==n.primitiveName||!Lt.includes(Yt.propertyName));let wt="";for(const Yt of J)void 0!==Yt.value&&(wt+=`-${Yt.primitiveName}-${Yt.propertyName}-${JSON.stringify(Yt.value)}`);const[Dt,Ht,jt]=tt.B$.getTextureAnchor(ct,Y),Zt=n.primitiveName,Bt=(0,A.NA)(n.rotation),ne=(0,A.NA)(n.offsetX),Jt=(0,A.NA)(n.offsetY),Qt=(0,V.hP)(JSON.stringify(ct)+wt).toString(),$t={type:"marker",templateHash:Qt,materialHash:Et.length>0||(0,L.pC)(P)&&"function"==typeof P?g(Qt,U,Et,X):Qt,cim:ct,materialOverrides:Et,colorLocked:!!n.colorLocked,effects:P,scaleSymbolsProportionally:!!n.scaleSymbolsProportionally,alignment:$,anchorPoint:{x:Dt,y:Ht},isAbsoluteAnchorPoint:!1,size:(0,A.NA)(n.size),rotation:x(Zt,U,"Rotation",X,Bt),offsetX:x(Zt,U,"OffsetX",X,ne),offsetY:x(Zt,U,"OffsetY",X,Jt),color:{r:255,g:255,b:255,a:1},outlineColor:{r:0,g:0,b:0,a:0},outlineWidth:0,scaleX:1,frameHeight:st,rotateClockwise:!!n.rotateClockwise,referenceSize:ot,sizeRatio:jt/(0,at.F2)(n.size),markerPlacement:m,animatedSymbolProperties:v,avoidSDFRasterization:!0};T.push($t)}function k(n){if(n&&0===n.indexOf("Level_")){const P=parseInt(n.substr(6),10);if(!isNaN(P))return P}return 0}function F(n){if(!n||0===n.length)return null;const P=new nt.Z(n).toRgba();return{r:P[0],g:P[1],b:P[2],a:P[3]}}function x(n,P,m,v,M,U,J){if(null==n)return M;const X=P[n];if(X){const T=X[m];if("string"==typeof T||"number"==typeof T||T instanceof Array)return U?U.call(null,T,J):T;if(null!=T&&T instanceof Q.mz&&v?.geometryType)return(Y,$,ot)=>{let st=(0,vt.Z)(T,Y,{$view:ot},v.geometryType,$);return null!==st&&U&&(st=U.call(null,st,J)),null!==st?st:M}}return M}function et(n){return n&&n.charAt(0).toLowerCase()+n.substr(1)}function Pt(n,P,m,v){for(const M of P)if(M.valueExpressionInfo&&v?.geometryType){const U=m[M.primitiveName]&&m[M.primitiveName][M.propertyName];U instanceof Q.mz&&(M.fn=(J,X,T)=>(0,vt.Z)(U,J,{$view:T},v.geometryType,X))}return(M,U,J)=>{for(const T of P)T.fn&&(T.value=T.fn(M,U,J));const X=[];for(let T of n){const Y=T?.primitiveName;if(Y){let $=!1;for(const ot of P)if(ot.primitiveName===Y){const st=et(ot.propertyName);null!=ot.value&&ot.value!==T[st]&&($||(T=(0,mt.d9)(T),$=!0),T[st]=ot.value)}}X.push(T)}return X}}function z(n,P,m,v){const M=[];if(tt.E0.findApplicableOverrides(n,P,M),null==n||0===M.length)return n;for(const U of M)if(U.valueExpressionInfo&&v?.geometryType){const J=m[U.primitiveName]&&m[U.primitiveName][U.propertyName];J instanceof Q.mz&&(U.fn=(X,T,Y)=>(0,vt.Z)(J,X,{$view:Y},v.geometryType,T))}return(U,J,X)=>{for(const $ of M)$.fn&&($.value=$.fn(U,J,X));const T=(0,mt.d9)(n),Y=n.primitiveName;for(const $ of M)if($.primitiveName===Y){const ot=et($.propertyName);null!=$.value&&$.value!==T[ot]&&(T[ot]=$.value)}return T}}function g(n,P,m,v){for(const M of m)if(M.valueExpressionInfo&&v?.geometryType){const U=P[M.primitiveName]&&P[M.primitiveName][M.propertyName];U instanceof Q.mz&&(M.fn=(J,X,T)=>(0,vt.Z)(U,J,{$view:T},v.geometryType,X))}return(M,U,J)=>{for(const X of m)X.fn&&(X.value=X.fn(M,U,J));return(0,V.hP)(n+tt.E0.buildOverrideKey(m)).toString()}}function C(n,P){if(!P||0===P.length)return n;const m=(0,mt.d9)(n);return tt.E0.applyOverrides(m,P),m}function w(n,P,m,v,M){let U=!1,J="";for(const X of n)X.primitiveName===P&&(void 0!==X.value?J+=`-${X.primitiveName}-${X.propertyName}-${JSON.stringify(X.value)}`:X.valueExpressionInfo&&(U=!0));return(0,L.pC)(m)&&"function"==typeof m&&(U=!0),(0,L.pC)(v)&&"function"==typeof v&&(U=!0),(0,L.pC)(M)&&"function"==typeof M&&(U=!0),[U,J]}const S=n=>n&&2===n.length&&n[0].enable&&n[1].enable&&"CIMSolidStroke"===n[0].type&&"CIMSolidFill"===n[1].type&&!n[0].effects&&!n[1].effects},46179:(ae,Wt,G)=>{G.d(Wt,{j:()=>L});var At=G(71182),nt=G(63291),pt=G(23975),mt=G(5780);class L{static executeEffects(V,Q,tt,H){const ft=(0,nt.GP)(Q);let E=new pt.MU(ft);for(const O of V){const ht=(0,mt.h)(O);ht&&(E=ht.execute(E,O,1.3333333333333333,tt,H))}return E}static next(V){const Q=V.next();return(0,nt.wp)(Q),Q}static applyEffects(V,Q,tt){if(!V)return Q;let H=new pt.MU(Q);for(const E of V){const O=(0,mt.h)(E);O&&(H=O.execute(H,E,1,null,tt))}let ft,gt=null;for(;ft=H.next();)gt?(0,At.l9)(gt)?(0,At.l9)(ft)&&gt.paths.push(...ft.paths):(0,At.oU)(gt)&&(0,At.oU)(ft)&&gt.rings.push(...ft.rings):gt=ft;return gt}}},13763:(ae,Wt,G)=>{G.d(Wt,{Z:()=>Ot});var At=G(32995),nt=G(28191),pt=G(53661),mt=G(6099);function Ot(Q,tt,H,ft,gt){if((0,pt.Wi)(Q))return null;const E=Q.referencesGeometry()&&gt?function at(Q,tt,H){const{transform:ft,hasZ:gt,hasM:E}=H;L.has(tt)||L.set(tt,function V(Q){const tt={};switch(Q){case"esriGeometryPoint":return(H,ft,gt,E)=>(0,mt.U1)(ft,tt,H,gt,E);case"esriGeometryPolygon":return(H,ft,gt,E)=>(0,mt.Ie)(ft,tt,H,gt,E);case"esriGeometryPolyline":return(H,ft,gt,E)=>(0,mt.G6)(ft,tt,H,gt,E);case"esriGeometryMultipoint":return(H,ft,gt,E)=>(0,mt.J9)(ft,tt,H,gt,E);default:return nt.Z.getLogger("esri.views.2d.support.arcadeOnDemand").error(new At.Z("mapview-arcade",`Unable to handle geometryType: ${Q}`)),H=>H}}(tt));const O=L.get(tt)(Q.geometry,ft,gt,E);return{...Q,geometry:O}}(tt,ft,gt):tt,O=Q.repurposeFeature(E);try{return Q.evaluate({...H,$feature:O})}catch(ht){return nt.Z.getLogger("esri.views.2d.support.arcadeOnDemand").warn("Feature arcade evaluation failed:",ht),null}}const L=new Map},5934:(ae,Wt,G)=>{G.d(Wt,{$:()=>pt,f:()=>nt});var At=G(3758);function nt(L,at){let V;if("string"==typeof L)V=(0,At.hP)(L+`-seed(${at})`);else{let Q=12;V=L^at;do{V=107*(V>>8^V)+Q|0}while(0!=--Q)}return(1+V/(1<<31))/2}function pt(L){return Math.floor(nt(L,mt)*Ot)}const mt=53290320,Ot=10},18659:(ae,Wt,G)=>{G.d(Wt,{Nr:()=>Tt});var At=G(55798),nt=G(53072),pt=G(80309),mt=G(80775),Ot=G(12288),L=G(81925),at=G(72375),V=G(26057);class Q{constructor(B,q,j,Z){this.center=(0,Ot.f)(B,q),this.centerT=(0,Ot.c)(),this.halfWidth=j/2,this.halfHeight=Z/2,this.width=j,this.height=Z}get x(){return this.center[0]}get y(){return this.center[1]}get blX(){return this.center[0]+this.halfWidth}get blY(){return this.center[1]+this.halfHeight}get trX(){return this.center[0]-this.halfWidth}get trY(){return this.center[1]-this.halfHeight}get xmin(){return this.x-this.halfWidth}get xmax(){return this.x+this.halfWidth}get ymin(){return this.y-this.halfHeight}get ymax(){return this.y+this.halfHeight}set x(B){this.center[0]=B}set y(B){this.center[1]=B}clone(){return new Q(this.x,this.y,this.width,this.height)}serialize(B){return B.writeF32(this.center[0]),B.writeF32(this.center[1]),B.push(this.width),B.push(this.height),B}findCollisionDelta(B,q=4){const j=Math.abs(B.centerT[0]-this.centerT[0]),Z=Math.abs(B.centerT[1]-this.centerT[1]),Nt=Math.min((B.halfWidth+this.halfWidth+q)/j,(B.halfHeight+this.halfHeight+q)/Z);return Math.log2(Nt)}extend(B){const q=Math.min(this.xmin,B.xmin),j=Math.min(this.ymin,B.ymin),Z=Math.max(this.xmax,B.xmax)-q,rt=Math.max(this.ymax,B.ymax)-j,dt=q+Z/2,Nt=j+rt/2;this.width=Z,this.height=rt,this.halfWidth=Z/2,this.halfHeight=rt/2,this.x=dt,this.y=Nt}static deserialize(B){const q=B.readF32(),j=B.readF32(),Z=B.readInt32(),rt=B.readInt32();return new Q(q,j,Z,rt)}}const tt=26,H=4,ft=tt+H,gt=tt-6,E=3,ht=Math.PI/180;class vt{constructor(B,q,j,Z){this._rotationT=(0,pt.c)(),this._xBounds=0,this._yBounds=0,this.minZoom=0,this.maxZoom=255,this._bounds=null;const rt=j.rect,dt=new Float32Array(8);B*=Z,q*=Z;const Nt=j.code?rt.width*Z:j.metrics.width,kt=j.code?rt.height*Z:j.metrics.height;this.width=Nt,this.height=kt,dt[0]=B,dt[1]=q,dt[2]=B+Nt,dt[3]=q,dt[4]=B,dt[5]=q+kt,dt[6]=B+Nt,dt[7]=q+kt,this._data=dt,this._setTextureCoords(rt),this._scale=Z,this._mosaic=j,this.x=B,this.y=q,this.maxOffset=Math.max(B+Nt,q+kt)}get mosaic(){return this._mosaic}set angle(B){this._angle=B,(0,nt.b)(this._rotationT,-B),this._setOffsets(this._data)}get angle(){return this._angle}get xTopLeft(){return this._data[0]}get yTopLeft(){return this._data[1]}get xBottomRight(){return this._data[6]}get yBottomRight(){return this._data[7]}get texcoords(){return this._texcoords}get textureBinding(){return this._mosaic.textureBinding}get offsets(){return this._offsets||this._setOffsets(this._data),this._offsets}get char(){return String.fromCharCode(this._mosaic.code)}get code(){return this._mosaic.code}get bounds(){if(!this._bounds){const{height:B,width:q}=this._mosaic.metrics,j=q*this._scale,Z=Math.abs(B)*this._scale,rt=new Float32Array(8);rt[0]=this.x,rt[1]=this.y,rt[2]=this.x+j,rt[3]=this.y,rt[4]=this.x,rt[5]=this.y+Z,rt[6]=this.x+j,rt[7]=this.y+Z;const dt=(0,nt.m)((0,pt.c)(),this._rotationT,this._transform);(0,pt.t)(rt,rt,dt);let Nt=1/0,kt=1/0,Gt=0,Xt=0;for(let b=0;b<4;b++){const k=rt[2*b],F=rt[2*b+1];Nt=Math.min(Nt,k),kt=Math.min(kt,F),Gt=Math.max(Gt,k),Xt=Math.max(Xt,F)}const lt=Gt-Nt,a=Xt-kt;this._bounds=new Q(Nt+lt/2,kt+a/2,lt,a)}return this._bounds}setTransform(B){this._transform=B,this._offsets=null}_setOffsets(B){this._offsets||(this._offsets={upperLeft:0,upperRight:0,lowerLeft:0,lowerRight:0});const q=this._offsets,j=new Float32Array(8),Z=(0,nt.m)((0,pt.c)(),this._rotationT,this._transform);(0,pt.t)(j,B,Z),q.upperLeft=(0,at.UJ)(8*j[0],8*j[1]),q.upperRight=(0,at.UJ)(8*j[2],8*j[3]),q.lowerLeft=(0,at.UJ)(8*j[4],8*j[5]),q.lowerRight=(0,at.UJ)(8*j[6],8*j[7])}_setTextureCoords({x:B,y:q,width:j,height:Z}){this._texcoords={upperLeft:(0,at.UJ)(B,q),upperRight:(0,at.UJ)(B+j,q),lowerLeft:(0,at.UJ)(B,q+Z),lowerRight:(0,at.UJ)(B+j,q+Z)}}}const bt=(_t,B)=>({code:0,page:0,sdf:!0,rect:new V.Z(0,0,11,8),textureBinding:B,metrics:{advance:0,height:4,width:_t,left:0,top:0}});function It(_t,B){return _t.forEach(q=>(0,mt.t)(q,q,B)),{upperLeft:(0,at.UJ)(8*_t[0][0],8*_t[0][1]),upperRight:(0,at.UJ)(8*_t[1][0],8*_t[1][1]),lowerLeft:(0,at.UJ)(8*_t[2][0],8*_t[2][1]),lowerRight:(0,at.UJ)(8*_t[3][0],8*_t[3][1])}}class Rt{constructor(B,q,j){this._rotation=0,this._decorate(B,q,j),this.glyphs=B,this.bounds=this._createBounds(B),this.isMultiline=q.length>1,this._hasRotation=0!==j.angle,this._transform=this._createGlyphTransform(this.bounds,j),this._borderLineSize=j.borderLineSize,(j.borderLineSize||j.hasBackground)&&([this.bounds,this.background]=this.shapeBackground(this._transform));for(const Z of B)Z.setTransform(this._transform)}setRotation(B){if(0===B&&0===this._rotation)return;this._rotation=B;const q=this._transform,j=(0,nt.b)((0,pt.c)(),B);(0,nt.m)(q,j,q);for(const Z of this.glyphs)Z.setTransform(this._transform)}_decorate(B,q,j){if(!j.decoration||"none"===j.decoration||!B.length)return;const Z=j.scale,rt="underline"===j.decoration?ft:gt,dt=B[0].textureBinding;for(const Nt of q)B.push(new vt(Nt.startX*Z,Nt.startY*Z+rt*Z,bt((Nt.width+Nt.glyphWidthEnd)*Z,dt),1))}shapeBackground(B){const j=(1.5+(0,At.F2)(this._borderLineSize||0))/2,Z=this._borderLineSize?j:0,{xmin:rt,ymin:dt,xmax:Nt,ymax:kt,x:Gt,y:Xt,width:lt,height:a}=this.bounds,_=[rt-8,dt-8],I=[Nt+8,dt-8],b=[rt-8,kt+8],k=[Nt+8,kt+8],F=It([[_[0]-j,_[1]-j],[I[0]+j,I[1]-j],[_[0]+Z,_[1]+Z],[I[0]-Z,I[1]+Z]],B),x=It([[b[0]+Z,b[1]-Z],[k[0]-Z,k[1]-Z],[b[0]-j,b[1]+j],[k[0]+j,k[1]+j]],B),et=It([[_[0]-j,_[1]-j],[_[0]+Z,_[1]+Z],[b[0]-j,b[1]+j],[b[0]+Z,b[1]-Z]],B),Pt=It([[I[0]-Z,I[1]+Z],[I[0]+j,I[1]-j],[k[0]-Z,k[1]-Z],[k[0]+j,k[1]+j]],B),z={main:It([_,I,b,k],B),top:F,bot:x,left:et,right:Pt};return[new Q(Gt,Xt,lt+2*j,a+2*j),z]}get boundsT(){const B=this.bounds,q=(0,mt.s)((0,Ot.c)(),B.x,B.y);if((0,mt.t)(q,q,this._transform),this._hasRotation){const j=Math.max(B.width,B.height);return new Q(q[0],q[1],j,j)}return new Q(q[0],q[1],B.width,B.height)}_createBounds(B){let q=1/0,j=1/0,Z=0,rt=0;for(const kt of B)q=Math.min(q,kt.xTopLeft),j=Math.min(j,kt.yTopLeft),Z=Math.max(Z,kt.xBottomRight),rt=Math.max(rt,kt.yBottomRight);const dt=Z-q,Nt=rt-j;return new Q(q+dt/2,j+Nt/2,dt,Nt)}_createGlyphTransform(B,q){const j=ht*q.angle,Z=(0,pt.c)(),rt=(0,Ot.c)();return(0,nt.t)(Z,Z,(0,mt.s)(rt,q.xOffset,-q.yOffset)),q.isCIM?(0,nt.r)(Z,Z,j):((0,nt.t)(Z,Z,(0,mt.s)(rt,B.x,B.y)),(0,nt.r)(Z,Z,j),(0,nt.t)(Z,Z,(0,mt.s)(rt,-B.x,-B.y))),Z}}class D{constructor(B,q,j,Z,rt,dt){this.glyphWidthEnd=0,this.startX=0,this.startY=0,this.start=Math.max(0,Math.min(q,j)),this.end=Math.max(0,Math.max(q,j)),this.end<B.length&&(this.glyphWidthEnd=B[this.end].metrics.width),this.width=Z,this.yMin=rt,this.yMax=dt}}const it=_t=>10===_t,Mt=_t=>32===_t;function Tt(_t,B,q){const j=q.scale,Z=new Array,rt=function zt(_t,B,q){const j=new Array,rt=q.maxLineWidth*(1/q.scale),dt=B?_t.length-1:0,Nt=B?-1:_t.length,kt=B?-1:1;let Gt=dt,Xt=0,lt=0,a=Gt,_=a,I=0,b=1/0,k=0;for(;Gt!==Nt;){const{code:x,metrics:et}=_t[Gt],Pt=Math.abs(et.top);it(x)||Mt(x)||(b=Math.min(b,Pt),k=Math.max(k,Pt+et.height)),it(x)?(Gt!==dt&&(j.push(new D(_t,a,Gt-kt,Xt,b,k)),b=1/0,k=0),Xt=0,a=Gt+kt,_=Gt+kt,lt=0):Mt(x)?(_=Gt+kt,lt=0,I=et.advance,Xt+=et.advance):Xt>rt?(_!==a?(Xt-=I,j.push(new D(_t,a,_-2*kt,Xt-lt,b,k)),b=1/0,k=0,a=_,Xt=lt):(j.push(new D(_t,a,Gt-kt,Xt,b,k)),b=1/0,k=0,a=Gt,_=Gt,Xt=0),Xt+=et.advance,lt+=et.advance):(Xt+=et.advance,lt+=et.advance),Gt+=kt}const F=new D(_t,a,Gt-kt,Xt,b,k);return F.start>=0&&F.end<_t.length&&j.push(F),j}(_t,B,q),dt=function yt(_t,B){let q=0;for(let rt=0;rt<_t.length;rt++){const{width:dt}=_t[rt];q=Math.max(dt,q)}const Z=_t[0].yMin;return{x:0,y:Z,height:_t[_t.length-1].yMax+B.lineHeight*(_t.length-1)+("underline"===B.decoration?H:0)-Z,width:q}}(rt,q),{vAlign:Nt,hAlign:kt}=q,Gt=Nt===L.TR.Baseline?1:0,lt=(1-Gt)*-dt.y+dt.height/2*(Gt?0:Nt-1)+(Gt?1:0)*-tt;for(let a=0;a<rt.length;a++){const{start:_,end:I,width:b}=rt[a];let k=-1*(kt+1)*(b/2)-E;const F=a*q.lineHeight+lt-E;rt[a].startX=k,rt[a].startY=F;for(let x=_;x<=I;x++){const et=_t[x];if(it(et.code))continue;const Pt=new vt(k+et.metrics.left,F-et.metrics.top,et,j);k+=et.metrics.advance,Z.push(Pt)}}return new Rt(Z,rt,q)}}}]);
//# sourceMappingURL=1850.c18cee961dfd5be7.js.map