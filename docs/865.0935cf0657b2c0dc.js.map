{"version":3,"file":"865.0935cf0657b2c0dc.js","mappings":"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","names":["AppFormsModule","t","_angular_core__WEBPACK_IMPORTED_MODULE_0__","oAB","cJS","CommonModule","FormsModule","ReactiveFormsModule","ForgeModule","timer","dueTime","intervalOrScheduler","scheduler","asyncScheduler","intervalDuration","isScheduler","Observable","subscriber","due","isValidDate","value","Date","isNaN","now","n","schedule","closed","next","this","undefined","complete","delayWhen","delayDurationSelector","subscriptionDelay","source","concat","pipe","take","ignoreElements","operate","subscribe","createOperatorSubscriber","noop","mergeMap","index","innerFrom","mapTo","delay","duration","takeUntil","notifier","Action","Subscription","constructor","work","super","state","intervalProvider","setInterval","handler","timeout","args","delegate","clearInterval","handle","AsyncAction","pending","_a","id","recycleAsyncId","requestAsyncId","_id","flush","bind","_scheduler","execute","Error","error","_execute","_delay","errorValue","errored","e","unsubscribe","actions","arrRemove","Scheduler","schedulerActionCtor","dateTimestampProvider","AsyncScheduler","SchedulerAction","_active","action","push","shift","async","takeUntilDestroyed","destroyRef","assertInInjectionContext","inject","DestroyRef","destroyed$","observer","onDestroy"],"sourceRoot":"webpack:///","sources":["./src/app/shared/app-forms.module.ts","./node_modules/rxjs/dist/esm/internal/observable/timer.js","./node_modules/rxjs/dist/esm/internal/util/isDate.js","./node_modules/rxjs/dist/esm/internal/operators/delayWhen.js","./node_modules/rxjs/dist/esm/internal/operators/ignoreElements.js","./node_modules/rxjs/dist/esm/internal/operators/delay.js","./node_modules/rxjs/dist/esm/internal/operators/takeUntil.js","./node_modules/rxjs/dist/esm/internal/scheduler/Action.js","./node_modules/rxjs/dist/esm/internal/scheduler/intervalProvider.js","./node_modules/rxjs/dist/esm/internal/scheduler/AsyncAction.js","./node_modules/rxjs/dist/esm/internal/Scheduler.js","./node_modules/rxjs/dist/esm/internal/scheduler/AsyncScheduler.js","./node_modules/rxjs/dist/esm/internal/scheduler/async.js","./node_modules/rxjs/dist/esm/internal/scheduler/dateTimestampProvider.js","./node_modules/@angular/core/fesm2022/rxjs-interop.mjs"],"sourcesContent":["import { NgModule } from '@angular/core';\r\nimport { CommonModule } from '@angular/common';\r\nimport { ReactiveFormsModule, FormsModule } from '@angular/forms';\r\nimport { ForgeModule } from '@tylertech/forge-angular';\r\n\r\n@NgModule({\r\n  imports: [CommonModule],\r\n  exports: [FormsModule, ReactiveFormsModule, ForgeModule],\r\n  providers: []\r\n})\r\nexport class AppFormsModule { }","import { Observable } from '../Observable';\nimport { async as asyncScheduler } from '../scheduler/async';\nimport { isScheduler } from '../util/isScheduler';\nimport { isValidDate } from '../util/isDate';\nexport function timer(dueTime = 0, intervalOrScheduler, scheduler = asyncScheduler) {\n    let intervalDuration = -1;\n    if (intervalOrScheduler != null) {\n        if (isScheduler(intervalOrScheduler)) {\n            scheduler = intervalOrScheduler;\n        }\n        else {\n            intervalDuration = intervalOrScheduler;\n        }\n    }\n    return new Observable((subscriber) => {\n        let due = isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;\n        if (due < 0) {\n            due = 0;\n        }\n        let n = 0;\n        return scheduler.schedule(function () {\n            if (!subscriber.closed) {\n                subscriber.next(n++);\n                if (0 <= intervalDuration) {\n                    this.schedule(undefined, intervalDuration);\n                }\n                else {\n                    subscriber.complete();\n                }\n            }\n        }, due);\n    });\n}\n","export function isValidDate(value) {\n    return value instanceof Date && !isNaN(value);\n}\n","import { concat } from '../observable/concat';\nimport { take } from './take';\nimport { ignoreElements } from './ignoreElements';\nimport { mapTo } from './mapTo';\nimport { mergeMap } from './mergeMap';\nimport { innerFrom } from '../observable/innerFrom';\nexport function delayWhen(delayDurationSelector, subscriptionDelay) {\n    if (subscriptionDelay) {\n        return (source) => concat(subscriptionDelay.pipe(take(1), ignoreElements()), source.pipe(delayWhen(delayDurationSelector)));\n    }\n    return mergeMap((value, index) => innerFrom(delayDurationSelector(value, index)).pipe(take(1), mapTo(value)));\n}\n","import { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { noop } from '../util/noop';\nexport function ignoreElements() {\n    return operate((source, subscriber) => {\n        source.subscribe(createOperatorSubscriber(subscriber, noop));\n    });\n}\n","import { asyncScheduler } from '../scheduler/async';\nimport { delayWhen } from './delayWhen';\nimport { timer } from '../observable/timer';\nexport function delay(due, scheduler = asyncScheduler) {\n    const duration = timer(due, scheduler);\n    return delayWhen(() => duration);\n}\n","import { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\nimport { noop } from '../util/noop';\nexport function takeUntil(notifier) {\n    return operate((source, subscriber) => {\n        innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, () => subscriber.complete(), noop));\n        !subscriber.closed && source.subscribe(subscriber);\n    });\n}\n","import { Subscription } from '../Subscription';\nexport class Action extends Subscription {\n    constructor(scheduler, work) {\n        super();\n    }\n    schedule(state, delay = 0) {\n        return this;\n    }\n}\n","export const intervalProvider = {\n    setInterval(handler, timeout, ...args) {\n        const { delegate } = intervalProvider;\n        if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {\n            return delegate.setInterval(handler, timeout, ...args);\n        }\n        return setInterval(handler, timeout, ...args);\n    },\n    clearInterval(handle) {\n        const { delegate } = intervalProvider;\n        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);\n    },\n    delegate: undefined,\n};\n","import { Action } from './Action';\nimport { intervalProvider } from './intervalProvider';\nimport { arrRemove } from '../util/arrRemove';\nexport class AsyncAction extends Action {\n    constructor(scheduler, work) {\n        super(scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n        this.pending = false;\n    }\n    schedule(state, delay = 0) {\n        var _a;\n        if (this.closed) {\n            return this;\n        }\n        this.state = state;\n        const id = this.id;\n        const scheduler = this.scheduler;\n        if (id != null) {\n            this.id = this.recycleAsyncId(scheduler, id, delay);\n        }\n        this.pending = true;\n        this.delay = delay;\n        this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay);\n        return this;\n    }\n    requestAsyncId(scheduler, _id, delay = 0) {\n        return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);\n    }\n    recycleAsyncId(_scheduler, id, delay = 0) {\n        if (delay != null && this.delay === delay && this.pending === false) {\n            return id;\n        }\n        if (id != null) {\n            intervalProvider.clearInterval(id);\n        }\n        return undefined;\n    }\n    execute(state, delay) {\n        if (this.closed) {\n            return new Error('executing a cancelled action');\n        }\n        this.pending = false;\n        const error = this._execute(state, delay);\n        if (error) {\n            return error;\n        }\n        else if (this.pending === false && this.id != null) {\n            this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n        }\n    }\n    _execute(state, _delay) {\n        let errored = false;\n        let errorValue;\n        try {\n            this.work(state);\n        }\n        catch (e) {\n            errored = true;\n            errorValue = e ? e : new Error('Scheduled action threw falsy error');\n        }\n        if (errored) {\n            this.unsubscribe();\n            return errorValue;\n        }\n    }\n    unsubscribe() {\n        if (!this.closed) {\n            const { id, scheduler } = this;\n            const { actions } = scheduler;\n            this.work = this.state = this.scheduler = null;\n            this.pending = false;\n            arrRemove(actions, this);\n            if (id != null) {\n                this.id = this.recycleAsyncId(scheduler, id, null);\n            }\n            this.delay = null;\n            super.unsubscribe();\n        }\n    }\n}\n","import { dateTimestampProvider } from './scheduler/dateTimestampProvider';\nexport class Scheduler {\n    constructor(schedulerActionCtor, now = Scheduler.now) {\n        this.schedulerActionCtor = schedulerActionCtor;\n        this.now = now;\n    }\n    schedule(work, delay = 0, state) {\n        return new this.schedulerActionCtor(this, work).schedule(state, delay);\n    }\n}\nScheduler.now = dateTimestampProvider.now;\n","import { Scheduler } from '../Scheduler';\nexport class AsyncScheduler extends Scheduler {\n    constructor(SchedulerAction, now = Scheduler.now) {\n        super(SchedulerAction, now);\n        this.actions = [];\n        this._active = false;\n    }\n    flush(action) {\n        const { actions } = this;\n        if (this._active) {\n            actions.push(action);\n            return;\n        }\n        let error;\n        this._active = true;\n        do {\n            if ((error = action.execute(action.state, action.delay))) {\n                break;\n            }\n        } while ((action = actions.shift()));\n        this._active = false;\n        if (error) {\n            while ((action = actions.shift())) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    }\n}\n","import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\nexport const asyncScheduler = new AsyncScheduler(AsyncAction);\nexport const async = asyncScheduler;\n","export const dateTimestampProvider = {\n    now() {\n        return (dateTimestampProvider.delegate || Date).now();\n    },\n    delegate: undefined,\n};\n","/**\n * @license Angular v16.1.2\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { assertInInjectionContext, inject, DestroyRef, Injector, effect, untracked as untracked$1, signal as signal$1, computed as computed$1 } from '@angular/core';\nimport { Observable, ReplaySubject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\n\n/**\n * Operator which completes the Observable when the calling context (component, directive, service,\n * etc) is destroyed.\n *\n * @param destroyRef optionally, the `DestroyRef` representing the current context. This can be\n *     passed explicitly to use `takeUntilDestroyed` outside of an injection context. Otherwise, the\n * current `DestroyRef` is injected.\n *\n * @developerPreview\n */\nfunction takeUntilDestroyed(destroyRef) {\n    if (!destroyRef) {\n        assertInInjectionContext(takeUntilDestroyed);\n        destroyRef = inject(DestroyRef);\n    }\n    const destroyed$ = new Observable(observer => {\n        const unregisterFn = destroyRef.onDestroy(observer.next.bind(observer));\n        return unregisterFn;\n    });\n    return (source) => {\n        return source.pipe(takeUntil(destroyed$));\n    };\n}\n\n/**\n * Exposes the value of an Angular `Signal` as an RxJS `Observable`.\n *\n * The signal's value will be propagated into the `Observable`'s subscribers using an `effect`.\n *\n * `toObservable` must be called in an injection context unless an injector is provided via options.\n *\n * @developerPreview\n */\nfunction toObservable(source, options) {\n    !options?.injector && assertInInjectionContext(toObservable);\n    const injector = options?.injector ?? inject(Injector);\n    const subject = new ReplaySubject(1);\n    const watcher = effect(() => {\n        let value;\n        try {\n            value = source();\n        }\n        catch (err) {\n            untracked$1(() => subject.error(err));\n            return;\n        }\n        untracked$1(() => subject.next(value));\n    }, { injector, manualCleanup: true });\n    injector.get(DestroyRef).onDestroy(() => {\n        watcher.destroy();\n        subject.complete();\n    });\n    return subject.asObservable();\n}\n\n/**\n * Base URL for the error details page.\n *\n * Keep this constant in sync across:\n *  - packages/compiler-cli/src/ngtsc/diagnostics/src/error_details_base_url.ts\n *  - packages/core/src/error_details_base_url.ts\n */\nconst ERROR_DETAILS_PAGE_BASE_URL = 'https://angular.io/errors';\n/**\n * URL for the XSS security documentation.\n */\nconst XSS_SECURITY_URL = 'https://g.co/ng/security#xss';\n\n/**\n * Class that represents a runtime error.\n * Formats and outputs the error message in a consistent way.\n *\n * Example:\n * ```\n *  throw new RuntimeError(\n *    RuntimeErrorCode.INJECTOR_ALREADY_DESTROYED,\n *    ngDevMode && 'Injector has already been destroyed.');\n * ```\n *\n * Note: the `message` argument contains a descriptive error message as a string in development\n * mode (when the `ngDevMode` is defined). In production mode (after tree-shaking pass), the\n * `message` argument becomes `false`, thus we account for it in the typings and the runtime\n * logic.\n */\nclass RuntimeError extends Error {\n    constructor(code, message) {\n        super(formatRuntimeError(code, message));\n        this.code = code;\n    }\n}\n/**\n * Called to format a runtime error.\n * See additional info on the `message` argument type in the `RuntimeError` class description.\n */\nfunction formatRuntimeError(code, message) {\n    // Error code might be a negative number, which is a special marker that instructs the logic to\n    // generate a link to the error details page on angular.io.\n    // We also prepend `0` to non-compile-time errors.\n    const fullCode = `NG0${Math.abs(code)}`;\n    let errorMessage = `${fullCode}${message ? ': ' + message : ''}`;\n    if (ngDevMode && code < 0) {\n        const addPeriodSeparator = !errorMessage.match(/[.,;!?\\n]$/);\n        const separator = addPeriodSeparator ? '.' : '';\n        errorMessage =\n            `${errorMessage}${separator} Find more at ${ERROR_DETAILS_PAGE_BASE_URL}/${fullCode}`;\n    }\n    return errorMessage;\n}\n\n/**\n * Symbol used to tell `Signal`s apart from other functions.\n *\n * This can be used to auto-unwrap signals in various cases, or to auto-wrap non-signal values.\n */\nconst SIGNAL = Symbol('SIGNAL');\n/**\n * Checks if the given `value` is a reactive `Signal`.\n *\n * @developerPreview\n */\nfunction isSignal(value) {\n    return typeof value === 'function' && value[SIGNAL] !== undefined;\n}\n/**\n * Converts `fn` into a marked signal function (where `isSignal(fn)` will be `true`), and\n * potentially add some set of extra properties (passed as an object record `extraApi`).\n */\nfunction createSignalFromFunction(node, fn, extraApi = {}) {\n    fn[SIGNAL] = node;\n    // Copy properties from `extraApi` to `fn` to complete the desired API of the `Signal`.\n    return Object.assign(fn, extraApi);\n}\n/**\n * The default equality function used for `signal` and `computed`, which treats objects and arrays\n * as never equal, and all other primitive values using identity semantics.\n *\n * This allows signals to hold non-primitive values (arrays, objects, other collections) and still\n * propagate change notification upon explicit mutation without identity change.\n *\n * @developerPreview\n */\nfunction defaultEquals(a, b) {\n    // `Object.is` compares two values using identity semantics which is desired behavior for\n    // primitive values. If `Object.is` determines two values to be equal we need to make sure that\n    // those don't represent objects (we want to make sure that 2 objects are always considered\n    // \"unequal\"). The null check is needed for the special case of JavaScript reporting null values\n    // as objects (`typeof null === 'object'`).\n    return (a === null || typeof a !== 'object') && Object.is(a, b);\n}\n\n// Always use __globalThis if available, which is the spec-defined global variable across all\n// environments, then fallback to __global first, because in Node tests both __global and\n// __window may be defined and _global should be __global in that case. Note: Typeof/Instanceof\n// checks are considered side-effects in Terser. We explicitly mark this as side-effect free:\n// https://github.com/terser/terser/issues/250.\nconst _global = ( /* @__PURE__ */(() => (typeof globalThis !== 'undefined' && globalThis) ||\n    (typeof global !== 'undefined' && global) || (typeof window !== 'undefined' && window) ||\n    (typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&\n        self instanceof WorkerGlobalScope && self))());\n\nfunction ngDevModeResetPerfCounters() {\n    const locationString = typeof location !== 'undefined' ? location.toString() : '';\n    const newCounters = {\n        namedConstructors: locationString.indexOf('ngDevMode=namedConstructors') != -1,\n        firstCreatePass: 0,\n        tNode: 0,\n        tView: 0,\n        rendererCreateTextNode: 0,\n        rendererSetText: 0,\n        rendererCreateElement: 0,\n        rendererAddEventListener: 0,\n        rendererSetAttribute: 0,\n        rendererRemoveAttribute: 0,\n        rendererSetProperty: 0,\n        rendererSetClassName: 0,\n        rendererAddClass: 0,\n        rendererRemoveClass: 0,\n        rendererSetStyle: 0,\n        rendererRemoveStyle: 0,\n        rendererDestroy: 0,\n        rendererDestroyNode: 0,\n        rendererMoveNode: 0,\n        rendererRemoveNode: 0,\n        rendererAppendChild: 0,\n        rendererInsertBefore: 0,\n        rendererCreateComment: 0,\n        hydratedNodes: 0,\n        hydratedComponents: 0,\n        dehydratedViewsRemoved: 0,\n        dehydratedViewsCleanupRuns: 0,\n        componentsSkippedHydration: 0,\n    };\n    // Make sure to refer to ngDevMode as ['ngDevMode'] for closure.\n    const allowNgDevModeTrue = locationString.indexOf('ngDevMode=false') === -1;\n    _global['ngDevMode'] = allowNgDevModeTrue && newCounters;\n    return newCounters;\n}\n/**\n * This function checks to see if the `ngDevMode` has been set. If yes,\n * then we honor it, otherwise we default to dev mode with additional checks.\n *\n * The idea is that unless we are doing production build where we explicitly\n * set `ngDevMode == false` we should be helping the developer by providing\n * as much early warning and errors as possible.\n *\n * `ɵɵdefineComponent` is guaranteed to have been called before any component template functions\n * (and thus Ivy instructions), so a single initialization there is sufficient to ensure ngDevMode\n * is defined for the entire instruction set.\n *\n * When checking `ngDevMode` on toplevel, always init it before referencing it\n * (e.g. `((typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode())`), otherwise you can\n *  get a `ReferenceError` like in https://github.com/angular/angular/issues/31595.\n *\n * Details on possible values for `ngDevMode` can be found on its docstring.\n *\n * NOTE:\n * - changes to the `ngDevMode` name must be synced with `compiler-cli/src/tooling.ts`.\n */\nfunction initNgDevMode() {\n    // The below checks are to ensure that calling `initNgDevMode` multiple times does not\n    // reset the counters.\n    // If the `ngDevMode` is not an object, then it means we have not created the perf counters\n    // yet.\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        if (typeof ngDevMode !== 'object') {\n            ngDevModeResetPerfCounters();\n        }\n        return typeof ngDevMode !== 'undefined' && !!ngDevMode;\n    }\n    return false;\n}\n\n// Required as the signals library is in a separate package, so we need to explicitly ensure the\n/**\n * A `WeakRef`-compatible reference that fakes the API with a strong reference\n * internally.\n */\nclass LeakyRef {\n    constructor(ref) {\n        this.ref = ref;\n    }\n    deref() {\n        return this.ref;\n    }\n}\n// `WeakRef` is not always defined in every TS environment where Angular is compiled. Instead,\n// read it off of the global context if available.\n// tslint:disable-next-line: no-toplevel-property-access\nlet WeakRefImpl = _global['WeakRef'] ?? LeakyRef;\nfunction newWeakRef(value) {\n    if (typeof ngDevMode !== 'undefined' && ngDevMode && WeakRefImpl === undefined) {\n        throw new Error(`Angular requires a browser which supports the 'WeakRef' API`);\n    }\n    return new WeakRefImpl(value);\n}\nfunction setAlternateWeakRefImpl(impl) {\n    // no-op since the alternate impl is included by default by the framework. Remove once internal\n    // migration is complete.\n}\n\n// Required as the signals library is in a separate package, so we need to explicitly ensure the\n/**\n * Counter tracking the next `ProducerId` or `ConsumerId`.\n */\nlet _nextReactiveId = 0;\n/**\n * Tracks the currently active reactive consumer (or `null` if there is no active\n * consumer).\n */\nlet activeConsumer = null;\n/**\n * Whether the graph is currently propagating change notifications.\n */\nlet inNotificationPhase = false;\nfunction setActiveConsumer(consumer) {\n    const prev = activeConsumer;\n    activeConsumer = consumer;\n    return prev;\n}\n/**\n * A node in the reactive graph.\n *\n * Nodes can be producers of reactive values, consumers of other reactive values, or both.\n *\n * Producers are nodes that produce values, and can be depended upon by consumer nodes.\n *\n * Producers expose a monotonic `valueVersion` counter, and are responsible for incrementing this\n * version when their value semantically changes. Some producers may produce their values lazily and\n * thus at times need to be polled for potential updates to their value (and by extension their\n * `valueVersion`). This is accomplished via the `onProducerUpdateValueVersion` method for\n * implemented by producers, which should perform whatever calculations are necessary to ensure\n * `valueVersion` is up to date.\n *\n * Consumers are nodes that depend on the values of producers and are notified when those values\n * might have changed.\n *\n * Consumers do not wrap the reads they consume themselves, but rather can be set as the active\n * reader via `setActiveConsumer`. Reads of producers that happen while a consumer is active will\n * result in those producers being added as dependencies of that consumer node.\n *\n * The set of dependencies of a consumer is dynamic. Implementers expose a monotonically increasing\n * `trackingVersion` counter, which increments whenever the consumer is about to re-run any reactive\n * reads it needs and establish a new set of dependencies as a result.\n *\n * Producers store the last `trackingVersion` they've seen from `Consumer`s which have read them.\n * This allows a producer to identify whether its record of the dependency is current or stale, by\n * comparing the consumer's `trackingVersion` to the version at which the dependency was\n * last observed.\n */\nclass ReactiveNode {\n    constructor() {\n        this.id = _nextReactiveId++;\n        /**\n         * A cached weak reference to this node, which will be used in `ReactiveEdge`s.\n         */\n        this.ref = newWeakRef(this);\n        /**\n         * Edges to producers on which this node depends (in its consumer capacity).\n         */\n        this.producers = new Map();\n        /**\n         * Edges to consumers on which this node depends (in its producer capacity).\n         */\n        this.consumers = new Map();\n        /**\n         * Monotonically increasing counter representing a version of this `Consumer`'s\n         * dependencies.\n         */\n        this.trackingVersion = 0;\n        /**\n         * Monotonically increasing counter which increases when the value of this `Producer`\n         * semantically changes.\n         */\n        this.valueVersion = 0;\n    }\n    /**\n     * Polls dependencies of a consumer to determine if they have actually changed.\n     *\n     * If this returns `false`, then even though the consumer may have previously been notified of a\n     * change, the values of its dependencies have not actually changed and the consumer should not\n     * rerun any reactions.\n     */\n    consumerPollProducersForChange() {\n        for (const [producerId, edge] of this.producers) {\n            const producer = edge.producerNode.deref();\n            if (producer === undefined || edge.atTrackingVersion !== this.trackingVersion) {\n                // This dependency edge is stale, so remove it.\n                this.producers.delete(producerId);\n                producer?.consumers.delete(this.id);\n                continue;\n            }\n            if (producer.producerPollStatus(edge.seenValueVersion)) {\n                // One of the dependencies reports a real value change.\n                return true;\n            }\n        }\n        // No dependency reported a real value change, so the `Consumer` has also not been\n        // impacted.\n        return false;\n    }\n    /**\n     * Notify all consumers of this producer that its value may have changed.\n     */\n    producerMayHaveChanged() {\n        // Prevent signal reads when we're updating the graph\n        const prev = inNotificationPhase;\n        inNotificationPhase = true;\n        try {\n            for (const [consumerId, edge] of this.consumers) {\n                const consumer = edge.consumerNode.deref();\n                if (consumer === undefined || consumer.trackingVersion !== edge.atTrackingVersion) {\n                    this.consumers.delete(consumerId);\n                    consumer?.producers.delete(this.id);\n                    continue;\n                }\n                consumer.onConsumerDependencyMayHaveChanged();\n            }\n        }\n        finally {\n            inNotificationPhase = prev;\n        }\n    }\n    /**\n     * Mark that this producer node has been accessed in the current reactive context.\n     */\n    producerAccessed() {\n        if (inNotificationPhase) {\n            throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode ?\n                `Assertion error: signal read during notification phase` :\n                '');\n        }\n        if (activeConsumer === null) {\n            return;\n        }\n        // Either create or update the dependency `Edge` in both directions.\n        let edge = activeConsumer.producers.get(this.id);\n        if (edge === undefined) {\n            edge = {\n                consumerNode: activeConsumer.ref,\n                producerNode: this.ref,\n                seenValueVersion: this.valueVersion,\n                atTrackingVersion: activeConsumer.trackingVersion,\n            };\n            activeConsumer.producers.set(this.id, edge);\n            this.consumers.set(activeConsumer.id, edge);\n        }\n        else {\n            edge.seenValueVersion = this.valueVersion;\n            edge.atTrackingVersion = activeConsumer.trackingVersion;\n        }\n    }\n    /**\n     * Whether this consumer currently has any producers registered.\n     */\n    get hasProducers() {\n        return this.producers.size > 0;\n    }\n    /**\n     * Whether this `ReactiveNode` in its producer capacity is currently allowed to initiate updates,\n     * based on the current consumer context.\n     */\n    get producerUpdatesAllowed() {\n        return activeConsumer?.consumerAllowSignalWrites !== false;\n    }\n    /**\n     * Checks if a `Producer` has a current value which is different than the value\n     * last seen at a specific version by a `Consumer` which recorded a dependency on\n     * this `Producer`.\n     */\n    producerPollStatus(lastSeenValueVersion) {\n        // `producer.valueVersion` may be stale, but a mismatch still means that the value\n        // last seen by the `Consumer` is also stale.\n        if (this.valueVersion !== lastSeenValueVersion) {\n            return true;\n        }\n        // Trigger the `Producer` to update its `valueVersion` if necessary.\n        this.onProducerUpdateValueVersion();\n        // At this point, we can trust `producer.valueVersion`.\n        return this.valueVersion !== lastSeenValueVersion;\n    }\n}\n\n/**\n * Create a computed `Signal` which derives a reactive value from an expression.\n *\n * @developerPreview\n */\nfunction computed(computation, options) {\n    const node = new ComputedImpl(computation, options?.equal ?? defaultEquals);\n    // Casting here is required for g3, as TS inference behavior is slightly different between our\n    // version/options and g3's.\n    return createSignalFromFunction(node, node.signal.bind(node));\n}\n/**\n * A dedicated symbol used before a computed value has been calculated for the first time.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst UNSET = Symbol('UNSET');\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * is in progress. Used to detect cycles in computation chains.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst COMPUTING = Symbol('COMPUTING');\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * failed. The thrown error is cached until the computation gets dirty again.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst ERRORED = Symbol('ERRORED');\n/**\n * A computation, which derives a value from a declarative reactive expression.\n *\n * `Computed`s are both producers and consumers of reactivity.\n */\nclass ComputedImpl extends ReactiveNode {\n    constructor(computation, equal) {\n        super();\n        this.computation = computation;\n        this.equal = equal;\n        /**\n         * Current value of the computation.\n         *\n         * This can also be one of the special values `UNSET`, `COMPUTING`, or `ERRORED`.\n         */\n        this.value = UNSET;\n        /**\n         * If `value` is `ERRORED`, the error caught from the last computation attempt which will\n         * be re-thrown.\n         */\n        this.error = null;\n        /**\n         * Flag indicating that the computation is currently stale, meaning that one of the\n         * dependencies has notified of a potential change.\n         *\n         * It's possible that no dependency has _actually_ changed, in which case the `stale`\n         * state can be resolved without recomputing the value.\n         */\n        this.stale = true;\n        this.consumerAllowSignalWrites = false;\n    }\n    onConsumerDependencyMayHaveChanged() {\n        if (this.stale) {\n            // We've already notified consumers that this value has potentially changed.\n            return;\n        }\n        // Record that the currently cached value may be stale.\n        this.stale = true;\n        // Notify any consumers about the potential change.\n        this.producerMayHaveChanged();\n    }\n    onProducerUpdateValueVersion() {\n        if (!this.stale) {\n            // The current value and its version are already up to date.\n            return;\n        }\n        // The current value is stale. Check whether we need to produce a new one.\n        if (this.value !== UNSET && this.value !== COMPUTING &&\n            !this.consumerPollProducersForChange()) {\n            // Even though we were previously notified of a potential dependency update, all of\n            // our dependencies report that they have not actually changed in value, so we can\n            // resolve the stale state without needing to recompute the current value.\n            this.stale = false;\n            return;\n        }\n        // The current value is stale, and needs to be recomputed. It still may not change -\n        // that depends on whether the newly computed value is equal to the old.\n        this.recomputeValue();\n    }\n    recomputeValue() {\n        if (this.value === COMPUTING) {\n            // Our computation somehow led to a cyclic read of itself.\n            throw new Error('Detected cycle in computations.');\n        }\n        const oldValue = this.value;\n        this.value = COMPUTING;\n        // As we're re-running the computation, update our dependent tracking version number.\n        this.trackingVersion++;\n        const prevConsumer = setActiveConsumer(this);\n        let newValue;\n        try {\n            newValue = this.computation();\n        }\n        catch (err) {\n            newValue = ERRORED;\n            this.error = err;\n        }\n        finally {\n            setActiveConsumer(prevConsumer);\n        }\n        this.stale = false;\n        if (oldValue !== UNSET && oldValue !== ERRORED && newValue !== ERRORED &&\n            this.equal(oldValue, newValue)) {\n            // No change to `valueVersion` - old and new values are\n            // semantically equivalent.\n            this.value = oldValue;\n            return;\n        }\n        this.value = newValue;\n        this.valueVersion++;\n    }\n    signal() {\n        // Check if the value needs updating before returning it.\n        this.onProducerUpdateValueVersion();\n        // Record that someone looked at this signal.\n        this.producerAccessed();\n        if (this.value === ERRORED) {\n            throw this.error;\n        }\n        return this.value;\n    }\n}\n\nfunction defaultThrowError() {\n    throw new Error();\n}\nlet throwInvalidWriteToSignalErrorFn = defaultThrowError;\nfunction throwInvalidWriteToSignalError() {\n    throwInvalidWriteToSignalErrorFn();\n}\nfunction setThrowInvalidWriteToSignalError(fn) {\n    throwInvalidWriteToSignalErrorFn = fn;\n}\n\n/**\n * If set, called after `WritableSignal`s are updated.\n *\n * This hook can be used to achieve various effects, such as running effects synchronously as part\n * of setting a signal.\n */\nlet postSignalSetFn = null;\nclass WritableSignalImpl extends ReactiveNode {\n    constructor(value, equal) {\n        super();\n        this.value = value;\n        this.equal = equal;\n        this.consumerAllowSignalWrites = false;\n    }\n    onConsumerDependencyMayHaveChanged() {\n        // This never happens for writable signals as they're not consumers.\n    }\n    onProducerUpdateValueVersion() {\n        // Writable signal value versions are always up to date.\n    }\n    /**\n     * Directly update the value of the signal to a new value, which may or may not be\n     * equal to the previous.\n     *\n     * In the event that `newValue` is semantically equal to the current value, `set` is\n     * a no-op.\n     */\n    set(newValue) {\n        if (!this.producerUpdatesAllowed) {\n            throwInvalidWriteToSignalError();\n        }\n        if (!this.equal(this.value, newValue)) {\n            this.value = newValue;\n            this.valueVersion++;\n            this.producerMayHaveChanged();\n            postSignalSetFn?.();\n        }\n    }\n    /**\n     * Derive a new value for the signal from its current value using the `updater` function.\n     *\n     * This is equivalent to calling `set` on the result of running `updater` on the current\n     * value.\n     */\n    update(updater) {\n        if (!this.producerUpdatesAllowed) {\n            throwInvalidWriteToSignalError();\n        }\n        this.set(updater(this.value));\n    }\n    /**\n     * Calls `mutator` on the current value and assumes that it has been mutated.\n     */\n    mutate(mutator) {\n        if (!this.producerUpdatesAllowed) {\n            throwInvalidWriteToSignalError();\n        }\n        // Mutate bypasses equality checks as it's by definition changing the value.\n        mutator(this.value);\n        this.valueVersion++;\n        this.producerMayHaveChanged();\n        postSignalSetFn?.();\n    }\n    asReadonly() {\n        if (this.readonlySignal === undefined) {\n            this.readonlySignal = createSignalFromFunction(this, () => this.signal());\n        }\n        return this.readonlySignal;\n    }\n    signal() {\n        this.producerAccessed();\n        return this.value;\n    }\n}\n/**\n * Create a `Signal` that can be set or updated directly.\n *\n * @developerPreview\n */\nfunction signal(initialValue, options) {\n    const signalNode = new WritableSignalImpl(initialValue, options?.equal ?? defaultEquals);\n    // Casting here is required for g3, as TS inference behavior is slightly different between our\n    // version/options and g3's.\n    const signalFn = createSignalFromFunction(signalNode, signalNode.signal.bind(signalNode), {\n        set: signalNode.set.bind(signalNode),\n        update: signalNode.update.bind(signalNode),\n        mutate: signalNode.mutate.bind(signalNode),\n        asReadonly: signalNode.asReadonly.bind(signalNode)\n    });\n    return signalFn;\n}\nfunction setPostSignalSetFn(fn) {\n    const prev = postSignalSetFn;\n    postSignalSetFn = fn;\n    return prev;\n}\n\n/**\n * Execute an arbitrary function in a non-reactive (non-tracking) context. The executed function\n * can, optionally, return a value.\n *\n * @developerPreview\n */\nfunction untracked(nonReactiveReadsFn) {\n    const prevConsumer = setActiveConsumer(null);\n    // We are not trying to catch any particular errors here, just making sure that the consumers\n    // stack is restored in case of errors.\n    try {\n        return nonReactiveReadsFn();\n    }\n    finally {\n        setActiveConsumer(prevConsumer);\n    }\n}\n\nconst NOOP_CLEANUP_FN = () => { };\n/**\n * Watches a reactive expression and allows it to be scheduled to re-run\n * when any dependencies notify of a change.\n *\n * `Watch` doesn't run reactive expressions itself, but relies on a consumer-\n * provided scheduling operation to coordinate calling `Watch.run()`.\n */\nclass Watch extends ReactiveNode {\n    constructor(watch, schedule, allowSignalWrites) {\n        super();\n        this.watch = watch;\n        this.schedule = schedule;\n        this.dirty = false;\n        this.cleanupFn = NOOP_CLEANUP_FN;\n        this.registerOnCleanup = (cleanupFn) => {\n            this.cleanupFn = cleanupFn;\n        };\n        this.consumerAllowSignalWrites = allowSignalWrites;\n    }\n    notify() {\n        if (!this.dirty) {\n            this.schedule(this);\n        }\n        this.dirty = true;\n    }\n    onConsumerDependencyMayHaveChanged() {\n        this.notify();\n    }\n    onProducerUpdateValueVersion() {\n        // Watches are not producers.\n    }\n    /**\n     * Execute the reactive expression in the context of this `Watch` consumer.\n     *\n     * Should be called by the user scheduling algorithm when the provided\n     * `schedule` hook is called by `Watch`.\n     */\n    run() {\n        this.dirty = false;\n        if (this.trackingVersion !== 0 && !this.consumerPollProducersForChange()) {\n            return;\n        }\n        const prevConsumer = setActiveConsumer(this);\n        this.trackingVersion++;\n        try {\n            this.cleanupFn();\n            this.cleanupFn = NOOP_CLEANUP_FN;\n            this.watch(this.registerOnCleanup);\n        }\n        finally {\n            setActiveConsumer(prevConsumer);\n        }\n    }\n    cleanup() {\n        this.cleanupFn();\n    }\n}\n\nfunction toSignal(source, options) {\n    const requiresCleanup = !options?.manualCleanup;\n    requiresCleanup && !options?.injector && assertInInjectionContext(toSignal);\n    const cleanupRef = requiresCleanup ? options?.injector?.get(DestroyRef) ?? inject(DestroyRef) : null;\n    // Note: T is the Observable value type, and U is the initial value type. They don't have to be\n    // the same - the returned signal gives values of type `T`.\n    let state;\n    if (options?.requireSync) {\n        // Initially the signal is in a `NoValue` state.\n        state = signal$1({ kind: 0 /* StateKind.NoValue */ });\n    }\n    else {\n        // If an initial value was passed, use it. Otherwise, use `undefined` as the initial value.\n        state = signal$1({ kind: 1 /* StateKind.Value */, value: options?.initialValue });\n    }\n    const sub = source.subscribe({\n        next: value => state.set({ kind: 1 /* StateKind.Value */, value }),\n        error: error => state.set({ kind: 2 /* StateKind.Error */, error }),\n        // Completion of the Observable is meaningless to the signal. Signals don't have a concept of\n        // \"complete\".\n    });\n    if (ngDevMode && options?.requireSync && untracked(state).kind === 0 /* StateKind.NoValue */) {\n        throw new RuntimeError(601 /* RuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\n    }\n    // Unsubscribe when the current context is destroyed, if requested.\n    cleanupRef?.onDestroy(sub.unsubscribe.bind(sub));\n    // The actual returned signal is a `computed` of the `State` signal, which maps the various states\n    // to either values or errors.\n    return computed$1(() => {\n        const current = state();\n        switch (current.kind) {\n            case 1 /* StateKind.Value */:\n                return current.value;\n            case 2 /* StateKind.Error */:\n                throw current.error;\n            case 0 /* StateKind.NoValue */:\n                // This shouldn't really happen because the error is thrown on creation.\n                // TODO(alxhub): use a RuntimeError when we finalize the error semantics\n                throw new RuntimeError(601 /* RuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\n        }\n    });\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { takeUntilDestroyed, toObservable, toSignal };\n"],"x_google_ignoreList":[1,2,3,4,5,6,7,8,9,10,11,12,13,14]}