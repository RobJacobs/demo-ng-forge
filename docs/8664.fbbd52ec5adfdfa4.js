"use strict";(self.webpackChunkdemo_ng_forge=self.webpackChunkdemo_ng_forge||[]).push([[8664],{49533:(dt,$,g)=>{function j(){return new Float32Array(3)}function O(W){const F=new Float32Array(3);return F[0]=W[0],F[1]=W[1],F[2]=W[2],F}function z(W,F,Z){const m=new Float32Array(3);return m[0]=W,m[1]=F,m[2]=Z,m}function C(){return j()}function G(){return z(1,1,1)}function d(){return z(1,0,0)}function T(){return z(0,1,0)}function E(){return z(0,0,1)}g.d($,{b:()=>O,c:()=>j,f:()=>z});const B=C(),P=G(),Y=d(),X=T(),Q=E();Object.freeze(Object.defineProperty({__proto__:null,ONES:P,UNIT_X:Y,UNIT_Y:X,UNIT_Z:Q,ZEROS:B,clone:O,create:j,createView:function k(W,F){return new Float32Array(W,F,3)},fromValues:z,ones:G,unitX:d,unitY:T,unitZ:E,zeros:C},Symbol.toStringTag,{value:"Module"}))},18661:(dt,$,g)=>{g.d($,{SR:()=>E,Ui:()=>T});var j=g(53661),O=g(6848),z=g(71949),k=g(12818),C=g(71182),G=g(15686),d=g(53492);function T(p){return B(p,!0)}function E(p){return B(p,!1)}function B(p,l){if((0,j.Wi)(p))return null;const f=p.spatialReference,x=(0,d.C5)(f),_="toJSON"in p?p.toJSON():p;if(!x)return _;const M=(0,d.sS)(f)?102100:4326,U=G.UZ[M].maxX,w=G.UZ[M].minX;if((0,C.wp)(_))return Y(_,U,w);if((0,C.aW)(_))return _.points=_.points.map(I=>Y(I,U,w)),_;if((0,C.YX)(_))return function P(p,l){if(!l)return p;const f=function X(p,l){const f=[],{ymin:x,ymax:_,xmin:M,xmax:U}=p,w=p.xmax-p.xmin,[I,A]=l.valid,{x:K,frameId:N}=Q(p.xmin,l),{x:H,frameId:et}=Q(p.xmax,l),gt=K===H&&w>0;if(w>2*A){const nt={xmin:M<U?K:H,ymin:x,xmax:A,ymax:_},xt={xmin:I,ymin:x,xmax:M<U?H:K,ymax:_},vt={xmin:0,ymin:x,xmax:A,ymax:_},Ct={xmin:I,ymin:x,xmax:0,ymax:_},ht=[],ot=[];L(nt,vt)&&ht.push(N),L(nt,Ct)&&ot.push(N),L(xt,vt)&&ht.push(et),L(xt,Ct)&&ot.push(et);for(let q=N+1;q<et;q++)ht.push(q),ot.push(q);f.push(new Z(nt,[N]),new Z(xt,[et]),new Z(vt,ht),new Z(Ct,ot))}else K>H||gt?f.push(new Z({xmin:K,ymin:x,xmax:A,ymax:_},[N]),new Z({xmin:I,ymin:x,xmax:H,ymax:_},[et])):f.push(new Z({xmin:K,ymin:x,xmax:H,ymax:_},[N]));return f}(p,l).map(x=>x.extent);return f.length<2?f[0]||p:f.length>2?(p.xmin=l.valid[0],p.xmax=l.valid[1],p):{rings:f.map(x=>[[x.xmin,x.ymin],[x.xmin,x.ymax],[x.xmax,x.ymax],[x.xmax,x.ymin],[x.xmin,x.ymin]])}}(_,x);if((0,C.oU)(_)||(0,C.l9)(_)){const I=(0,z.$P)(m,_),A={xmin:I[0],ymin:I[1],xmax:I[2],ymax:I[3]},K=(0,G.XZ)(A.xmin,w)*(2*U),N=0===K?_:(0,G.Sy)(_,K);return A.xmin+=K,A.xmax+=K,A.xmax>U?F(N,U,l):A.xmin<w?F(N,w,l):N}return _}function Y(p,l,f){if(Array.isArray(p)){const x=p[0];if(x>l){const _=(0,G.XZ)(x,l);p[0]=x+_*(-2*l)}else if(x<f){const _=(0,G.XZ)(x,f);p[0]=x+_*(-2*f)}}else{const x=p.x;if(x>l){const _=(0,G.XZ)(x,l);p.x+=_*(-2*l)}else if(x<f){const _=(0,G.XZ)(x,f);p.x+=_*(-2*f)}}return p}function Q(p,l){const[f,x]=l.valid,_=2*x;let M,U=0;return p>x?(M=Math.ceil(Math.abs(p-x)/_),p-=M*_,U=M):p<f&&(M=Math.ceil(Math.abs(p-f)/_),p+=M*_,U=-M),{x:p,frameId:U}}function L(p,l){const{xmin:f,ymin:x,xmax:_,ymax:M}=l;return W(p,f,x)&&W(p,f,M)&&W(p,_,M)&&W(p,_,x)}function W(p,l,f){return l>=p.xmin&&l<=p.xmax&&f>=p.ymin&&f<=p.ymax}function F(p,l,f=!0){const x=!(0,C.l9)(p);if(x&&(0,k.Zy)(p),f)return(new R).cut(p,l);const _=x?p.rings:p.paths,M=x?4:2,U=_.length,w=-2*l;for(let I=0;I<U;I++){const A=_[I];if(A&&A.length>=M){const K=[];for(const N of A)K.push([N[0]+w,N[1]]);_.push(K)}}return x?p.rings=_:p.paths=_,p}class Z{constructor(l,f){this.extent=l,this.frameIds=f}}const m=(0,O.Ue)();class R{constructor(){this._linesIn=[],this._linesOut=[]}cut(l,f){let x;if(this._xCut=f,l.rings)this._closed=!0,x=l.rings,this._minPts=4;else{if(!l.paths)return null;this._closed=!1,x=l.paths,this._minPts=2}for(const M of x){if(!M||M.length<this._minPts)continue;let U=!0;for(const w of M)U?(this.moveTo(w),U=!1):this.lineTo(w);this._closed&&this.close()}this._pushLineIn(),this._pushLineOut(),x=[];for(const M of this._linesIn)M&&M.length>=this._minPts&&x.push(M);const _=-2*this._xCut;for(const M of this._linesOut)if(M&&M.length>=this._minPts){for(const U of M)U[0]+=_;x.push(M)}return this._closed?l.rings=x:l.paths=x,l}moveTo(l){this._pushLineIn(),this._pushLineOut(),this._prevSide=this._side(l[0]),this._moveTo(l[0],l[1],this._prevSide),this._prevPt=l,this._firstPt=l}lineTo(l){const f=this._side(l[0]);if(f*this._prevSide==-1){const x=this._intersect(this._prevPt,l);this._lineTo(this._xCut,x,0),this._prevSide=0,this._lineTo(l[0],l[1],f)}else this._lineTo(l[0],l[1],f);this._prevSide=f,this._prevPt=l}close(){const l=this._firstPt,f=this._prevPt;l[0]===f[0]&&l[1]===f[1]||this.lineTo(l),this._checkClosingPt(this._lineIn),this._checkClosingPt(this._lineOut)}_moveTo(l,f,x){this._closed?(this._lineIn.push([x<=0?l:this._xCut,f]),this._lineOut.push([x>=0?l:this._xCut,f])):(x<=0&&this._lineIn.push([l,f]),x>=0&&this._lineOut.push([l,f]))}_lineTo(l,f,x){this._closed?(this._addPolyVertex(this._lineIn,x<=0?l:this._xCut,f),this._addPolyVertex(this._lineOut,x>=0?l:this._xCut,f)):x<0?(0===this._prevSide&&this._pushLineOut(),this._lineIn.push([l,f])):x>0?(0===this._prevSide&&this._pushLineIn(),this._lineOut.push([l,f])):this._prevSide<0?(this._lineIn.push([l,f]),this._lineOut.push([l,f])):this._prevSide>0&&(this._lineOut.push([l,f]),this._lineIn.push([l,f]))}_addPolyVertex(l,f,x){const _=l.length;_>1&&l[_-1][0]===f&&l[_-2][0]===f?l[_-1][1]=x:l.push([f,x])}_checkClosingPt(l){const f=l.length;f>3&&l[0][0]===this._xCut&&l[f-2][0]===this._xCut&&l[1][0]===this._xCut&&(l[0][1]=l[f-2][1],l.pop())}_side(l){return l<this._xCut?-1:l>this._xCut?1:0}_intersect(l,f){return l[1]+(this._xCut-l[0])/(f[0]-l[0])*(f[1]-l[1])}_pushLineIn(){this._lineIn&&this._lineIn.length>=this._minPts&&this._linesIn.push(this._lineIn),this._lineIn=[]}_pushLineOut(){this._lineOut&&this._lineOut.length>=this._minPts&&this._linesOut.push(this._lineOut),this._lineOut=[]}}},28679:(dt,$,g)=>{g.d($,{H:()=>F});var j=g(71670),O=g(32995),z=g(67087),k=g(28191),C=g(53661),G=g(30801),d=g(80696),T=g(21288),E=g(52300),B=g(13458),P=g(69923),Y=g(2512),X=g(74697);const Q=k.Z.getLogger("esri.views.2d.engine.webgl.AttributeStoreView"),L=(0,B.g)(B.J,Q);class W{constructor(m,R,p){this._texture=null,this._lastTexture=null,this._fbos={},this.texelSize=4;const{buffer:l,pixelType:f,textureOnly:x}=m,_=(0,E.UK)(f);this.shared=p,this.pixelType=f,this.size=R,this.textureOnly=x,x||(this.data=new _((0,C.Wg)(l))),this._resetRange()}destroy(){(0,C.yw)(this._texture,m=>m.dispose());for(const m in this._fbos)(0,C.yw)(this._fbos[m],R=>{"0"===m&&R.detachColorTexture(),R.dispose()}),this._fbos[m]=null;this._texture=null}get _textureDesc(){return{target:P.No.TEXTURE_2D,wrapMode:P.e8.CLAMP_TO_EDGE,pixelFormat:P.VI.RGBA,dataType:this.pixelType,samplingMode:P.cw.NEAREST,width:this.size,height:this.size}}setData(m,R,p){const l=(0,T.jL)(m),f=(0,C.Wg)(this.data),x=l*this.texelSize+R;!f||x>=f.length||(f[x]=p,this.dirtyStart=Math.min(this.dirtyStart,l),this.dirtyEnd=Math.max(this.dirtyEnd,l))}getData(m,R){if((0,C.Wi)(this.data))return null;const p=(0,T.jL)(m)*this.texelSize+R;return!this.data||p>=this.data.length?null:this.data[p]}getTexture(m){return(0,C.Pt)(this._texture,()=>this._initTexture(m))}getFBO(m,R=0){if((0,C.Wi)(this._fbos[R])){const p={colorTarget:P.Lm.TEXTURE,depthStencilTarget:P.OU.NONE},l=0===R?this.getTexture(m):this._textureDesc;this._fbos[R]=new Y.X(m,p,l)}return this._fbos[R]}get locked(){return!(this.pixelType!==P.Br.UNSIGNED_BYTE||!this.shared||this.textureOnly||!(0,z.Z)("esri-atomics")||!this.data)&&1===Atomics.load(this.data,0)}get hasDirty(){return this.dirtyEnd>=this.dirtyStart}updateTexture(m,R){if(!this.locked){try{const p=this.dirtyStart,l=this.dirtyEnd;if(!this.hasDirty)return;this._resetRange();const f=(0,C.Wg)(this.data).buffer,x=this.getTexture(m),_=4,M=(p-p%this.size)/this.size,w=M,A=(l-l%this.size)/this.size,K=M*this.size*_,N=(this.size+A*this.size)*_-K,H=(0,E.UK)(this.pixelType),et=new H(f,K*H.BYTES_PER_ELEMENT,N),gt=this.size,nt=A-w+1;if(nt>this.size)return void Q.error(new O.Z("mapview-webgl","Out-of-bounds index when updating AttributeData"));x.updateData(0,0,w,gt,nt,et)}catch{}R()}}update(m){const{data:R,start:p,end:l}=m;if((0,C.pC)(R)&&(0,C.pC)(this.data)){const f=this.data,x=p*this.texelSize;for(let _=0;_<R.length;_++)m.layout&1<<_%this.texelSize&&(f[x+_]=R[_])}this.dirtyStart=Math.min(this.dirtyStart,p),this.dirtyEnd=Math.max(this.dirtyEnd,l)}resize(m,R){const p=this.size;if(this.size=R,this.textureOnly)return void(p!==this.size&&(this._lastTexture=this._texture,this._texture=null));const l=(0,E.UK)(this.pixelType);this.destroy(),this.data=new l((0,C.Wg)(m.buffer))}_resetRange(){this.dirtyStart=2147483647,this.dirtyEnd=0}_initTexture(m){const R=new X.x(m,this._textureDesc,(0,C.Pt)(this.data,void 0));if((0,C.pC)(this._lastTexture)&&this._fbos[0]){const p=this._lastTexture.descriptor.width,l=this._lastTexture.descriptor.height,f=this._lastTexture.descriptor.dataType,x=this._lastTexture.descriptor.pixelFormat,_=this.getFBO(m),M=(0,E.Yw)(f),U=new((0,E.UK)(f))(new ArrayBuffer(p*l*M*this.texelSize)),w=m.getBoundFramebufferObject(),{x:I,y:A,width:K,height:N}=m.getViewport();m.bindFramebuffer(_),_.readPixels(0,0,p,l,x,f,U),R.updateData(0,0,0,2*p,l/2,U),m.setViewport(I,A,K,N),m.bindFramebuffer(w)}return this.destroy(),this._texture=R,this._texture}}class F{constructor(m){this._onUpdate=m,this._initialized=!1,this._forceNextUpload=!1,this._locked=!1}initialize(m){const{blocks:R,shared:p,size:l}=m;if(this.shared=p,this.size=l,L("Initializing AttributeStoreView",m),(0,C.Wi)(this._data))this._data=(0,C.Fd)(R,f=>new W(f,l,p));else for(let f=0;f<this._data.length;f++){const x=this._data[f],_=R[f];(0,C.pC)(_)&&((0,C.Wi)(x)?this._data[f]=new W(_,l,p):x.resize(_,l))}this._initialized=!0}destroy(){(0,C.yw)(this._data,m=>(0,C.Fd)(m,R=>R.destroy())),(0,C.yw)(this._defaultTexture,m=>m.dispose())}isEmpty(){return(0,C.Wi)(this._data)}isUpdating(){const m=(0,C.pC)(this._pendingAttributeUpdate),R=m;return(0,z.Z)("esri-2d-log-updating")&&console.log(`Updating AttributeStoreView ${R}\n  -> hasPendingUpdate ${m}`),R}getBlock(m){return(0,C.Wi)(this._data)?null:this._data[m]}setLabelMinZoom(m,R){this.setData(m,0,1,R)}getLabelMinZoom(m){return this.getData(m,0,1,255)}getFilterFlags(m){return this.getData(m,0,0,0)}getVVSize(m){return this.getData(m,d.aK,0,0)}getData(m,R,p,l){if(!this._data)return 0;const f=(0,C.Wg)(this._data)[R];if((0,C.Wi)(f))return 0;const x=f.getData(m,p);return(0,C.pC)(x)?x:l}setData(m,R,p,l){const f=(0,C.Wg)(this._data)[R];(0,C.Wg)(f).setData(m,p,l)}lockTextureUpload(){this._locked=!0}unlockTextureUpload(){this._locked=!1}forceTextureUpload(){this._forceNextUpload=!0}requestUpdate(m){var R=this;return(0,j.Z)(function*(){if(R._pendingAttributeUpdate)return void Q.error(new O.Z("mapview-webgl","Tried to update attribute data with a pending update"));const p=(0,G.hh)();return L("AttributeStoreView Update Requested",m),R._pendingAttributeUpdate={data:m,resolver:p},R._onUpdate(),p.promise})()}update(){if(this._initialized&&(0,C.pC)(this._pendingAttributeUpdate)){(0,z.Z)("esri-2d-update-debug")&&console.debug("AttributeStoreView::update");const{data:m,resolver:R}=this._pendingAttributeUpdate,p=(0,C.Wg)(this._data);for(let l=0;l<m.blocks.length;l++){const f=m.blocks[l];(0,C.yw)(p[l],_=>(0,C.yw)(f,M=>{L(`Updating block ${l}`,M),_.update(M)}))}this._pendingAttributeUpdate=null,R(),this._onUpdate()}}bindTextures(m,R=!0){const p=this._getDefaultTexture(m);if(!this._initialized)return m.bindTexture(p,d.iJ),void(R&&(m.bindTexture(p,d.nM),m.bindTexture(p,d.Ij),m.bindTexture(p,d.f2),m.bindTexture(p,d.By),m.bindTexture(p,d.mx),m.bindTexture(p,d.Xj)));const l=(0,C.Wg)(this._data);this._locked&&!this._forceNextUpload||((0,C.JR)(l,f=>f.updateTexture(m,()=>this._onUpdate())),this._forceNextUpload=!1),m.bindTexture((0,C.R2)(l[d._5],p,f=>f.getTexture(m)),d.iJ),R&&(m.bindTexture((0,C.R2)(l[d.pU],p,f=>f.getTexture(m)),d.Xj),m.bindTexture((0,C.R2)(l[d.xl],p,f=>f.getTexture(m)),d.nM),m.bindTexture((0,C.R2)(l[d.aK],p,f=>f.getTexture(m)),d.Ij),m.bindTexture((0,C.R2)(l[d.lK],p,f=>f.getTexture(m)),d.f2),m.bindTexture((0,C.R2)(l[d.By],p,f=>f.getTexture(m)),d.By),m.bindTexture((0,C.R2)(l[d.mx],p,f=>f.getTexture(m)),d.mx))}_getDefaultTexture(m){return(0,C.Wi)(this._defaultTexture)&&(this._defaultTexture=new X.x(m,{wrapMode:P.e8.CLAMP_TO_EDGE,pixelFormat:P.VI.RGBA,dataType:P.Br.UNSIGNED_BYTE,samplingMode:P.cw.NEAREST,width:1,height:1},new Uint8Array(4))),this._defaultTexture}}},11653:(dt,$,g)=>{g.d($,{I:()=>k});var j=g(38974),O=g(99390),z=g(67026);class k extends O.s{constructor(G,d,T,E,B,P,Y=B,X=P){super(),this.triangleCountReportedInDebug=0,this.triangleCount=0,this.texture=null,this.key=new z.Z(G),this.resolution=d,this.x=T,this.y=E,this.width=B,this.height=P,this.rangeX=Y,this.rangeY=X}destroy(){this.texture&&(this.texture.dispose(),this.texture=null)}setTransform(G){const d=this.resolution/(G.resolution*G.pixelRatio),T=this.transforms.tileMat3,[E,B]=G.toScreenNoRotation([0,0],[this.x,this.y]);(0,j.s)(T,this.width/this.rangeX*d,0,0,0,this.height/this.rangeY*d,0,E,B,1),(0,j.m)(this.transforms.dvs,G.displayViewMat3,T)}}},6833:(dt,$,g)=>{g.d($,{o:()=>T});var j=g(53072),O=g(80309),z=g(38974),k=g(40334),C=g(80696),G=g(11653);class T extends G.I{constructor(B,P,Y,X){super(B,P,Y,X,C.I_,C.I_)}destroy(){super.destroy(),this._transforms&&T.TransformCache.release(this.key.hash)}setTransform(B){const P=this.resolution/B.resolution,Y=this.transforms.tileMat3,[X,Q]=B.toScreenNoRotation([0,0],[this.x,this.y]),L=this.width/this.rangeX*P,W=this.height/this.rangeY*P;(0,z.s)(Y,L,0,0,0,W,0,X,Q,1),(0,z.m)(this.transforms.dvs,B.displayViewMat3,Y);const F=this.transforms.labelMat2d,Z=window.devicePixelRatio,m=(0,j.d)((0,O.c)(),L*Z,0,0,W*Z,X*Z,Q*Z);(0,j.m)(F,B.viewMat2d,m)}_createTransforms(){return T.TransformCache.acquire(this.key.hash)}}T.TransformCache=new class d{acquire(B){return{refCount:1,version:-1,labelMat2d:(0,O.c)(),tileMat3:(0,k.c)(),dvs:(0,k.c)()}}release(B){}}},46461:(dt,$,g)=>{g.d($,{$:()=>k});var j=g(53661),O=g(80696);const z=2147483647;class k{constructor(d){this._head=d,this._cursor=d}static from(d,T=0,E=d.byteLength/C.BYTES_PER_RECORD-T){const B=new C(new Int32Array(d,T*C.BYTES_PER_RECORD,E*C.ELEMENTS_PER_RECORD));return new k(B)}size(){let d=this._cursor,T=0;for(;d;)T+=d.size(),d=d._link;return T}get id(){return this._cursor.id}set id(d){this._cursor.id=d}get materialKey(){return this._cursor.materialKey}set materialKey(d){this._cursor.materialKey=d}get insertAfter(){return this._cursor.insertAfter}get indexFrom(){return this._cursor.indexFrom}set indexFrom(d){this._cursor.indexFrom=d}get indexCount(){return this._cursor.indexCount}set indexCount(d){this._cursor.indexCount=d}get vertexFrom(){return this._cursor.vertexFrom}set vertexFrom(d){this._cursor.vertexFrom=d}get vertexCount(){return this._cursor.vertexCount}set vertexCount(d){this._cursor.vertexCount=d}get sortKey(){return this._cursor.sortKey}set sortKey(d){this._cursor.sortKey=d}get index(){return this._cursor._indexStart+this._cursor._index}seekIndex(d){let T=d;for(this._cursor=this._head;this._cursor;){const E=this._cursor.size();if(T<E)return this._cursor._index=T,!0;T-=E,this._cursor=this._cursor._link}return!1}forEach(d){const T=this.getCursor();for(;T.next();)d(T)}link(d){if(!this._head)return void(this._head=d._head);let T=this._head;for(;T._link;)T=T._link;T._link=d._head,T._link._indexStart=T._indexStart+T.size()}getCursor(){return this.copy()}lookup(d){for(this._cursor=this._head;this._cursor&&!this._cursor.lookup(d);){if(!this._cursor._link)return!1;this._cursor=this._cursor._link}return!!this._cursor}copy(){const d=new k(this._head?.copy());if(!d._head)return d;let T=d._head,E=d._head._link;for(;E;)T._link=E.copy(),T=E,E=T._link;return d}next(){return!!this._cursor&&(!!this._cursor.next()||!!this._cursor._link&&(this._cursor=this._cursor._link,this.next()))}peekId(){return this._cursor.peekId()??this._cursor._link.peekId()}delete(d){let T=this._head,E=null;for(;T;){if(T.delete(d))return T.isEmpty()&&((0,j.pC)(E)&&(E._link=T._link),T===this._head&&(this._head=T._link),T===this._cursor&&(this._cursor=T._link)),!0;E=T,T=T._link}return!1}}k.ELEMENTS_PER_RECORD=O.XJ,k.BYTES_PER_RECORD=k.ELEMENTS_PER_RECORD*Int32Array.BYTES_PER_ELEMENT;class C{constructor(d){this._link=null,this._index=-1,this._indexStart=0,this._packedRecordsF32=null,this._deletedCount=0,this._offsets={instance:null},this._packedRecords=d}static from(d,T=0,E=d.byteLength/this.BYTES_PER_RECORD-T){return new C(new Int32Array(d,T*this.BYTES_PER_RECORD,E*this.ELEMENTS_PER_RECORD))}delete(d){const T=this._index,E=this.lookup(d);if(E)for(this.id=z,++this._deletedCount;this.next()&&this.id===d;)this.id=z,++this._deletedCount;return this._index=T,E}isEmpty(){return this._deletedCount===this.size()}link(d){this._link?this._link.link(d):this._link=d}lookup(d){if((0,j.Wi)(this._offsets.instance)){this._offsets.instance=new Map;const E=this.copy();E._index=-1;let B=0;for(;E.next();)E.id!==B&&(this._offsets.instance.set(E.id,E._index),B=E.id)}if(!this._offsets.instance.has(d))return!1;const T=this._index;return this._index=this._offsets.instance.get(d),this.id!==z||(this._index=T,!1)}get id(){return this._packedRecords[this._index*C.ELEMENTS_PER_RECORD]}set id(d){this._packedRecords[this._index*C.ELEMENTS_PER_RECORD]=d}get materialKey(){return this._packedRecords[this._index*C.ELEMENTS_PER_RECORD+1]}set materialKey(d){this._packedRecords[this._index*C.ELEMENTS_PER_RECORD+1]=d}get insertAfter(){return this._packedRecords[this._index*C.ELEMENTS_PER_RECORD+2]}get indexFrom(){return this._packedRecords[this._index*C.ELEMENTS_PER_RECORD+3]}set indexFrom(d){this._packedRecords[this._index*C.ELEMENTS_PER_RECORD+3]=d}get indexCount(){return this._packedRecords[this._index*C.ELEMENTS_PER_RECORD+4]}set indexCount(d){this._packedRecords[this._index*C.ELEMENTS_PER_RECORD+4]=d}get vertexFrom(){return this._packedRecords[this._index*C.ELEMENTS_PER_RECORD+5]}set vertexFrom(d){this._packedRecords[this._index*C.ELEMENTS_PER_RECORD+5]=d}get vertexCount(){return this._packedRecords[this._index*C.ELEMENTS_PER_RECORD+6]}set vertexCount(d){this._packedRecords[this._index*C.ELEMENTS_PER_RECORD+6]=d}get sortKey(){return this._packedRecordsF32||(this._packedRecordsF32=new Float32Array(this._packedRecords.buffer)),this._packedRecordsF32[this._index*C.ELEMENTS_PER_RECORD+7]}set sortKey(d){this._packedRecordsF32||(this._packedRecordsF32=new Float32Array(this._packedRecords.buffer)),this._packedRecordsF32[this._index*C.ELEMENTS_PER_RECORD+7]=d}get index(){return this._index}size(){return this._packedRecords.length/C.ELEMENTS_PER_RECORD}next(){for(;++this._index<this.size()&&this.id===z;);return this._index<this.size()}peekId(){const d=(this._index+1)*C.ELEMENTS_PER_RECORD;return d>=this._packedRecords.length?0:this._packedRecords[d]}getCursor(){return this.copy()}copy(){const d=new C(this._packedRecords);return d._indexStart=this._indexStart,d._link=this._link,d._index=this._index,d._offsets=this._offsets,d._deletedCount=this._deletedCount,d}}C.ELEMENTS_PER_RECORD=O.XJ,C.BYTES_PER_RECORD=C.ELEMENTS_PER_RECORD*Int32Array.BYTES_PER_ELEMENT},18825:(dt,$,g)=>{g.d($,{Z:()=>Re});var j=g(71670),O=g(18100),z=g(6365),k=g(65489),C=g(31882),G=g(67087),d=g(53661),T=g(30801),E=g(7521),B=g(9497),X=(g(83382),g(19420),g(20891)),Q=g(68230),L=g(6848),W=g(12818),F=g(71182),Z=g(18661),m=g(53492),R=g(19482),p=g(77213),l=g(32682),f=g(80696),x=g(20753);const _=-1;class M{constructor(){this._dirties=[{vertexFrom:_,vertexCount:_,indexFrom:_,indexCount:_,allDirty:!1},{vertexFrom:_,vertexCount:_,indexFrom:_,indexCount:_,allDirty:!1},{vertexFrom:_,vertexCount:_,indexFrom:_,indexCount:_,allDirty:!1},{vertexFrom:_,vertexCount:_,indexFrom:_,indexCount:_,allDirty:!1},{vertexFrom:_,vertexCount:_,indexFrom:_,indexCount:_,allDirty:!1}]}hasDirty(){return this._dirties.some(t=>t.indexCount!==_||t.allDirty)}markAllClean(){for(const t of this._dirties)t.indexFrom=_,t.indexCount=_,t.vertexFrom=_,t.vertexCount=_,t.allDirty=!1}markAllDirty(){for(const t of this._dirties)t.allDirty=!0}forEach(t){for(let e=0;e<this._dirties.length;++e){const{indexCount:s,indexFrom:i,vertexCount:r,vertexFrom:n,allDirty:o}=this._dirties[e],h={};let u,v=!1;(o||n!==_&&r>0)&&(h.geometry={count:r,from:n,allDirty:o},v=!0),(o||i!==_&&s>0)&&(u={count:s,from:i,allDirty:o},v=!0),v&&t({indices:u,vertices:h},e)}}markDirtyIndices(t,e,s){const i=this._dirties[t],r=e,n=s;if(!i.allDirty)if(i.indexCount!==_){const o=Math.min(i.indexFrom,r),h=Math.max(i.indexFrom+i.indexCount,r+n)-o;i.indexFrom=o,i.indexCount=h}else i.indexFrom=r,i.indexCount=n}markDirtyVertices(t,e,s,i){const r=this._dirties[t],n=s,o=i;if(!r.allDirty)if(r.vertexCount!==_){const h=Math.min(r.vertexFrom,n),u=Math.max(r.vertexFrom+r.vertexCount,n+o)-h;r.vertexFrom=h,r.vertexCount=u}else r.vertexFrom=n,r.vertexCount=o}}class U{get largestRange(){return this._largestRange}constructor(t){this._largestRange=null,this._parent=t,this._updateLargestRange()}rangeCreated(t){(!this._largestRange||t.count>this._largestRange.count)&&(this._largestRange=t)}rangeResized(t,e){t===this._largestRange?t.count<e&&this._updateLargestRange():(!this._largestRange||t.count>this._largestRange.count)&&(this._largestRange=t)}findBestRange(t){let e=this._parent._freeHead,s=null;for(;null!==e;)e.count>=t&&(!s||e.count-t<s.count-t)&&(s=e),e=e.next;return s}findAdjacentRanges(t,e){let s=!0,i=!1,r=null,n=this._parent._freeHead;for(;s&&!i;)t>=(null!==r?r.from+r.count:0)&&t+e<=(null!==n?n.from:this._parent._size)?(s=!1,i=!0):null!==n?(r=n,n=n.next):s=!1;return[r,n]}_updateLargestRange(){let t=null,e=this._parent._freeHead;for(;null!==e;)(!t||e.count>t.count)&&(t=e),e=e.next;this._largestRange=t}}class w{constructor(t,e){this._allocated=0,this._size=t,this._freeHead=t>0?{from:0,count:t,prev:null,next:null}:null,this._bookKeeper=e||new U(this),this._freeHead&&this._bookKeeper.rangeCreated(this._freeHead)}allocate(t){const e=this._bookKeeper.findBestRange(t);if(null==e)return-1;const s=e.from,i=e.count;if(e.from+=t,e.count-=t,this._bookKeeper.rangeResized(e,s,i),this._allocated+=t,0===e.count){const r=null!==e.prev?this._freeHead:e.next;w._removeRange(e),this._freeHead=r}return s}free(t,e){const[s,i]=this._bookKeeper.findAdjacentRanges(t,e),r={from:t,count:e,prev:s??null,next:i??null};if(null!=s&&(s.next=r),null!=i&&(i.prev=r),this._bookKeeper.rangeCreated(r),this._allocated-=e,null!=i&&r.from+r.count===i.from){const n=r.from,o=r.count;w._fuse(r,i),w._removeRange(i),this._bookKeeper.rangeResized(r,n,o),this._bookKeeper.rangeResized(i,void 0,0)}if(null!=s&&s.from+s.count===r.from){const n=s.from,o=s.count;w._fuse(s,r),w._removeRange(r),this._bookKeeper.rangeResized(s,n,o),this._bookKeeper.rangeResized(r,void 0,0)}this._freeHead=null!==r.prev?this._freeHead:r}get fragmentation(){const t=this._size-this._allocated;return 0===t?0:1-this._bookKeeper.largestRange.count/t}static _removeRange(t){null!==t.prev?null!==t.next?(t.prev.next=t.next,t.next.prev=t.prev):t.prev.next=null:null!==t.next&&(t.next.prev=null)}static _fuse(t,e){t.count+=e.count,t.next=e.next,e.from+=e.count,e.count=0,null!==e.next&&(e.next.prev=t)}}var I=g(52300);const A=["FILL","LINE","MARKER","TEXT","LABEL"];class H{constructor(t,e,s,i){this._strides=t,this._displayList=e,this._freeListsAndStorage={},this._dirtyMap=null,this._dirtyMap=s;for(const r in t){this._freeListsAndStorage[r]={vtxFreeList:i?new w(i):null,idxFreeList:i?new w(i):null,vertexBuffers:{},indexBuffer:i?new Uint32Array(i):null};for(const n in t[r])this._freeListsAndStorage[r].vertexBuffers[n]={data:i?(0,I.C$)(i,t[r][n]):null,stride:t[r][n]}}}static fromTileData(t,e){const s=function K(a){const t=a.getStrides(),e={};for(let s=0;s<t.length;s++)e[A[s]]=t[s];return e}(t),i=[0,0,0,0,0],r=[0,0,0,0,0];for(const h of t.tileDisplayData.displayObjects)for(const u of h.displayRecords)i[u.geometryType]=Math.max(i[u.geometryType],u.vertexFrom+u.vertexCount),r[u.geometryType]=Math.max(r[u.geometryType],u.indexFrom+u.indexCount);const n=new H(s,t.tileDisplayData.displayList,e,void 0),o=t.tileBufferData?.geometries??[];for(let h=0;h<o.length;++h){const u=i[h],v=r[h],c=o[h],D=n._storageFor(A[h]),b=o[h].indexBuffer;D.indexBuffer=b,D.idxFreeList=new w(b.length),D.idxFreeList.allocate(v);let S=0;for(const J in c.vertexBuffer){const tt=o[h].vertexBuffer[J];D.vertexBuffers[J].data=tt.data,D.vertexBuffers[J].stride=tt.stride;const at=(0,I.Y8)(tt.stride);S||(S=tt.data.length*at/tt.stride)}D.vtxFreeList=new w(S),D.vtxFreeList.allocate(u)}return n}delete(t){const e=A[t.geometryType];this._freeVertices(e,t.vertexFrom,t.vertexCount),this._freeIndices(e,t.indexFrom,t.indexCount),this._displayList.removeFromList(t),t.vertexFrom=void 0,t.indexFrom=void 0}setMeshData(t,e,s,i,r){const n=A[t.geometryType];let o,h;t.meshData=null,void 0===t.vertexFrom?(h=e.vertexCount,o=this._allocateVertices(n,h)):e.vertexCount>t.vertexCount?(this._freeVertices(n,t.vertexFrom,t.vertexCount),h=e.vertexCount,o=this._allocateVertices(n,h)):e.vertexCount===t.vertexCount?(o=t.vertexFrom,h=t.vertexCount):(this._freeVertices(n,t.vertexFrom+e.vertexCount,t.vertexCount-e.vertexCount),o=t.vertexFrom,h=e.vertexCount);let u,v,c,y=!0;if(void 0===t.indexFrom?(u=r,c=e.indexCount,v=this._allocateIndices(n,c)):e.indexCount>t.indexCount?(u=this._displayList.removeFromList(t),this._freeIndices(n,t.indexFrom,t.indexCount),c=e.indexCount,v=this._allocateIndices(n,c)):e.indexCount===t.indexCount?(y=!1,v=t.indexFrom,c=t.indexCount):(u=this._displayList.removeFromList(t),this._freeIndices(n,t.indexFrom+e.indexCount,t.indexCount-e.indexCount),v=t.indexFrom,c=e.indexCount),-1!==o&&-1!==v){const D=this._storageFor(n);if((0,I.wO)(o,v,D.vertexBuffers,D.indexBuffer,e,s,i),t.vertexFrom=o,t.indexFrom=v,t.vertexCount=e.vertexCount,t.indexCount=e.indexCount,this._dirtyMap){this._dirtyMap.markDirtyIndices(t.geometryType,t.indexFrom,t.indexCount);for(const b in s)this._dirtyMap.markDirtyVertices(t.geometryType,b,t.vertexFrom,t.vertexCount)}return y&&this._displayList.addToList(t,u),!0}return-1!==o&&this._freeVertices(n,o,h),-1!==v&&this._freeIndices(n,v,c),t.setMeshDataFromBuffers(e,s,i),t.vertexFrom=void 0,t.vertexCount=0,t.indexFrom=void 0,t.indexCount=0,!1}tryAddMeshData(t,e){const s=e.vertexBuffer,i=e.indexBuffer,r=A[t.geometryType],n=this._allocateVertices(r,t.vertexCount);if(-1===n)return this._freeVertices(r,n,t.vertexCount),!1;const o=this._allocateIndices(r,t.indexCount);if(-1===o)return this._freeVertices(r,n,t.vertexCount),this._freeIndices(r,o,t.indexCount),!1;const h=this._storageFor(r);if((0,I.wO)(n,o,h.vertexBuffers,h.indexBuffer,t,s,i),t.vertexFrom=n,t.indexFrom=o,this._dirtyMap){this._dirtyMap.markDirtyIndices(t.geometryType,t.indexFrom,t.indexCount);for(const u in s)this._dirtyMap.markDirtyVertices(t.geometryType,u,n,t.vertexCount)}return this._displayList.addToList(t),!0}_allocateVertices(t,e){const s=this._storageFor(t),i=s.vtxFreeList?.allocate(e);if(null==i||-1===i)return-1;const r=s.vtxFreeList?.fragmentation;return null==r||r>.5?-1:i}_freeVertices(t,e,s){this._storageFor(t).vtxFreeList?.free(e,s)}_freeIndices(t,e,s){this._storageFor(t).idxFreeList?.free(e,s)}_allocateIndices(t,e){const s=this._storageFor(t),i=s.idxFreeList?.allocate(e);if(null==i||-1===i)return-1;const r=s.idxFreeList?.fragmentation;return null==r||r>.5?-1:i}_storageFor(t){return this._freeListsAndStorage[t]}_stridesFor(t,e){return this._strides[t][e]}}var et=g(10615),gt=g(69923),nt=g(19955);class xt{constructor(t){this.geometryMap=(0,I.Mk)(()=>({indexBuffer:et.f.createIndex(t,gt.l1.STATIC_DRAW),vao:null}),(e,s)=>({vertexBuffer:et.f.createVertex(t,I.mR[s])}))}dispose(){for(let t=0;t<5;t++){const e=this.geometryMap[t];if(e){e.data.vao&&e.data.vao.dispose(!1),e.data.indexBuffer&&e.data.indexBuffer.dispose();for(const s in e.buffers)e.buffers[s]&&e.buffers[s].data.vertexBuffer.dispose()}}}get(t){const e=this.geometryMap[t];return{getVAO(s,i,r){if(!e.data.vao){const n={};for(const o in e.buffers)n[o]=e.buffers[o].data.vertexBuffer;e.data.vao=new nt.U(s,r,i,n,e.data.indexBuffer)}return e.data.vao}}}has(t){return null!=this.geometryMap[t]}upload(t,e){e.forEach((s,i)=>{this._upload(s,i,t)})}_upload(t,e,s){if(t.indices&&(t.indices.allDirty?this._uploadIndices(s,e):null!=t.indices.from&&null!=t.indices.count&&this._uploadIndices(s,e,t.indices.from,t.indices.count)),t.vertices){const i=t.vertices;for(const r in i){const n=i[r];n.allDirty?this._uploadVertices(s,e,r):null!=n.from&&null!=n.count&&this._uploadVertices(s,e,r,n.from,n.count)}}}_uploadVertices(t,e,s,i,r){const n=this.geometryMap[e];if(!n)return;const o=t.geometries[e].vertexBuffer[s];if(!o)return;const{data:h,stride:u}=o;if(n.buffers[s]&&h.length>0){const v=u/h.BYTES_PER_ELEMENT;null!=i&&null!=r?n.buffers[s].data.vertexBuffer.setSubData(h,i*v,i*v,(i+r)*v):n.buffers[s].data.vertexBuffer.setData(h)}}_uploadIndices(t,e,s,i){const r=this.geometryMap[e];if(!r)return;const n=t.geometries[e].indexBuffer;r.data.indexBuffer&&n.length>0&&(null!=s&&null!=i?r.data.indexBuffer.setSubData(n,s,s,s+i):r.data.indexBuffer.setData(n))}}var vt=g(6833);class Ct extends vt.o{constructor(){super(...arguments),this._data=null,this._displayList=null,this._lastCommitTime=0,this._hasData=!1,this._invalidated=!1,this._wglBuffers=null,this._dirtyMap=new M}destroy(){super.destroy(),this.clear()}get hasData(){return!!this._hasData}get displayObjects(){return this._displayObjects??[]}getGeometry(t){return this._wglBuffers&&this._wglBuffers.has(t)?this._wglBuffers.get(t):null}getDisplayList(){return this._displayList}patch(t){if(!0===t.clear)return this.clear(),void(this._hasData=!1);const e=t.addOrUpdate,s=t.remove;!this._data&&e&&e.tileDisplayData?.displayObjects.length?(e.tileDisplayData.computeDisplayList(),this._dirtyMap=new M,this._dispRecStore=H.fromTileData(e,this._dirtyMap),this._data=e,this._dirtyMap.markAllDirty(),this._hasData=!0,t.end&&this.ready()):this._data&&(e&&e.tileDisplayData?.displayObjects.length||s.length)?this._doPatchData(t):t.end&&this.ready(),t.end&&!this._data&&this.clear(),this.requestRender(),this.emit("change")}commit(t){t.time&&t.time===this._lastCommitTime||(this._lastCommitTime=t.time,this.visible&&this._data&&(this._wglBuffers||(this._wglBuffers=new xt(t.context)),(this._dirtyMap.hasDirty()||this._invalidated)&&(this._invalidated=!1,this._wglBuffers.upload(this._data.tileBufferData,this._dirtyMap),this._displayList=this._data.tileDisplayData.displayList.clone(),this._displayObjects=this._data.tileDisplayData.displayObjects.slice(),this._dirtyMap.markAllClean())))}clear(){this._data=null,this._displayList=null,this._dispRecStore=null,this._wglBuffers&&(this._wglBuffers.dispose(),this._wglBuffers=null)}_doPatchData(t){this._invalidated=!0,this._patchData(t)||(this._dirtyMap.markAllDirty(),this._data.reshuffle(),this._dispRecStore=H.fromTileData(this._data,this._dirtyMap)),this.requestRender()}_patchData(t){let e=!0;const s=t.addOrUpdate&&t.addOrUpdate.tileDisplayData&&t.addOrUpdate.tileDisplayData.displayObjects||[],i=(t.remove||[]).slice();for(const o of s)null!=o.insertAfter&&i.push(o.id);let r;i.length>0&&(r=new Set(i));const n=this._data.tileDisplayData;for(const o of i){const h=n.displayObjectRegistry.get(o);if(h){n.displayList.removeFromList(h.displayRecords);for(const u of h.displayRecords)this._dispRecStore.delete(u);n.displayObjectRegistry.delete(o)}}r?.size&&(n.displayObjects=n.displayObjects.filter(o=>!r.has(o.id)));for(const o of s){let h,u=n.displayObjectRegistry.get(o.id);if(u){const c=u.displayRecords;u.set(o),u.displayRecords=c;const y=u.displayRecords.length;for(let D=0;D<y;++D){const b=u.displayRecords[D],S=o.displayRecords[D];(D>=o.displayRecords.length||b.geometryType!==S.geometryType||b.symbolLevel!==S.symbolLevel||b.zOrder!==S.zOrder||b.materialKey!==S.materialKey)&&(this._dispRecStore.delete(u.displayRecords[D]),D<o.displayRecords.length&&(u.displayRecords[D]=void 0))}u.displayRecords.length=o.displayRecords.length}else{let c;u=o.copy(),u.displayRecords=[],n.displayObjectRegistry.set(o.id,u);const y=n.displayObjects;if(null!=u.insertAfter)if(h={},u.insertAfter>=0){const D=n.displayObjectRegistry.get(u.insertAfter);D?(c=y.indexOf(D)+1,c<y.length?y.splice(c,0,u):(y.push(u),c=y.length)):(y.push(u),c=y.length)}else y.unshift(u),c=0;else y.push(u),c=y.length;if(h){const D=o.displayRecords.length>0?1:0;let b=0;for(let S=c-1;S>=0&&b<D;--S)for(let J=y[S].displayRecords.length-1;J>=0&&b<D;--J){const tt=y[S].displayRecords[J],at=n.displayList.getDPInfoType();h[at]||(h[at]=tt,++b)}}}const v=o.displayRecords.length;for(let c=0;c<v;++c){const y=o.displayRecords[c];let D=u.displayRecords[c];D?(D.meshData=y.meshData,D.materialKey=y.materialKey):(D=y.copy(),D.vertexFrom=void 0,D.indexFrom=void 0,u.displayRecords[c]=D);const b=y.geometryType,S=n.displayList.getDPInfoType(),J=t.addOrUpdate.tileBufferData.geometries[b],tt=J.vertexBuffer,at=J.indexBuffer;let lt;h&&(lt=h[S]?n.displayList.splitAfter(h[S]):-1),e=this._dispRecStore.setMeshData(D,y,tt,at,lt)&&e,h&&null!=D.indexFrom&&null!=D.indexFrom&&(h[S]=D)}}return e}}class ht{constructor(){this._byGeometryType=null}get satisfied(){return!this._byGeometryType}reset(){this._byGeometryType=null}verticesFor(t){return this._byGeometryType?this._byGeometryType[t].vertices:0}indicesFor(t){return this._byGeometryType?this._byGeometryType[t].indices:0}needMore(t,e,s){if(!e&&!s)return;this._byGeometryType||(this._byGeometryType=[{vertices:0,indices:0},{vertices:0,indices:0},{vertices:0,indices:0},{vertices:0,indices:0},{vertices:0,indices:0}]);const i=this._byGeometryType[t];i.vertices+=e,i.indices+=s}}class q{constructor(){this.geometries=[{indexBuffer:void 0,vertexBuffer:{}},{indexBuffer:void 0,vertexBuffer:{}},{indexBuffer:void 0,vertexBuffer:{}},{indexBuffer:void 0,vertexBuffer:{}},{indexBuffer:void 0,vertexBuffer:{}}]}clone(){const t=new q;for(let e=0;e<this.geometries.length;e++){const s=this.geometries[e],i=t.geometries[e];i.indexBuffer=s.indexBuffer.slice(),i.vertexBuffer={};for(const r in s.vertexBuffer){const{data:n,stride:o}=s.vertexBuffer[r];i.vertexBuffer[r]={data:n.slice(),stride:o}}}return t}static deserialize(t){const e=new q;for(let s=0;s<5;++s){e.geometries[s].indexBuffer=new Uint32Array(t.geometries[s].indexBuffer),e.geometries[s].vertexBuffer={};for(const i in t.geometries[s].vertexBuffer)e.geometries[s].vertexBuffer[i]={data:(0,I.e2)(t.geometries[s].vertexBuffer[i].data,t.geometries[s].vertexBuffer[i].stride),stride:t.geometries[s].vertexBuffer[i].stride}}return e}serialize(){const t={geometries:[{indexBuffer:this.geometries[0].indexBuffer.buffer,vertexBuffer:{}},{indexBuffer:this.geometries[1].indexBuffer.buffer,vertexBuffer:{}},{indexBuffer:this.geometries[2].indexBuffer.buffer,vertexBuffer:{}},{indexBuffer:this.geometries[3].indexBuffer.buffer,vertexBuffer:{}},{indexBuffer:this.geometries[4].indexBuffer.buffer,vertexBuffer:{}}]};for(let e=0;e<5;++e)for(const s in this.geometries[e].vertexBuffer)t.geometries[e].vertexBuffer[s]={data:this.geometries[e].vertexBuffer[s].data.buffer,stride:this.geometries[e].vertexBuffer[s].stride};return t}getBuffers(){const t=[];for(let e=0;e<5;++e){t.push(this.geometries[e].indexBuffer.buffer);for(const s in this.geometries[e].vertexBuffer)t.push(this.geometries[e].vertexBuffer[s].data.buffer)}return t}}var Yt=g(21605);function Mt(a,t,e,...s){t<a.length?a.splice(t,e,...s):a.push(...s)}class Lt{constructor(){this.symbolLevels=[]}replay(t,e,s){for(const i of this.symbolLevels)for(const r of i.zLevels){const n=r.geometryDPInfo.unified;if(n)for(const o of n){const{geometryType:h,materialKey:u,indexFrom:v,indexCount:c}=o,y=Yt.m2.load(u).symbologyType,D=t.painter.getBrush(h,y),b={geometryType:h,materialKey:u,indexFrom:v,indexCount:c,target:e.getGeometry(h)};D.prepareState(t),D.drawGeometry(t,e,b,s)}}}get empty(){return!this.symbolLevels||0===this.symbolLevels.length}clear(){this.symbolLevels.length=0}addToList(t,e){if(Array.isArray(t))for(const s of t)this._addToList(s,e);else this._addToList(t,e)}removeFromList(t){Array.isArray(t)||(t=[t]);let e=null;for(const s of t)e=this._removeFromList(s);return e}clone(){const t=new Lt;for(const e of this.symbolLevels)t.symbolLevels.push(e.clone());return t}splitAfter(t){const e=this._getDisplayList(t.symbolLevel,t.zOrder),s=e.length,i=t.indexFrom+t.indexCount;for(let r=0;r<s;++r){const n=e[r];if(n.geometryType===t.geometryType&&i>n.indexFrom&&i<=n.indexFrom+n.indexCount){if(i<n.indexFrom+n.indexCount){const o=new Tt;o.geometryType=n.geometryType,o.materialKey=n.materialKey,o.indexFrom=i,o.indexCount=n.indexFrom+n.indexCount-i,e.splice(r+1,0,o),n.indexCount=i-n.indexFrom}return r}}}_addToList(t,e){const r=this._getDisplayList(t.symbolLevel,t.zOrder),n=e??r.length-1,o=n>=0&&n<r.length?r[n]:null;if(null!==o&&o.materialKey===t.materialKey&&o.indexFrom+o.indexCount===t.indexFrom&&o.geometryType===t.geometryType)o.indexCount+=t.indexCount;else{const h=new Tt;h.indexFrom=t.indexFrom,h.indexCount=t.indexCount,h.materialKey=t.materialKey,h.geometryType=t.geometryType,Mt(r,n+1,0,h)}}_removeFromList(t){const i=this._getDisplayList(t.symbolLevel,t.zOrder),r=i.length;let n;for(let o=0;o<r;++o){const h=i[o];if(t.indexFrom+t.indexCount>h.indexFrom&&t.indexFrom<h.indexFrom+h.indexCount&&h.geometryType===t.geometryType){n=o;break}}if(void 0!==n){const o=i[n];if(t.indexFrom===o.indexFrom)return o.indexCount-=t.indexCount,o.indexFrom+=t.indexCount,0===o.indexCount&&Mt(i,n,1),n-1;if(t.indexFrom+t.indexCount===o.indexFrom+o.indexCount)return o.indexCount-=t.indexCount,0===o.indexCount?(Mt(i,n,1),n-1):n;{const h=o.indexFrom,u=t.indexFrom-o.indexFrom,v=t.indexCount,c=o.indexFrom+o.indexCount-(t.indexFrom+t.indexCount);o.indexCount=u;const y=new Tt;return y.geometryType=o.geometryType,y.materialKey=o.materialKey,y.indexFrom=h+u+v,y.indexCount=c,Mt(i,n+1,0,y),n}}return null}_getDisplayList(t,e){let s;const i=this.symbolLevels.length;for(let o=0;o<i;o++)if(this.symbolLevels[o].symbolLevel===t){s=this.symbolLevels[o];break}let r;s||(s=new Ut,s.symbolLevel=t,this.symbolLevels.push(s));const n=s.zLevels.length;for(let o=0;o<n;o++)if(s.zLevels[o].zLevel===e){r=s.zLevels[o];break}return r||(r=new Pt,r.geometryDPInfo=new St,r.zLevel=e,s.zLevels.push(r)),r.geometryDPInfo.unified||(r.geometryDPInfo.unified=[]),r.geometryDPInfo.unified}getDPInfoType(){return"unified"}}class Tt{constructor(){this.materialKey=null,this.indexFrom=0,this.indexCount=0}clone(){const t=new Tt;return t.geometryType=this.geometryType,t.materialKey=this.materialKey,t.indexFrom=this.indexFrom,t.indexCount=this.indexCount,t}}class St{constructor(){this.fill=null,this.line=null,this.marker=null,this.text=null,this.label=null,this.unified=null}clone(){const t=new St;return t.fill=this.fill&&this.fill.map(e=>e.clone()),t.line=this.line&&this.line.map(e=>e.clone()),t.marker=this.marker&&this.marker.map(e=>e.clone()),t.text=this.text&&this.text.map(e=>e.clone()),t.label=this.label&&this.label.map(e=>e.clone()),t.unified=this.unified&&this.unified.map(e=>e.clone()),t}}class Pt{constructor(){this.geometryDPInfo=new St}clone(){const t=new Pt;return t.zLevel=this.zLevel,t.geometryDPInfo=this.geometryDPInfo.clone(),t}}class Ut{constructor(){this.zLevels=[]}clone(){const t=new Ut;t.symbolLevel=this.symbolLevel;for(const e of this.zLevels)t.zLevels.push(e.clone());return t}}class jt{constructor(){this.vertexData=new Map,this.vertexCount=0,this.indexData=[]}clear(){this.vertexData.clear(),this.vertexCount=0,this.indexData=[]}update(t,e,s){for(const i in t)this.vertexData.set(i,t[i]);for(const i in this.vertexData)null===t[i]&&this.vertexData.delete(i);this.vertexCount=e,this.indexData=s}}class ut{constructor(t,e,s,i=0,r=0){this.id=t,this.geometryType=e,this.materialKey=s,this.minZoom=i,this.maxZoom=r,this.meshData=null,this.symbolLevel=0,this.zOrder=0,this.vertexFrom=0,this.vertexCount=0,this.indexFrom=0,this.indexCount=0,this._sortKey=null}get sortKey(){return null==this._sortKey&&this._computeSortKey(),this._sortKey}clone(){return this.copy()}copy(){const t=new ut(this.id,this.geometryType,this.materialKey);return t.vertexFrom=this.vertexFrom,t.vertexCount=this.vertexCount,t.indexFrom=this.indexFrom,t.indexCount=this.indexCount,t.zOrder=this.zOrder,t.symbolLevel=this.symbolLevel,t.meshData=this.meshData,t.minZoom=this.minZoom,t.maxZoom=this.maxZoom,t}setMeshDataFromBuffers(t,e,s){const i=new jt;for(const r in e){const n=e[r].stride,o=e[r].data;if(!o)continue;const h=[],u=(0,I.Y8)(n);for(let v=0;v<n*t.vertexCount/u;++v)h[v]=o[v+n*t.vertexFrom/u];i.vertexData.set(r,h)}i.indexData.length=0;for(let r=0;r<t.indexCount;++r)i.indexData[r]=s[r+t.indexFrom]-t.vertexFrom;i.vertexCount=t.vertexCount,this.meshData=i}readMeshDataFromBuffers(t,e){this.meshData?this.meshData.clear():this.meshData=new jt;for(const s in t){const i=t[s].stride,r=t[s].data,n=[],o=(0,I.Y8)(i);for(let h=0;h<i*this.vertexCount/o;++h)n[h]=r[h+i*this.vertexFrom/o];this.meshData.vertexData.set(s,n)}this.meshData.indexData.length=0;for(let s=0;s<this.indexCount;++s)this.meshData.indexData[s]=e[s+this.indexFrom]-this.vertexFrom;this.meshData.vertexCount=this.vertexCount}writeMeshDataToBuffers(t,e,s,i){if(this.meshData){for(const r in e){const n=e[r].stride,o=this.meshData.vertexData.get(r),h=e[r].data,u=(0,I.Y8)(n);for(let v=0;v<n*this.meshData.vertexCount/u;++v)h[v+n*t/u]=o[v]}for(let r=0;r<this.meshData.indexData.length;++r)i[r+s]=this.meshData.indexData[r]+t;this.vertexFrom=t,this.vertexCount=this.meshData.vertexCount,this.indexFrom=s,this.indexCount=this.meshData.indexData.length}}static writeAllMeshDataToBuffers(t,e,s){let i=0,r=0;for(const n of t)n.writeMeshDataToBuffers(i,e,r,s),i+=n.vertexCount,r+=n.indexCount}_computeSortKey(){this._sortKey=(31&this.symbolLevel)<<12|(127&this.zOrder)<<4|7&this.geometryType}serialize(t){return t.push(this.geometryType),t.push(this.materialKey),t.push(this.vertexFrom),t.push(this.vertexCount),t.push(this.indexFrom),t.push(this.indexCount),t.push(this.minZoom),t.push(this.maxZoom),t}static deserialize(t,e){const s=t.readInt32(),i=t.readInt32(),r=new ut(e.id,s,i);return r.vertexFrom=t.readInt32(),r.vertexCount=t.readInt32(),r.indexFrom=t.readInt32(),r.indexCount=t.readInt32(),r.minZoom=t.readInt32(),r.maxZoom=t.readInt32(),r}}function Kt(a,t){if(null!==t){a.push(t.length);for(const e of t)e.serialize(a);return a}a.push(0)}class ct{constructor(t){this.insertAfter=null,this.id=t,this.displayRecords=[]}copy(){const t=new ct(this.id);return t.set(this),t}clone(){const t=new ct(this.id);return t.displayRecords=this.displayRecords.map(e=>e.clone()),t.insertAfter=this.insertAfter,t}set(t){this.id=t.id,this.displayRecords=t.displayRecords,this.insertAfter=t.insertAfter}serialize(t){return t.push(this.id),Kt(t,this.displayRecords),t}static deserialize(t){const e=t.readInt32(),s=new ct(e);return s.displayRecords=function Xt(a,t,e){const s=a.readInt32(),i=new Array(s);for(let r=0;r<i.length;r++)i[r]=t.deserialize(a,e);return i}(t,ut,{id:e})??[],s}}class Dt{constructor(){this.displayObjects=[],this._displayList=null}get displayObjectRegistry(){if(!this._displayObjectRegistry){this._displayObjectRegistry=new Map;for(const t of this.displayObjects)this._displayObjectRegistry.set(t.id,t)}return this._displayObjectRegistry}get displayList(){return this._displayList}computeDisplayList(){this._displayList=new Lt;for(const t of this.displayObjects)for(const e of t.displayRecords)this._displayList.addToList(e)}clone(){const t=new Dt;return this.displayObjects&&(t.displayObjects=this.displayObjects.map(e=>e.clone())),t}serialize(t){return Kt(t,this.displayObjects),t}_deserializeObjects(t){const e=t.readInt32(),s=new Array(e),i=new Map;for(let r=0;r<s.length;++r){const n=ct.deserialize(t);s[r]=n,i.set(n.id,n)}this.displayObjects=s,this._displayList=null,this._displayObjectRegistry=i}static deserialize(t){const e=new Dt;return e._deserializeObjects(t),e}}var Ht=g(46461);class ft{constructor(t,e){this.data=t,this.stride=e}static decode(t){const e=(0,I.e2)(t.data,t.stride);return new ft(e,t.stride)}static fromVertexVector(t){const e=(0,I.e2)(t.data.buffer(),t.stride);return new ft(e,t.stride)}}class pt{constructor(t,e,s){this.geometryType=t,this.indexBuffer=new Uint32Array(e),this.namedBuffers=s}static decode(t){const e=t.geometryType,s=t.indexBuffer,i={};for(const r in t.namedBuffers)i[r]=ft.decode(t.namedBuffers[r]);return new pt(e,s,i)}static fromVertexData(t,e){const s=t.indices,i=(0,I.e2)(t.vertices,t.stride),n={geometry:new ft(i,t.stride)};return new pt(e,s,n)}static fromVertexVectors(t){const e=t.geometryType,s=t.indexVector.buffer(),i={};for(const r in t.namedVectors)i[r]=ft.fromVertexVector(t.namedVectors[r]);return new pt(e,s,i)}}var Bt=g(68741);class Jt{get vertexCount(){const e=this.data.length/(this.stride/4);return e!==(0|e)&&console.debug("Corrupted stride"),e}constructor(t,e){this.data=t,this.stride=e}transfer(t,e){const s=this.data.buffer();t.vertexCount=this.vertexCount,t.data=s,t.stride=this.stride,e.push(s)}}class $t{constructor(t,e,s){this.geometryType=t,this.indexVector=new Bt.Z(Uint32Array,6*e),this.namedVectors={};const i=(0,I.$_)(t,s);for(const r in i){const n=i[r];let o;switch(n%4){case 0:case 2:o=new Bt.Z(Uint32Array,n*e);break;case 1:case 3:o=new Bt.Z(Uint8Array,n*e)}this.namedVectors[r]=new Jt(o,n)}}get(t){return this.namedVectors[t].data}getVector(t){return this.namedVectors[t]}transfer(t,e){const s=this.indexVector.buffer(),i={};e.push(s);for(const r in this.namedVectors){const n=this.namedVectors[r];i[r]={},n.transfer(i[r],e)}t.geometryType=this.geometryType,t.indexBuffer=s,t.namedBuffers=i,this.destroy()}intoBuffers(){const t=pt.fromVertexVectors(this);return this.destroy(),t}destroy(){this.indexVector=null,this.namedVectors=null}}const It=new ht,mt=new ht;function qt(a,t){const e={};for(const s in a){const i={data:(0,I.C$)(t,a[s]),stride:a[s]};e[s]=i}return e}class st{constructor(){this.tileDisplayData=null,this.tileBufferData=null}reshuffle(){if(It.reset(),!this.tileDisplayData)return;const t=function ee(a){const t=[[],[],[],[],[]],e=a;for(const s of e)for(const i of s.displayRecords)t[i.geometryType].push(i);return t}(this.tileDisplayData.displayObjects);for(const n of t)for(const o of n)o&&It.needMore(o.geometryType,o.meshData?o.meshData.vertexCount:o.vertexCount,o.meshData?o.meshData.indexData.length:o.indexCount);const e=t.length,s=new q;for(let n=0;n<e;++n){s.geometries[n].indexBuffer=new Uint32Array(Math.round(1.5*It.indicesFor(n)));const o=[],h=this.tileBufferData?.geometries[n].vertexBuffer;if(!h)continue;for(const y in h)o.push(h[y].stride);const u=st._computeVertexAlignment(o),v=Math.round(1.5*It.verticesFor(n)),c=st._align(v,u);for(const y in h){const D=h[y].stride;s.geometries[n].vertexBuffer[y]={stride:D,data:(0,I.C$)(c,D)}}}mt.reset(),this.tileDisplayData.displayList?.clear();for(let n=0;n<e;++n){const o=t[n];for(const h of o){if(h.meshData)h.writeMeshDataToBuffers(mt.verticesFor(n),s.geometries[n].vertexBuffer,mt.indicesFor(n),s.geometries[n].indexBuffer),h.meshData=null;else{const u=this.tileBufferData?.geometries[n];if(u){const v=u.vertexBuffer,c=u.indexBuffer,y=s.geometries[n].vertexBuffer,D=s.geometries[n].indexBuffer,b=mt.verticesFor(n),S=mt.indicesFor(n);(0,I.wO)(b,S,y,D,h,v,c),h.vertexFrom=b,h.indexFrom=S}}mt.needMore(n,h.vertexCount,h.indexCount)}}const{displayList:i,displayObjects:r}=this.tileDisplayData;if(i)for(const n of r)i.addToList(n.displayRecords);this.tileBufferData=s}getStrides(){const t=[],e=this.tileBufferData?.geometries;if(!e)return t;for(let s=0;s<e.length;++s){const i=e[s];t[s]={};for(const r in i.vertexBuffer)t[s][r]=i.vertexBuffer[r].stride}return t}clone(){const t=new st;return t.tileBufferData=this.tileBufferData?.clone()??null,t.tileDisplayData=this.tileDisplayData?.clone()??null,t}_guessSize(){const t=this.tileDisplayData?.displayObjects??[],e=Math.min(t.length,4);let r=0;for(let n=0;n<e;n++)r=Math.max(r,t[n].displayRecords.length);return 2*(12*t.length+t.length*r*40)}serialize(){const t=this.tileBufferData.serialize(),e=this.tileBufferData.getBuffers(),s=this.tileDisplayData.serialize(new Bt.Z(Int32Array,this._guessSize())).buffer();return e.push(s),{result:{displayData:s,bufferData:t},transferList:e}}static fromVertexData(t,e){const s={},i=new Map;for(const r of e)i.set(r.id,r);return(0,I.Z_)(r=>{const n=t.data[r];if((0,d.pC)(n)){const o=Ht.$.from(n.records).getCursor();for(;o.next();){const h=o.id,u=o.materialKey,v=o.indexFrom,c=o.indexCount,y=o.vertexFrom,D=o.vertexCount,b=i.get(h),S=new ut(h,r,u);S.indexFrom=v,S.indexCount=c,S.vertexFrom=y,S.vertexCount=D,b.displayRecords.push(S)}s[r]=pt.fromVertexData(n,r)}else s[r]=new $t(r,0,x.mD.DEFAULT).intoBuffers()}),st.fromMeshData({displayObjects:e,vertexBuffersMap:s})}static fromMeshData(t){const e=new st,s=new Dt,i=new q;s.displayObjects=t.displayObjects;for(const r in t.vertexBuffersMap){const n=t.vertexBuffersMap[r];i.geometries[r].indexBuffer=n.indexBuffer,i.geometries[r].vertexBuffer=n.namedBuffers}return e.tileDisplayData=s,e.tileBufferData=i,e}static bind(t,e){const s=new st;return s.tileDisplayData=t,s.tileBufferData=e,s}static create(t,e){const s=new st;s.tileDisplayData=new Dt,s.tileDisplayData.displayObjects=t;const i=[0,0,0,0,0],r=[0,0,0,0,0],n=[[],[],[],[],[]];for(const u of t)for(const v of u.displayRecords)n[v.geometryType].push(v),i[v.geometryType]+=v.meshData.vertexCount,r[v.geometryType]+=v.meshData.indexData.length;const o=new q,h=function te(a){return[a.fill||{},a.line||{},a.icon||{},a.text||{},a.label||{}]}(e);for(let u=0;u<5;u++){const v=new Uint32Array(r[u]),c=qt(h[u],i[u]);ut.writeAllMeshDataToBuffers(n[u],c,v),o.geometries[u]={indexBuffer:v,vertexBuffer:c}}return s.tileBufferData=o,s}static _align(t,e){const s=t%e;return 0===s?t:t+(e-s)}static _computeVertexAlignment(t){let e=!1,s=!1;for(const i of t)i%4==2?e=!0:i%4!=0&&(s=!0);return s?4:e?2:1}}var se=g(29541),ie=g(13615),re=g(79222),ne=g(61995),At=g(30250),oe=g(25534),ae=g(26440),Rt=g(50805),he=g(80074),le=g(80416);class Ft extends le.i{static from(t,e,s){const i=he.s.createInstance(),r=[],n=t.filter(o=>!!o.geometry);for(const o of n){const h=(0,F.Ji)(o.geometry);(0,Rt.E7)(r,[o],h,!1,!1,e)}return new Ft(i,r,s)}constructor(t,e,s){super(t,e,null),this._transform=s}get geometryType(){const t=this._current;return t?t.geometryType:null}get insertAfter(){return this._current.insertAfter}readGraphic(){return this._current}getCursor(){return this.copy()}copy(){const t=new Ft(this.instance,this._features,this._transform);return this.copyInto(t),t}}var Ot=g(55798),de=g(34662),ue=g(71949),ce=g(42758),fe=g(14862),pe=g(78127),_t=g(6099),kt=g(93846);const bt=new kt.Z,zt=new kt.Z,Wt="esriGeometryPolyline";function Nt(a){a.coords.length=0,a.lengths.length=0}class rt{constructor(){this.bounds=(0,L.Ue)(),this.graphic=null}static acquire(t=null,e,s,i,r){let n;return 0===rt._pool.length?n=new rt:(n=rt._pool.pop(),this._set.delete(n)),n.acquire(t,e,s,i,r),n}static release(t){t&&!this._set.has(t)&&(t.release(),this._pool.push(t),this._set.add(t))}static getCentroidQuantized(t,e){if((0,F.oU)(t.geometry)){const s=t.symbol;if((0,d.Wi)(s))return null;if(s?.layers.length>0&&s.layers.some(i=>"text"===i.type||"marker"===i.type)){const i=(0,pe.tO)(t.geometry);return null!==i?(0,_t.RF)(e,{},{x:i[0],y:i[1]},!1,!1):null}}return null}acquire(t=null,e,s,i,r){t&&this.set(t,e,s,i,r)}release(){this.graphic=null,this.symbolResource=null,this.geometry=null}get symbol(){return this.symbolResource.symbol}set(t,e,s,i,r){this.graphic=t,this.geometry=s,this.symbolResource=e,this.bounds=i,r&&(this.size=r)}getGeometryQuantized(t,e,s,i){const r=this.geometry,n=(0,F.Ji)(r);if((0,d.Wi)(n))return null;switch(n){case"esriGeometryPolygon":{const o=r,{rings:h}=o;if(!h||0===h.length)return null;let u;if(u=(0,_t.ym)(t,1===h.length&&2===h[0].length?{paths:[[h[0][0],h[0][1]]]}:this.geometry),!u&&(u=(0,_t.ym)(t,{x:h[0][0][0],y:h[0][0][1]}),u)){const{x:c,y}=u;return{rings:[[[c-1,y],[1,-1],[1,1],[-1,1],[-1,-1]]]}}return u}case"esriGeometryPolyline":{const o=r;Nt(bt),Nt(zt);const h=o.hasZ??!1,u=o.hasM??!1;return(0,Rt.u0)(bt,o),(0,Rt.zj)(zt,bt,h,u,Wt,t.scale[0]),(0,Rt.Nh)(bt,zt,h,u,Wt,t),(0,Rt.J6)(bt,o.hasZ??!1,o.hasM??!1)}case"esriGeometryMultipoint":{const o=r,h=.5*i*Math.max(Math.abs(this.size[0])+this.size[2]-this.size[0],Math.abs(this.size[1])+this.size[3]-this.size[1]),u=(0,m.C5)(s);let v=o.points;if(u){const[c,y]=u.valid,D=y-c;v=v.filter(b=>{if(b[0]+h>y||b[0]-h<c){const S=[...b];return b[0]+h>y?S[0]-=D:S[0]+=D,(0,L.Zm)(e,b,h)||(0,L.Zm)(e,S,h)}return(0,L.Zm)(e,b,h)})}return 0===v.length?{points:v}:(0,_t.ym)(t,{points:v})}}return(0,_t.ym)(t,this.geometry)}}rt._pool=[],rt._set=new Set;var V=g(48068);const Et={minX:0,minY:0,maxX:0,maxY:0},yt=(0,L.Ue)();function wt(a,t,e,s,i){return Et.minX=t,Et.minY=e,Et.maxX=s,Et.maxY=i,a.search(Et)}function me(a){return{minX:a.bounds[0],minY:a.bounds[1],maxX:a.bounds[2],maxY:a.bounds[3]}}class _e{constructor(t,e,s,i,r,n,o){this._graphics=i,this._onAdd=r,this._onRemove=n,this._hashToCIM=o,this._index=(0,de.r)(9,me),this._itemByGraphic=new Map,this._inflatedSizeHelper=new p.bP,this._tileInfoView=t,this._uidFieldName=s;const h=t.getClosestInfoForScale(e);h&&(this._resolution=this._tileInfoView.getTileResolution(h.level))}setResourceManager(t){this._cimResourceManager=t,this._hittestDrawHelper=new fe.Tu(t)}hitTest(t,e,s,i,r){t=(0,ce.or)(t,this._tileInfoView.spatialReference);const n=.5*i*window.devicePixelRatio*s;yt[0]=t-n,yt[1]=e-n,yt[2]=t+n,yt[3]=e+n;const o=.5*i*(s+V.y1),h=wt(this._index,t-o,e-o,t+o,e+o);if(!h||0===h.length)return[];const u=[],v=(0,L.Ue)(),c=(0,L.Ue)();for(const b of h){const{geometry:S,symbolResource:J}=b;this._getSymbolBounds(v,J,S,c,r),c[3]=c[2]=c[1]=c[0]=0,(0,L.kK)(v,yt)&&b.graphic?.visible&&u.push(b)}if(0===u.length)return[];const y=this._hittestDrawHelper,D=[];for(const b of u){const{geometry:S,symbolResource:J}=b,{hash:tt,textInfo:at}=J,lt=this._hashToCIM.get(tt);lt&&y.hitTest(yt,lt.symbol,S,at,r,i)&&D.push(b)}return D.sort(ye),D.map(b=>b.graphic)}getGraphicsData(t,e,s){const i=this._searchForItems(e);if(0===i.length||0===s.length)return[];i.sort((c,y)=>c.zorder-y.zorder),i[0].insertAfter=-1;for(let c=1;c<i.length;c++)i[c].insertAfter=i[c-1].graphic.uid;i.sort((c,y)=>c.graphic.uid-y.graphic.uid),s.sort((c,y)=>c.uid-y.uid);let r,n=0,o=0;const h=e.resolution,u=[],v={originPosition:"upperLeft",scale:[h,h],translate:[e.bounds[0],e.bounds[3]]};for(const c of s){for(o=-2;n<i.length;)if(r=i[n],n++,c.uid===r.graphic.uid){o=r.insertAfter;break}if(!r?.geometry||-2===o)continue;const y=r.getGeometryQuantized(v,e.bounds,this._tileInfoView.spatialReference,h),D={...r.graphic.attributes};D[this._uidFieldName]=c.uid,null==r.groupId&&(r.groupId=t.createTemplateGroup(r.symbol,null)),u.push({centroid:rt.getCentroidQuantized(r,v),geometry:y,attributes:D,symbol:r.symbol,groupId:r.groupId,insertAfter:o,zorder:r.zorder})}return u.sort((c,y)=>c.zorder-y.zorder),u}queryTileData(t,e){if(0===this._graphics.length)return[];const{bounds:s,resolution:i}=e,r=this._searchForItems(e),n=[];return 0===r.length||this._createTileGraphics(n,t,r,{originPosition:"upperLeft",scale:[i,i],translate:[s[0],s[3]]},e),n}has(t){return this._itemByGraphic.has(t)}getBounds(t){const e=this._itemByGraphic.get(t);return e?e.bounds:null}getAllBounds(){return Array.from(this._itemByGraphic.values()).filter(t=>t.graphic.visible).map(t=>t.bounds)}addOrModify(t,e,s){if(!t||(0,d.Wi)(e))return;this.has(t)&&this.remove(t),this._onAdd(t);const i=[0,0,0,0],r=this._getSymbolBounds(null,e,s,i,0),n=rt.acquire(t,e,s,(0,d.pC)(r)?r:null,i);return this._itemByGraphic.set(t,n),s&&this._index.insert(n),n.bounds}remove(t){if(!this._itemByGraphic.has(t))return;this._onRemove(t);const e=this._itemByGraphic.get(t);e?.bounds&&this._index.remove(e),this._itemByGraphic.delete(t)}updateZ(){const t=this._graphics.items;let e,s;for(let i=0;i<t.length;i++)s=t[i],e=this._itemByGraphic.get(s),e&&(e.zorder=i)}update(t,e,s){const i=this._itemByGraphic.get(t);i.groupId=null;const r=(0,L.d9)(i.bounds);this._index.remove(i);const n=this._getSymbolBounds(i.bounds,e,s,i.size,0);return(0,d.pC)(n)&&i.set(t,e,s,n,i.size),s&&this._index.insert(i),{oldBounds:r,newBounds:i.bounds}}updateLevel(t){if(this._resolution===t)return;this._resolution=t,this._index.clear();const e=this._itemByGraphic,s=[];for(const[i,r]of e){const n=this._getSymbolBounds(r.bounds,r.symbolResource,r.geometry,r.size,0);r.geometry&&(0,d.pC)(n)&&(r.bounds=n,s.push(r))}this._index.load(s)}clear(){this._itemByGraphic.clear(),this._index.clear()}_createTileGraphics(t,e,s,i,r){const n=this._uidFieldName,o=this._tileInfoView.spatialReference,{bounds:h,resolution:u}=r;let v,c,y,D;s.sort((b,S)=>b.zorder-S.zorder);for(let b=0;b<s.length;b++){y=s[b],v=y.graphic,c=y.getGeometryQuantized(i,h,o,u),D=0===b?-1:s[b-1].graphic.uid;const S={...y.graphic.attributes};S[n]=v.uid,null==y.groupId&&(y.groupId=e.createTemplateGroup(y.symbol,null)),t.push({centroid:rt.getCentroidQuantized(y,i),geometry:c,attributes:S,symbol:y.symbol,groupId:y.groupId,insertAfter:D,zorder:y.zorder})}}_searchForItems(t){const e=this._tileInfoView.spatialReference,s=t.bounds,i=(0,m.C5)(e);if(i&&e.isWrappable){const[r,n]=i.valid,o=Math.abs(s[2]-n)<1e-5,h=Math.abs(s[0]-r)<1e-5;if((!o||!h)&&(o||h)){const u=t.resolution;let v;v=(0,L.Ue)(o?[r,s[1],r+u*V.y1,s[3]]:[n-u*V.y1,s[1],n,s[3]]);const c=wt(this._index,s[0],s[1],s[2],s[3]),y=wt(this._index,v[0],v[1],v[2],v[3]);return[...new Set([...c,...y])]}}return wt(this._index,s[0],s[1],s[2],s[3])}_getSymbolBounds(t,e,s,i,r){if(!e||!e.symbol||!s)return null;if(t||(t=(0,L.Ue)()),(0,ue.$P)(t,s),!i||0===i[0]&&0===i[1]&&0===i[2]&&0===i[3]){const{hash:h,textInfo:u}=e,v=this._hashToCIM.get(h);if(!v)return null;i||(i=[0,0,0,0]);const c=this._inflatedSizeHelper.getSymbolInflateSize(i,v.symbol,this._cimResourceManager,r,u);i[0]=(0,Ot.F2)(c[0]),i[1]=(0,Ot.F2)(c[1]),i[2]=(0,Ot.F2)(c[2]),i[3]=(0,Ot.F2)(c[3])}const n=this._resolution,o=p.bP.safeSize(i);return t[0]-=o*n,t[1]-=o*n,t[2]+=o*n,t[3]+=o*n,t}}const ye=(a,t)=>{const e=(0,V.eT)(a.graphic),s=(0,V.eT)(t.graphic);return e===s?t.zorder-a.zorder:e-s};var ge=g(50439),xe=g(20711);const ve=a=>{let t=class extends((0,xe.IG)(a)){constructor(){super(...arguments),this.graphics=null,this.renderer=null}};return(0,O._)([(0,B.Cb)()],t.prototype,"graphics",void 0),(0,O._)([(0,B.Cb)()],t.prototype,"renderer",void 0),(0,O._)([(0,B.Cb)()],t.prototype,"updating",void 0),(0,O._)([(0,B.Cb)()],t.prototype,"view",void 0),t=(0,O._)([(0,X.j)("esri.views.layers.GraphicsView")],t),t};var Ce=g(86626),Te=g(81945);const De=(0,G.Z)("esri-2d-graphic-debug");function Gt(a,t,e){let s=e.get(a);return s||(s={tile:t,addedOrModified:[],removed:[]},e.set(a,s)),s}let it=class extends(ve((0,C.p)(z.Z))){constructor(a){super(a),this._storage=new ae.O,this._displayIds=new Map,this._controller=new AbortController,this._tiles=new Map,this._graphicStoreUpdate=!1,this._graphicsSet=new Set,this._matcher=Promise.resolve(null),this._tileUpdateSet=new Set,this._tilesToUpdate=new Map,this._graphicIdToAbortController=new Map,this._attached=!1,this._updatingGraphicsTimer=null,this._hashToExpandedSymbol=new Map,this._hashToExpandedSymbolPromise=new Map,this._hashToCIMSymbolPromise=new Map,this._hashToCIM=new Map,this._processing=!1,this._needsProcessing=!1,this._pendingUpdate={added:new Set,updated:new Set,removed:new Set},this.lastUpdateId=-1,this.updateRequested=!1,this.defaultPointSymbolEnabled=!0,this.graphicUpdateHandler=this.graphicUpdateHandler.bind(this)}destroy(){this._updatingGraphicsTimer&&(clearTimeout(this._updatingGraphicsTimer),this._updatingGraphicsTimer=null,this.notifyChange("updating")),this._controller.abort(),this.container.destroy(),this._set("graphics",null),this._graphicStore.clear(),this._attributeStore=null,this._hashToExpandedSymbol.clear(),this.view=null,this.renderer=null,this._hashToCIM.clear(),this._hashToCIMSymbolPromise.clear(),this._hashToExpandedSymbolPromise.clear()}_createMatcher(a,t,e){if(a){const s=(0,At.q5)(a),i=(0,At.MD)({indexCount:0,fields:{}},"feature",a,s);this._matcher=(0,ne.fL)(i,t,null,e)}}_createDisplayId(a){let t=this._displayIds.get(a);return t||(t=this._storage.createDisplayId(),this._displayIds.set(a,t)),t}initialize(){this._attributeStore=new oe.Z({type:"local",initialize:i=>Promise.resolve(this.container.attributeView.initialize(i)),update:i=>this.container.attributeView.requestUpdate(i),render:()=>this.container.requestRender()},(0,Ce.hc)("2d"),()=>this.notifyChange("updating")),this.container.hasHighlight=()=>this._attributeStore.hasHighlight;const e=new re.Wr(this.container.getMaterialItems.bind(this.container),this.view.featuresTilingScheme.tileInfo);this._graphicStore=new _e(this.view.featuresTilingScheme,this.view.state.scale,this.uid,this.graphics,i=>{this._createDisplayId(i.uid),this._setFilterState(i.uid,i.visible)},i=>{const r=this._displayIds.get(i.uid);this._displayIds.delete(i.uid),this._storage.releaseDisplayId(r)},this._hashToCIM),this._meshFactory=new ie.j(null,this.uid,e),this._templateStore=e,this.handles.add([(0,E.YP)(()=>this.renderer,i=>{this._createMatcher(i,e,this.container.stage.resourceManager);for(const r of this.graphics)this._pendingUpdate.updated.add(r);this.requestUpdate()}),this.view.graphicsTileStore.on("update",this._onTileUpdate.bind(this)),this.container.on("attach",()=>{De&&this.container.enableRenderingBounds(()=>this._graphicStore.getAllBounds()),this.graphics.items.length>0&&this._graphicsChangeHandler({target:this.graphics,added:this.graphics.items,removed:[],moved:[]}),this.handles.add(this.graphics.on("change",r=>this._graphicsChangeHandler(r)),"graphics");const i=this.container.stage.resourceManager;this._createMatcher(this.renderer,e,i),this._graphicStore.setResourceManager(i),this._attached=!0,this.notifyChange("updating")})]),this._onTileUpdate({added:this.view.graphicsTileStore.tiles,removed:[]})}get updating(){return!this._attached||null!==this._updatingGraphicsTimer||this._tileUpdateSet.size>0||this._tilesToUpdate.size>0||this._attributeStore.isUpdating()}hitTest(a){if(!this.view||!this.view.position)return[];const{resolution:t,rotation:e}=this.view.state;return this._graphicStore.hitTest(a.x,a.y,2,t,e)}update(a){(0,T.k_)(this._controller.signal);const t=a.state,{resolution:e}=t;if(this._graphicStore.updateLevel(e),this._graphicStoreUpdate=!0,this.updateRequested=!1,this._pendingUpdate.updated.size>0){if(!this._processing)return void this._updateGraphics();this._needsProcessing=!0}}viewChange(){this.requestUpdate()}requestUpdate(){this.updateRequested||(this.updateRequested=!0,this.requestUpdateCallback())}processUpdate(a){this.updateRequested&&(this.updateRequested=!1,this.update(a))}graphicUpdateHandler(a){const{graphic:t,property:e}=a;switch(e){case"attributes":case"geometry":case"symbol":this._pendingUpdate.updated.add(t),this.requestUpdate();break;case"visible":this._setFilterState(t.uid,t.visible),this._attributeStore.sendUpdates()}}setHighlight(a){const t=a.map(e=>this._displayIds.get(e)).filter(d.pC);this._attributeStore.setHighlight(a,t)}_getIntersectingTiles(a){const t=this._graphicStore.getBounds(a);if(!t||0===(0,L.bf)(t)||0===(0,L.Cb)(t))return[];const e=(0,V.Zu)(t,this.view.spatialReference);return(0,d.pC)(e)?[...new Set([...this.view.graphicsTileStore.boundsIntersections(e[0]),...this.view.graphicsTileStore.boundsIntersections(e[1])])]:this.view.graphicsTileStore.boundsIntersections(t)}_updateTile(a){var t=this;return(0,j.Z)(function*(){(0,T.k_)(t._controller.signal);const e=a.tile,s=t._getGraphicsData(t._templateStore,e,a.addedOrModified),i=yield t._processGraphics(e,s);return(0,T.k_)(t._controller.signal),t._patchTile(e.key,{type:"update",addOrUpdate:i,remove:a.removed,end:!0,clear:!1,sort:!1}),i})()}_patchTile(a,t){const e=this._tiles.get(a);e&&(this.container.onTileData(e,t),this.container.requestRender())}_graphicsChangeHandler(a){const t=this._pendingUpdate;for(const e of a.added)t.added.add(e);for(const e of a.moved)t.updated.add(e);for(const e of a.removed)this._pendingUpdate.added.has(e)?t.added.delete(e):t.removed.add(e);this._processing?this._needsProcessing=!0:this._updateGraphics()}_getGraphicsToUpdate(){const a={added:[],removed:[],updated:[]};if(!this.graphics)return a;const t=this._pendingUpdate;for(const e of this.graphics.items)t.added.has(e)?a.added.push(e):t.updated.has(e)&&a.updated.push(e);for(const e of t.removed)this._graphicStore.has(e)&&a.removed.push(e);return t.added.clear(),t.removed.clear(),t.updated.clear(),a}_updateGraphics(){var a=this;return(0,j.Z)(function*(){a._processing=!0;const{added:t,removed:e,updated:s}=a._getGraphicsToUpdate(),i=a._tilesToUpdate;let r;try{if(!a._graphicStoreUpdate){const c=a.view.state,{resolution:y}=c;a._graphicStore.updateLevel(y)}const n=[],o=new Array(t.length+e.length);for(let c=0;c<s.length;c++){const y=s[c],D=a._getIntersectingTiles(y);for(const b of D)r=b.id,Gt(r,b,i).removed.push(a._displayIds.get(y.uid));n.push(a._updateGraphic(y,null)),o[c]=y}const h=s.length;for(let c=0;c<t.length;c++){const y=t[c];o[h+c]=y,a._graphicsSet.add(y),n.push(a._addGraphic(y))}for(const c of e){a._abortProcessingGraphic(c.uid);const y=a._getIntersectingTiles(c);for(const D of y)r=D.id,Gt(r,D,i).removed.push(a._displayIds.get(c.uid));a._graphicsSet.delete(c),a._graphicStore.remove(c)}let u;a._flipUpdatingGraphics(),yield Promise.all(n);for(let c=0;c<o.length;c++){u=o[c];const y=a._getIntersectingTiles(u);for(const D of y)r=D.id,Gt(r,D,i).addedOrModified.push(u)}a._graphicStore.updateZ();const v=[];for(const[c,y]of i)v.push(a._updateTile(y));yield Promise.all(v)}catch(n){(0,T.D_)(n)}for(const n of e)try{const o=yield a._getSymbolForGraphic(n,null);if(o){const h=o.hash();a._hashToExpandedSymbol.delete(h)}}catch(o){(0,T.D_)(o)}i.clear(),a.notifyChange("updating"),a._processing=!1,a._needsProcessing&&(a._needsProcessing=!1,a._updateGraphics())})()}_getArcadeInfo(a){const t=(a.attributes?Object.keys(a.attributes):[]).map(e=>({name:e,alias:e,type:"string"==typeof a.attributes[e]?"esriFieldTypeString":"esriFieldTypeDouble"}));return(0,d.Wi)(a.geometry)?null:{geometryType:(0,F.Ji)(a.geometry),spatialReference:Q.Z.fromJSON(a.geometry.spatialReference),fields:t}}_getSymbolForGraphic(a,t){return(0,T.k_)(this._controller.signal),(0,d.pC)(a.symbol)?Promise.resolve(a.symbol):(0,d.pC)(this.renderer)?this.renderer.getSymbolAsync(a,{scale:this.view.scale,signal:(0,d.pC)(t)?t.signal:null}):Promise.resolve(this._getNullSymbol(a))}_getCIMSymbol(a,t,e){let s=this._hashToCIM.get(t);if(s)return Promise.resolve(s);const i=(0,p.rW)(a);if((0,d.pC)(i)){if("CIMSymbolReference"===i.type)return s=i,this._hashToCIM.set(t,s),Promise.resolve(s);let r=this._hashToCIMSymbolPromise.get(t);return r||(r=i.fetchCIMSymbol(e).then(n=>(this._hashToCIM.set(t,n.data),this._hashToCIMSymbolPromise.delete(t),n)).catch(n=>(this._hashToCIMSymbolPromise.delete(t),(0,T.r9)(n),null)),this._hashToCIMSymbolPromise.set(t,r),r)}return Promise.resolve(null)}_expandCIMSymbol(a,t,e,s){const i=this._hashToExpandedSymbol.get(e);if(i)return Promise.resolve(i);let r=this._hashToExpandedSymbolPromise.get(e);if(r)return r;const n=this.container.stage,o=this._getArcadeInfo(t),h=(0,At.q5)(null),u=(0,Te.createSymbolSchema)(a,h);return r=(0,ge.B)(u,o,n.resourceManager,s),this._hashToExpandedSymbolPromise.set(e,r),r.then(v=>(this._hashToExpandedSymbol.set(e,v),this._hashToExpandedSymbolPromise.delete(e),v)),r}_getSymbolResources(a,t){var e=this;return(0,j.Z)(function*(){return(0,T.k_)(e._controller.signal),e.container.stage?e._getSymbolForGraphic(a,t).then(s=>{if(!s)return null;const i=s.hash();return e._getCIMSymbol(s,i,t).then(r=>(0,d.Wi)(r)?null:e._expandCIMSymbol(r,a,i,t).then(n=>{const o=n.layers.filter(h=>"text"===h.type&&"string"==typeof h.text);if(o&&o.length>0){const h=new Array(o.length);for(let v=0;v<o.length;v++){const c=o[v],y=[],[D]=(0,k.E)(c.text);c.text=D;for(let b=0;b<D.length;b++)y.push(D.charCodeAt(b));h[v]={symbol:c,id:v,glyphIds:y}}const u=new Map;return e.container.getMaterialItems(h).then(v=>{(0,d.O3)(v);for(let c=0;c<o.length;c++){const y=o[c];u.set(y.cim,{text:y.text,mosaicItem:v[c].mosaicItem})}return{symbol:n,textInfo:u,hash:i}})}return{symbol:n,hash:i}}))}).catch(s=>((0,T.r9)(s),null)):null})()}_projectAndNormalizeGeometry(a,t){var e=this;return(0,j.Z)(function*(){if((0,T.k_)(e._controller.signal),(0,d.Wi)(a.geometry)||"mesh"===a.geometry.type)return null;let s=a.geometry;if((0,F.oU)(s))s.rings=s.rings;else if((0,F.l9)(s))s.paths=s.paths;else if((0,F.YX)(s)){const n=yield e._getSymbolForGraphic(a,t);(0,T.k_)(e._controller.signal),s=n&&((0,V.yA)(n.type)||(0,V.ab)(n.type))?s.center:(0,V.XA)(s)}yield(0,R._W)(s.spatialReference,e.view.spatialReference);const i=(0,Z.SR)(s),r=(0,R.iV)(i,s.spatialReference,e.view.spatialReference);return r&&(0,W.pW)(r),r})()}_onTileUpdate(a){const t=(0,m.C5)(this.view.spatialReference);if(a.added&&a.added.length>0)for(const e of a.added)this._addNewTile(e,t);if(a.removed&&a.removed.length>0)for(const e of a.removed)this._removeTile(e.key)}_addGraphic(a){var t=this;return(0,j.Z)(function*(){t._abortProcessingGraphic(a.uid),(0,T.k_)(t._controller.signal);const e=new AbortController;t._graphicIdToAbortController.set(a.uid,e);const s={signal:e.signal};try{yield t._addOrUpdateGraphic(a,s),(0,T.k_)(t._controller.signal),t._graphicIdToAbortController.delete(a.uid)}catch(i){if(t._graphicIdToAbortController.delete(a.uid),!(0,T.D_)(i))throw i}})()}_updateGraphic(a,t){(0,T.k_)(this._controller.signal);const e=this._projectAndNormalizeGeometry(a,t),s=this._getSymbolResources(a,t);return Promise.all([e,s]).then(([i,r])=>{(0,T.k_)(this._controller.signal),this._graphicStore.addOrModify(a,r,i)})}_addOrUpdateGraphic(a,t){(0,T.k_)(this._controller.signal);const e=this._projectAndNormalizeGeometry(a,t),s=this._getSymbolResources(a,t);return Promise.all([e,s]).then(([i,r])=>{(0,T.k_)(this._controller.signal),this._graphicsSet.has(a)&&this._graphicStore.addOrModify(a,r,i)})}_addTile(a){const t=this.view.featuresTilingScheme.getTileBounds((0,L.Ue)(),a),e=this.view.featuresTilingScheme.getTileResolution(a.level),s=new Ct(a,e,t[0],t[3]);return this._tiles.set(a,s),this.container.addChild(s),s}_addNewTile(a,t){var e=this;return(0,j.Z)(function*(){const s=e._addTile(a.key),i=e._graphicStore.queryTileData(e._templateStore,a);if(0===i.length)return;if(t){const n=Math.round((t.valid[1]-t.valid[0])/a.resolution);for(const o of i)o.geometry&&((0,F.wp)(o.geometry)||(0,F.aW)(o.geometry))&&e._wrapPoints(o,n)}const r=a.key;e._tileUpdateSet.add(a.key),e.notifyChange("updating");try{const n={type:"update",clear:!1,addOrUpdate:yield e._processGraphics(a,i),remove:[],end:!0,sort:!1};s.patch(n),e._tileUpdateSet.delete(r),e.notifyChange("updating")}catch(n){if(e._tileUpdateSet.delete(r),e.notifyChange("updating"),!(0,T.D_)(n))throw n}})()}_removeTile(a){if(!this._tiles.has(a))return;const t=this._tiles.get(a);this.container.removeChild(t),t.destroy(),this._tiles.delete(a)}_setFilterState(a,t){const e=this._displayIds.get(a),s=this._attributeStore.getHighlightFlag(a);this._attributeStore.setData(e,0,0,s|(t?f.Zd:0))}_getGraphicsData(a,t,e){const i=(0,m.C5)(this.view.spatialReference),r=this._graphicStore.getGraphicsData(a,t,e);if(i){const n=Math.round((i.valid[1]-i.valid[0])/t.resolution);for(const o of r)o.geometry&&((0,F.wp)(o.geometry)||(0,F.aW)(o.geometry))&&this._wrapPoints(o,n)}return r}_wrapPoints(a,t){const e=a.geometry;(0,F.aW)(e)?this._wrapMultipoint(e,t):this._wrapPoint(a,t)}_wrapMultipoint(a,t){const e=a.points,s=[];let i=0,r=0;for(const[n,o]of e){if(s.push([n+i,o]),i=0,t===V.I_){const h=5*V.y1;n+r<h?(s.push([t,0]),i=-t):n+r>V.I_-h&&(s.push([-t,0]),i=t)}else n+r<-V.y1?(s.push([t,0]),i=-t):n+r>V.I_+V.y1&&(s.push([-t,0]),i=t);r+=n}a.points=s}_wrapPoint(a,t){const e=a.geometry;if(t===V.I_){const s=5*V.y1;e.x<s?a.geometry={points:[[e.x,e.y],[t,0]]}:e.x>V.I_-s&&(a.geometry={points:[[e.x,e.y],[-t,0]]})}else e.x<-V.y1?a.geometry={points:[[e.x,e.y],[t,0]]}:e.x>V.I_+V.y1&&(a.geometry={points:[[e.x,e.y],[-t,0]]})}_processGraphics(a,t,e){if(!t||!t.length||!this._meshFactory)return Promise.resolve(null);const s=Ft.from(t,this.uid,a.transform),i=this._meshFactory;return this._matcher.then(r=>i.analyzeGraphics(s,this.container.stage.resourceManager,r,null,null,e).then(()=>(this._attributeStore.sendUpdates(),this._processAnalyzedGraphics(a,s))))}_processAnalyzedGraphics(a,t){const e=this._meshFactory,s=t.getSize(),i=t.getCursor(),n=new se._(a.key.id,{features:s,records:s,metrics:0},x.mD.DEFAULT,!1,!1),o=[];for(;i.next();){const c=i.readGraphic();c.insertAfter=-1===c.insertAfter?-1:this._displayIds.get(c.insertAfter),c.displayId=this._displayIds.get(c.attributes[this.uid]);const y=new ct(c.displayId);y.insertAfter=c.insertAfter,o.push(y),e.writeGraphic(n,i,a.level,this.container.stage.resourceManager)}const u=n.serialize(a.tileInfoView.tileInfo.isWrappable);return 1!==u.length?new st:st.fromVertexData(u[0].message,o)}_abortProcessingGraphic(a){this._graphicIdToAbortController.get(a)?.abort()}_getNullSymbol(a){const t=a.geometry;return(0,F.l9)(t)?l.mW:(0,F.oU)(t)||(0,F.YX)(t)?l.kD:this.defaultPointSymbolEnabled?l.G:null}_flipUpdatingGraphics(){this._updatingGraphicsTimer&&clearTimeout(this._updatingGraphicsTimer),this._updatingGraphicsTimer=setTimeout(()=>{this._updatingGraphicsTimer=null,this.notifyChange("updating")},160),this.notifyChange("updating")}};(0,O._)([(0,B.Cb)({constructOnly:!0})],it.prototype,"requestUpdateCallback",void 0),(0,O._)([(0,B.Cb)()],it.prototype,"container",void 0),(0,O._)([(0,B.Cb)({constructOnly:!0})],it.prototype,"graphics",void 0),(0,O._)([(0,B.Cb)()],it.prototype,"updating",null),(0,O._)([(0,B.Cb)()],it.prototype,"view",void 0),(0,O._)([(0,B.Cb)()],it.prototype,"updateRequested",void 0),(0,O._)([(0,B.Cb)()],it.prototype,"defaultPointSymbolEnabled",void 0),it=(0,O._)([(0,X.j)("esri.views.2d.layers.support.GraphicsView2D")],it);const Re=it}}]);
//# sourceMappingURL=8664.fbbd52ec5adfdfa4.js.map